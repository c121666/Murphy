 idea常用基础操作

# 在职成长指南：

```
一.重要的不是写代码，而是读代码

阅读代码的三个重点
1被反复使用的代码
这样的代码是一个软件的重点函数，大神的写法一定有很多精华值得学习。
2穿越时间的代码
如果一段代码10年甚至15年，都还在使用，那他的设计思想一定很棒。
3好调试的代码
一个程序的代码很容易就调试成功，说明作者项目结构能力很强，值得学习。

二.在公司成长的捷径，是通读牛人的代码

向公司牛人代码学什么？
1.牛人写代码会非常清晰、明确、易用，自带使用说明。
2.牛人写的代码会非常高效。
3.牛人写的代码通用性会很高，可扩展。
4.牛人的代码都自带风格。

三.太多的视频教程无用，多读文档和官方源码

四.重在学习过程，学习牛人的方法，但别抄答案

五.和优秀的人一起工作

六.和身边的人一起搭伴学习
```

## idea快捷键

```
快捷键：
Ctrl+O：重写方法
Ctrl+P：查看方法参数
Ctrl+Q：查看类、方法、属性注释
Idea当中有两种方法可以查看继承关系 
在Idea当中选中一个类,然后按Ctrl+H,可以快速查看当前所选类的继承关系,
同样选中一个类,按CTRL+ALT+U,即可生成当前类的继承关系图
idea 快速跳转实现类-快捷键
Ctrl + Alt + 鼠标左键
Ctrl + Alt + B

快速try-catch  CTRL+ALT+T
iter 遍历快捷键

Try…catch快捷键选中行，ctl+alt+t  alt+回车也可以（先双击选中方法名）

Alt+4 展示关闭cmd运行结果

Shift +F6 局部自动替换同名变量

Ctrl+”+/-”，当前方法展开、折叠

Ctrl+Shift+”+/-”，全部展开、折叠

Ctrl+鼠标左键查看源码

查看源码类下的所有方法Ctrl+F12

Alt+Enter 导入包，自动修正代码

自定义 快捷键：

代码补全 alt +/

删除行ctrl+y

智能补全Ctrl+Shift+空格

默认代码类快捷键：

psv main方法;

sout  System.out.println();

for会有一个fori的提示，选中然后tab键，就会自动创建一个for循环;

Ctrl+Y 删除光标所在行

Ctrl+D 复制光标所在行的内容，插入光标位置下面

Ctrl+Alt+L 格式化代码  就是对齐

Ctrl+/ 单行注释

Ctrl+Shift+/ 选中代码注释，多行注释，再按取消注释

Alt+Ins 自动生成代码，toString，get，set等方法

Alt+Shift+上下箭头移动当前代码行

方法或类注释 /**，然后按回车

移动选中的代码或者光标所在单行 按 Alt+Up 或 Alt+Down。

在下一行开一个空白行Shift+Enter

快速打开智能提示 鼠标中键

快速修改文件名F2

打包成jar 切换到项目目录下 ，用cmd 输入mvn install 即可扫描项目打包成jar，之后部署即可

部署java -jar target/springboot-0.0.1-SNAPSHOT.jar

快速生成循环5次的正序for循环i.for

快速生存循环的倒序遍历chars.forr

快速创建方法，点击demo01和括号中间快速按下alt+Enter
```

```
windows快捷键：
win+↓窗口最小化
win+←窗口分屏
win+←↓窗口四分屏
alt+F4关闭程序
chrome快捷键：
```

## 项目层次

![项目层次](D:\SQL\笔记\项目层次\项目层次.png)

## 环境变量

配置Path即可，即javac.exe所在目录，bin文件夹下

如果要用Tomcat等，那么JAVA_HOME也要配置，即带JAVA版本的安装路径

# java基础

## 01常量变量

### 注释

```
1. 单行注释：// 开头，//后的内容均为注释
2. 多行注释：/*开头，*/结尾，之间的内容均为注释，可以作为行内注释

注意：多行注释不能嵌套使用

1. 文档注释：以/**开头，*/结尾，注释内容中包含一些说明性文字及一些JavaDoc标签（后期写项目时，可以生成项目API）
```

### 标识符

```
标识符规则：

1. 必须以字母、下划线、美元符号$开头
2. 其它部分可以是字母、数字、下划线“_”、美元符号$的任意组合
3. Java标识符大小写敏感，且无长度限制
4. 标识符不可以是Java的关键字

标识符使用规范：

1. 表示类名的标识符：每个单词的首字母大写
2. 表示方法和变量的标识符：第一个单词小写，从第二个单词开始首字母大写，即“驼峰命名法“

注意Java采用Unicode这样标准的国际字符集，不采用通常语言使用的ASCII字符集

因此，这里字母的含义不仅仅是英文，还包括汉字等等。但是不建议大家使用汉字来定义标识符
```

【示例2-2】合法的标识符

```
int  a = 3;
int  _123 = 3;
int  $12aa = 3;
int  变量1 = 55;  //合法，但是不建议使用中文命名的标识符
```

【示例2-3】不合法的标识符

```
int  1a = 3;   //不能用数字开头
int  a# = 3;   //不能包含#这样的特殊字符
int  int = 3;  //不能使用关键字
```

课堂测试代码：

```
public class TestIdentifer {
     
    //能力是练出来的，不是看书看出来的。对于初学者来说，再简单的代码也一定要敲一下！
    public static void main(String[] args) {
        int  a123 = 1;
        //int  123abc = 2;        //数字不能开头
        int  $a = 3;
        int  _abc = 4;
        //int  #abc = 5;
         
        int  年龄 = 18;        //可以使用汉字，但是一般不建议
         
        //int class = 2;        //关键字不能作为标识符
         
    }
}

```

### **Java中的关键字/保留字**

```
 Java关键字是Java语言保留供内部使用的，如class用于定义类。 关键字也可以称为保留字，它们的意思是一样的，我们不能使用关键字作为变量名或方法名。
```

java定义了如下所示关键字：

| abstract   | assert       | boolean   | break      | byte   |
| ---------- | ------------ | --------- | ---------- | ------ |
| case       | catch        | char      | class      | const  |
| continue   | default      | do        | double     | else   |
| enum       | extends      | final     | finally    | float  |
| for        | goto         | if        | implements | import |
| instanceof | int          | interface | long       | native |
| new        | package      | private   | protected  | public |
| return     | strictfp     | short     | static     | super  |
| switch     | synchronized | this      | throw      | throws |
| transient  | try          | void      | volatile   | while  |

### 变量

**一、变量的本质**

```
变量本质上就是代表一个”可操作的存储空间”，空间位置是确定的，但是里面放置什么值不确定。我们可通过变量名来访问“对应的存储空间”，从而操纵这个“存储空间”存储的

值。

Java是一种强类型语言，每个变量都必须声明其数据类型。

变量作为程序中最基本的存储单元，其要素包括变量名，变量类型和作用域。变量在使用前必须对其声明, 只有在变量声明以后，才能为其分配相应长度的存储空间。

1个字节 = 8位

注意事项

1. 每个变量都有类型，类型可以是基本类型，也可以是引用类型。
2. 变量名必须是合法的标识符
3. 变量声明是一条完整的语句，因此每一个声明都必须以分号结束
```

**二、变量的分类**

| 类型               | 声明位置           | 从属于      | 生命周期                                                     |
| ------------------ | ------------------ | ----------- | ------------------------------------------------------------ |
| 局部变量           | 方法或语句块内部   | 方法/语句块 | 从声明位置开始，直到方法或语句块执行完毕，局部变量消失       |
| 成员变量(实例变量) | 类内部，方法外部   | 对象        | 对象创建，成员变量也跟着创建。对象消失，成员变量也跟着消失； |
| 静态变量  (类变量) | 类内部，static修饰 | 类          | 类被加载，静态变量就有效；类被卸载，静态变量消失。           |

 **局部变量(local variable)**

```
方法或语句块内部定义的变量。生命周期是从声明位置开始到到方法或语句块执行完毕为止。局部变量在使用前必须先声明、初始化(赋初值)再使用。

//局部变量 public void test() {   
			int i;  int j = i+5 ; // 编译出错，变量i还未被初始化 
			}   
	  	public void test() {  
		int i;   i=10;  int j = i+5 ; // 编译正确 
			} 

```

**成员变量（也叫实例变量 member variable）**

```
方法外部、类的内部定义的变量。从属于对象，生命周期伴随对象始终。如果不自行初始化，它会自动初始化成该类型的默认初始值。
```

**实例变量的默认初始值**

| 数据类型 | 实始值   |
| -------- | -------- |
| int      | 0        |
| double   | 0.0      |
| char     | ‘\u0000’ |
| boolean  | false    |

**静态变量（类变量 static variable）**

```java
使用static定义。 从属于类，生命周期伴随类始终，从类加载到卸载。如果不自行初始化，与成员变量相同会自动初始化成该类型的默认初始值

/**
 * 测试变量
 * 
 * @author 高淇
 *
 */
public class TestVariable {
 
    int a;            //成员变量, 从属于对象； 成员变量会自动被初始化
    static  int  size;   //静态变量，从属于类
     
    public static void main(String[] args) {
 
        {
            int age;        //局部变量，从属于语句块；
            age = 18;
        }
         
        int salary = 3000;    //局部变量，从属于方法
 
        int gao = 13;
        System.out.println(gao);
 
        int i;
    //    int j = i + 5; // 编译出错，变量i还未被初始化
         
    }
}


生命周期：静态变量>成员变量>局部变量
```

### 常量

```
常量，通常指的是一个固定的值，例如：1、2、3、’a’、’b’、true、false、”helloWorld”等。
在Java语言中，主要是利用关键字final来定义一个常量。 常量一旦被初始化后不能再更改其值。
```

```
**声明格式为：**

final type varName = value; 
```

```
为了更好的区分和表述，一般将1、2、3、’a’、’b’、true、false、”helloWorld”等称为字面常量，而使用final修饰的PI等称为符号常量。
```

```
变量和常量命名规范（）：
1. 所有变量、方法、类名：见名知意
2. 类成员变量：首字母小写和驼峰原则: monthSalary
3. 局部变量：首字母小写和驼峰原则
4. 常量：大写字母和下划线：MAX_VALUE
5. 类名：首字母大写和驼峰原则: Man, GoodMan
6. 方法名：首字母小写和驼峰原则:     run(), runRun()
```



## 02数据类型运算符

### 基本数据类型**primitive data type**

```
Java 是 一 种 强 类 型 语 言 ， 每 个 变 量 都 必 须 声 明 其 数 据 类 型 。 Java 的 数 据 类 型 可 分 为 两 大 类 ： 基 本 数 据 类 型 (primitive data type) 和 引 用 数 据 类 型  (reference data type) 

Java 中 定 义 了 3 类 8 种 基 本 数 据 类 型 

数值型-byte、short. int、long、 float、  double
字符型-char
布尔型-boolean
```

![7.png](C:/Users/Murphy/Pictures/1496834727293971.png)







```
常量：初始化后不可改变

标识符

字母数字下划线美元符号，不能数字

变量

变量类型

数值型 ：整数（微整数byte（1字节），短整数short（2字节），整数int（4字节），长整数long（8字节））

浮点数（单精度浮点数float（4字节）双精度浮点数double（8字节）），即不精确的数字 前者精确到7个有效数字 后者更多

布尔型（ 1位）：true false

字符型（2字节）：'单引号括起来

引用数据类型（占4字节用来表示对象的地址）
```

![image-20210724105035956](C:/Users/Murphy/Pictures/image-20210724105035956.png)

1个字节8位=2的8次方=256

拿出一位来表示符号-，所以范围就是-128～127

整型用于表示没有小数部分的数值，它允许是负数。整型的范围与运行Java代码的机器无关，这正是Java程序具有很强移植能力的原因之一。与此相反，C和C++程序需要针对不同的处理器选择最有效的整型。

| **表****2-4****整型数据类型** |                  |                                              |
| ----------------------------- | ---------------- | -------------------------------------------- |
| **类型**                      | **占用存储空间** | **表数范围**                                 |
| byte                          | 1字节            | -27 ~  27-1（-128~127）                      |
| short                         | 2字节            | -215 ~  215-1（-32768~32767）                |
| int                           | 4字节            | -231 ~  231-1 (-2147483648~2147483647)约21亿 |
| long                          | 8字节            | -263 ~  263-1                                |

**Java 语言整型常量的四种表示形式**

- 十进制整数，如：99, -500, 0
- 八进制整数，要求以 0 开头，如：015
- 十六进制数，要求 0x 或 0X 开头，如：0x15
- 二进制数，要求0b或0B开头，如：0b01110011

Java语言的整型常数默认为int型，声明long型常量可以后加‘ l ’或‘ L ’ 。

**【示例2-10】长整型常数的声明**

```
long a = 55555555; //编译成功，在int表示的范围内(21亿内)。``long b = 55555555555;//不加L编译错误，已经超过int表示的范围。
```

**我们修改成long类型的常量即可：**

```
long b = 55555555555L;
```

 **浮点型变量/常量**

带小数的数据在Java中称为浮点型。浮点型可分为float类型和double类型。

| **表****2-5****浮点型数据类型** |                  |                      |
| ------------------------------- | ---------------- | -------------------- |
| **类型**                        | **占用存储空间** | **表数范围**         |
| float                           | 4字节            | -3.403E38~3.403E38   |
| double                          | 8字节            | -1.798E308~1.798E308 |

 float类型又被称作单精度类型，尾数可以精确到7位有效数字，在很多情况下，float类型的精度很难满足需求。而double表示这种类型的数值精度约是float类型的两倍，又被称作双精度类型，绝大部分应用程序都采用double类型。浮点型常量默认类型也是double。

**Java浮点类型常量有两种表示形式**

- 十进制数形式，例如:3.14    314.0    0.314 
- 科学记数法形式，如314e2    314E2    314E-2 



**【示例2-11】使用科学记数法给浮点型变量赋值**

```
double f = 314e2; //314*10^2-->31400.0``double f2 = 314e-2; //314*10^(-2)-->3.14
```

​    float类型的数值有一个后缀F或者f ，没有后缀F/f的浮点数值默认为double类型。也可以在浮点数值后添加后缀D或者d， 以明确其为double类型。

**【示例2-12】float类型赋值时需要添加后缀F/f**

```
float f = 0.1f;
double d = 1.0/10;
System.out.println(f==d);//结果为false
```

- 浮点类型float，double的数据不适合在不容许舍入误差的金融计算领域。如果需要进行不产生舍入误差的精确数字计算，需要使用BigDecimal类。

**【示例2-13】浮点数的比较一** 

```
float f = 0.1f;``double d = 1.0/10;``System.out.println(f==d);//结果为false
```

**【示例2-14】浮点数的比较二**

```
float d1 = 423432423f;
float d2 = d1+1;
if(d1==d2){
   System.out.println("d1==d2");//输出结果为d1==d2
}else{
    System.out.println("d1!=d2");
}
```

​    运行以上两个示例，发现示例2-13的结果是“false”，而示例2-14的输出结果是“d1==d2”。这是因为由于字长有限，浮点数能够精确表示的数是有限的，因而也是离散的。 浮点数一般都存在舍入误差，很多数字无法精确表示(例如0.1)，其结果只能是接近， 但不等于。二进制浮点数不能精确的表示0.1、0.01、0.001这样10的负次幂。并不是所有的小数都能可以精确的用二进制浮点数表示。

​    java.math包下面的两个有用的类：BigInteger和BigDecimal，这两个类可以处理任意长度的数值。BigInteger实现了任意精度的整数运算。BigDecimal实现了任意精度的浮点运算。



**菜鸟雷区**

1.不要使用浮点数进行比较！很多新人甚至很多理论不扎实的有工作经验的程序员也会犯这个错误！需要比较请使用BigDecimal类



**【示例2-15】使用BigDecimal进行浮点数的比较**

```
import java.math.BigDecimal;
public class Main {
    public static void main(String[] args) {
        BigDecimal bd = BigDecimal.valueOf(1.0);
        bd = bd.subtract(BigDecimal.valueOf(0.1));
        bd = bd.subtract(BigDecimal.valueOf(0.1));
        bd = bd.subtract(BigDecimal.valueOf(0.1));
        bd = bd.subtract(BigDecimal.valueOf(0.1));
        bd = bd.subtract(BigDecimal.valueOf(0.1));
        System.out.println(bd);//0.5
        System.out.println(1.0 - 0.1 - 0.1 - 0.1 - 0.1 - 0.1);//0.5000000000000001
    }
}
```

**浮点数使用总结**

- 默认是double类型
- 浮点数存在舍入误差，数字不能精确表示。如果需要进行不产生舍入误差的精确数字计算，需要使用**BigDecimal类。**
- 避免比较中使用浮点数，需要比较请使用BigDecimal类

### 运算符

| 算术运算符   | 二元运算符 | +，-，*，/，%                    |
| ------------ | ---------- | -------------------------------- |
|              | 一元运算符 | ++，--                           |
| 赋值运算符   |            | =                                |
| 扩展运算符   |            | +=，-=，*=，/=                   |
| 关系运算符   |            | >，<，>=，<=，==，!=  instanceof |
| 逻辑运算符   |            | &&，\|\|，!，^                   |
| 位运算符     |            | &，\|，^，~ ， >>，<<，>>>       |
| 条件运算符   |            | ? :                              |
| 字符串连接符 |            | +                                |

### 算数运算符

算术运算符中+，-，*，/，%属于二元运算符，二元运算符指的是需要两个操作数才能完成运算的运算符。其中的%是取模运算符，就是我们常说的求余数操作。

**二元运算符的运算规则：**

**整数运算：**

\1. 如果两个操作数有一个为Long, 则结果也为long。

\2. 没有long时，结果为int。即使操作数全为short，byte，结果也是int。

浮点运算：

\3. 如果两个操作数有一个为double，则结果为double。

\4. 只有两个操作数都是float，则结果才为float。

**取模运算：**

1.其操作数可以为浮点数,一般使用整数，结果是“余数”，“余数”符号和左边操作数相同，如：7%3=1，-7%3=-1，7%-3=1。

算术运算符中++，--属于一元运算符，该类运算符只需要一个操作数。

**【示例2-20】一元运算符++与--**

```java
int a = 3;  
int b = a++;  //执行完后,b=3。先给b赋值，再自增。  System.out.println("a="+a+"\nb="+b);  
a = 3;  
b = ++a;  //执行完后,c=5。a先自增，再给c赋值  System.out.println("a="+a+"\nb="+b);  
```

### **赋值及其扩展运算符**

| 运算符 | 用法举例 | 等效的表达式 |
| ------ | -------- | ------------ |
| +=     | a += b   | a = a+b      |
| -=     | a -= b   | a = a-b      |
| *=     | a *= b   | a = a*b      |
| /=     | a *= b   | a = a/b      |
| %=     | a *= b   | a = a%b      |

```java
1	int a=3;
2	int b=4;
3	a+=b;//相当于a=a+b;
4	System.out.println("a="+a+"\nb="+b);
5	a=3;
6	a*=b+3;//相当于a=a*(b+3)
7	System.out.println("a="+a+"\nb="+b);
```

### 关系运算符

| 运算符 | 含义       | 示例 |
| ------ | ---------- | ---- |
| ==     | 等于       | a==b |
| !=     | 不等于     | a!=b |
| >      | 大于       | a>b  |
| <      | 小于       | a<b  |
| >=     | 大于或等于 | a>=b |
| <=     | 小于或等于 | a<=b |

**注意事项**

- =是赋值运算符，而真正的判断两个操作数是否相等的运算符是==。

- ==、!=     是所有（基本和引用）数据类型都可以使用

- \> 、>=、 <、     <= 仅针对数值类型（byte/short/int/long, float/double。以及char）

  ### 逻辑运算符

  | 运算符   |           | 说明                                        |
  | -------- | --------- | ------------------------------------------- |
  | 逻辑与   | &( 与)    | 两个操作数为true，结果才是true，否则是false |
  | 逻辑或   | \|(或)    | 两个操作数有一个是true，结果就是true        |
  | 短路与   | &&( 与)   | 只要有一个为false，则直接返回false          |
  | 短路或   | \|\|(或)  | 只要有一个为true， 则直接返回true           |
  | 逻辑非   | !（非）   | 取反：!false为true，!true为false            |
  | 逻辑异或 | ^（异或） | 相同为false，不同为true                     |

   短路与和短路或采用短路的方式。从左到右计算，如果只通过运算符左边的操作数就能够确定该逻辑表达式的值，则不会继续计算运算符右边的操作数，提高效率。

```java
//1>2的结果为false，那么整个表达式的结果即为false，将不再计算2>(3/0)
boolean c = 1>2 && 2>(3/0);
System.out.println(c);
//1>2的结果为false，那么整个表达式的结果即为false，还要计算2>(3/0)，0不能做除数，//会输出异常信息
boolean d = 1>2 & 2>(3/0);
System.out.println(d);
```

### 位运算符

| 位运算符 | 说明                             |
| -------- | -------------------------------- |
| ~        | 取反                             |
| &        | 按位与                           |
| \|       | 按位或                           |
| ^        | 按位异或                         |
| <<       | 左移运算符，左移1位相当于乘2     |
| >>       | 右移运算符，右移1位相当于除2取商 |

**【示例2-23】左移运算和右移运算**

```java
int a = 3*2*2;
int b = 3<<2; //相当于：3*2*2;
int c = 12/2/2;
int d = 12>>2; //相当于12/2/2;
```

**雷区**

\1. &和|既是逻辑运算符，也是位运算符。如果两侧操作数都是boolean类型，就作为逻辑运算符。如果两侧的操作数是整数类型，就是位运算符。

\2. 不要把“^”当做数学运算“乘方”，是“位的异或”操作。

### 字符串连接符

“+”运算符两侧的操作数中只要有一个是字符串(String)类型，系统会自动将另一个操作数转换为字符串然后再进行连接。

**【示例2-24】连接符“+”**

```java
int a=12;
        System.out.println("a="+a);//输出结果: a=12
```

### 条件运算符

**语法格式：**

| 1    | x ? y : z |
| ---- | --------- |
|      |           |

  其中 x 为 boolean 类型表达式，先计算 x 的值，若为true，则整个运算的结果为 y ，否则整个运算结果为 z 。

**【示例2-25】三目条件运算符**

```java
int score = 80; 
int x = -100;
String type =score<60?"不及格":"及格"; 
int flag = x > 0 ? 1 : (x == 0 ? 0 : -1); //按顺序执行即可
System.out.println("type= " + type);
System.out.println("flag= "+ flag);
```

### 运算符优先级问题

| 优先级 | 运算符                  | 类                     | 结合性   |
| ------ | ----------------------- | ---------------------- | -------- |
| 1      | ()                      | 括号运算符             | 由左至右 |
| 2      | !、+（正号）、-（负号） | 一元运算符             | 由左至右 |
| 2      | ~                       | 位逻辑运算符           | 由右至左 |
| 2      | ++、--                  | 递增与递减运算符       | 由右至左 |
| 3      | *、/、%                 | 算术运算符             | 由左至右 |
| 4      | +、-                    | 算术运算符             | 由左至右 |
| 5      | <<、>>                  | 位左移、右移运算符     | 由左至右 |
| 6      | >、>=、<、<=            | 关系运算符             | 由左至右 |
| 7      | ==、!=                  | 关系运算符             | 由左至右 |
| 8      | &                       | 位运算符、逻辑运算符   | 由左至右 |
| 9      | ^                       | 位运算符、逻辑运算符   | 由左至右 |
| 10     | \|                      | 位运算符、逻辑运算符   | 由左至右 |
| 11     | &&                      | 逻辑运算符             | 由左至右 |
| 12     | \|\|                    | 逻辑运算符             | 由左至右 |
| 13     | ? :                     | 条件运算符             | 由右至左 |
| 14     | =、+=、-=、*=、/=、%=   | 赋值运算符、扩展运算符 | 由右至左 |

**老鸟建议**

- 大家不需要去刻意的记这些优先级，表达式里面优先使用小括号来组织！！
- 逻辑与、逻辑或、逻辑非的优先级一定要熟悉！（逻辑非>逻辑与>逻辑或）。如：
- a||b&&c的运算结果是：a||(b&&c)，而不是(a||b)&&c

### 自动类型转换

 自动类型转换指的是容量小的数据类型可以自动转换为容量大的数据类型。如图2-6所示，黑色的实线表示无数据丢失的自动类型转换，而虚线表示在转换时可能会有精度的损失。

![1.png](D:\SQL\笔记\自动类型转换/clip_image001.png)

**图2-6 自动类型转换**

​    可以将整型常量直接赋值给byte、 short、 char等类型变量，而不需要进行强制类型转换，只要不超出其表数范围即可。

**【示例2-26】自动类型转换特例**

```java
short  b = 12;  //合法
short  b = 1234567;//非法，1234567超出了short的表数范围
```

### 强制类型转换

强制类型转换，又被称为造型，用于显式的转换一个数值的类型。在有可能丢失信息的情况下进行的转换是通过造型来完成的，但可能造成精度降低或溢出。

**语法格式：**

| 1    | (type)var |
| ---- | --------- |
|      |           |

 

运算符“()”中的type表示将值var想要转换成的目标数据类型。

**【示例2-27】强制类型转换**

```java
double x  = 3.14; 
int nx = (int)x;   //值为3
char c = 'a';
int d = c+1;
System.out.println(nx);//3
System.out.println(d);//98
System.out.println((char)d);//b
```

当将一种类型强制转换成另一种类型，而又超出了目标类型的表数范围，就会被截断成为一个完全不同的值。

**【示例2-28】强制类型转换特例**

```java
int x = 300;
byte bx = (byte)x;    //值为44
```

**新手雷区**

不能在布尔类型和任何数值类型之间做强制类型转换

### 基本类型转换时常见错误和问题

操作比较大的数时，要留意是否溢出，尤其是整数操作时。

**【示例2-29】常见问题一**

```java
int money = 1000000000; //10亿
int years = 20;
//返回的total是负数，超过了int的范围
int total = money*years;
System.out.println("total="+total);//-1474836480
//返回的total仍然是负数。默认是int，因此结果会转成int值，再转成long。但是已经发生//了数据丢失
long total1 = money*years; 
System.out.println("total1="+total1);//-1474836480
//返回的total2正确:先将一个因子变成long，整个表达式发生提升。全部用long来计算。
long total2 = money*((long)years); 
System.out.println("total2="+total2);//20000000000
```

图2-8 示例2-29运行效果图

- L和l 的问题：
            不要命名名字为l的变量，l容易和1混淆。long类型使用大写L不要用小写。

**【示例2-30】常见问题二**

```java
int l = 2; //分不清是L还是1,
long a = 23451l;//建议使用大写L
System.out.println(l+1);
```

简单的键盘输入和输出

 为了我们能写出更加复杂的程序，可以让我们的程序和用户可以通过键盘交互，我们先学习一下简单的键盘输入和输出。

**【示例2-31】使用Scanner获取键盘输入**

```java
import  java.util.Scanner;
/**
 * 测试获得键盘输入
 * @author 高淇
 *
 */
public class TestScanner {
    public static void main(String[] args) {
        Scanner   scanner =  new Scanner(System.in);
        System.out.println("请输入名字：");
        String   name =  scanner.nextLine();
        System.out.println("请输入你的爱好：");
        String  favor = scanner.nextLine();
        System.out.println("请输入你的年龄：");
        int   age = scanner.nextInt();
         
        System.out.println("###############");
        System.out.println(name);
        System.out.println(favor);
        System.out.println("来到地球的天数："+age*365);
        System.out.println("离开地球的天数："+(72-age)*365);
         
    }
}
```

## 03控制语句

### 选择结构

主要的选择结构有：if选择结构和switch多选择结构。有如下结构：

  if单选择结构

  if-else双选择结构

  if-else if-else多选择结构

  switch结构

### if单选结构

if(关系表达式)｛

语句体;

｝

首先判断关系表达式看其结果是true还是false

如果是true就执行语句体

如果是false就不执行语句体

![计算机生成了可选文字: 关系表达式 true 讠吾句体 其．他讠吾句 false](data:image/png;base64,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)

 

```java
public static void main(String[] args){
System.out.println("开始");
// 定义两个变量
北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090
2.2 判断语句2--if...else
if语句第二种格式： if...else
执行流程
首先判断关系表达式看其结果是true还是false
如果是true就执行语句体1
如果是false就执行语句体2
int a = 10;
int b = 20;
//变量使用if判断
if (a == b){
System.out.println("a等于b");
}
int c = 10;
if(a == c){
System.out.println("a等于c");
}
System.out.println("结束");
｝
```

### If-else多选择结构

```
二者选其一
if(关系表达式)｛
语句体;
｝


判断语句
if (判断条件1) {
执行语句1;
} else if (判断条件2) {
执行语句2;
}
...
}else if (判断条件n) {
执行语句n;
} else {
执行语句n+1;
}


```

```java
练习代码
public class Demo04IfelseExt 
{
	public static void main(String[] args) 
	{
		int x = -10;
		int y;

		if (x >= 3)
		{
			y = 2 * x +1;
		}else if (-1 < x && x < 3)
		{
			y = 2 * x;
		}else {
		    y = 2 * x - 1;
		}
            System.out.println("结果是" + y);
	}
}

```

```java
三元运算符可以替换if -else
//使用三元运算符和标准的if-else语句分别实现：区别个数字中的最大值

public class Demo06Max 
{
	public static void main(String[] args) 
	{
		int a = 105;
		int b = 20;
		//首先使用三元运算符实现
		//int max = a > b ? a:b;
		int max;
		if (a>b)
		{
			max = a;
		}else {
			max = b;
			}
			    System.out.println("最大值" + max);
	}
}

```

### switch多选择结构

```
switch(表达式) {
case 常量值1:
语句体1;
break;
case 常量值2:
语句体2;
break;
...
default:
语句体n+1;
break;
}

```

```java
练习代码
public class Demo07Switch
{
	public static void main(String[] args) 
	{
		int num = 9;
        switch (num)
        {
        case 1:
			System.out.println("星期一");
            break;
		case 2:
			System.out.println("星期二");
            break;
		case 3:
			System.out.println("星期三");
            break;
		case 4:
			System.out.println("星期四");
            break;
		case 5:
			System.out.println("星期五");
            break;
		case 6:
			System.out.println("星期六");
            break;
		case 7:
			System.out.println("星期日");
            break;
		default:
			System.out.println("数据错误!");
		    break;

        }
		
	}
}

/*
switch语句使用的注意事项：

1. 多个case后面的数值不可以重复。

2. switch后面小括号当中只能是下列数据类型：
基本数据类型：byte/short/char/int
引用数据类型：String字符串、enum枚举   JDK1.7增加

3. switch语句格式可以很灵活：前后顺序可以颠倒，而且break语句还可以省略。
“匹配哪一个case就从哪一个位置向下执行，直到遇到了break或者整体结束为止。”
*/
public class Demo08SwitchNotice {
	public static void main(String[] args) {
		int num = 2;
		switch (num) {
			case 1:
				System.out.println("你好");
				break;
			case 2:
				System.out.println("我好");
				// break;
			case 3:
				System.out.println("大家好");
				break;
			default:
				System.out.println("他好，我也好。");
				break;
		} // switch
	}
}

```

### 循环结构

循环结构的基本组成部分，一般可以分成四部分：

 

1. 初始化语句：在循环开始最初执行，而且只做唯一一次。

2. 条件判断：如果成立，则循环继续；如果不成立，则循环退出。

3. 循环体：重复要做的事情内容，若干行语句。

4. 步进语句：每次循环之后都要进行的扫尾工作，每次循环结束之后都要执行一次。

### for循环 

for(初始化表达式①; 布尔表达式②; 步进表达式④){

​	循环体③

}

 

执行流程

执行顺序：①②③④>②③④>②③④…②不满足为止。

①负责完成循环变量初始化

②负责判断是否满足循环条件，不满足则跳出循环

③具体执行的语句

④循环后，循环条件所涉及变量的变化情况

```java
*/
public class Demo09For {
	public static void main(String[] args) {
		for (int i = 1; i <= 100; i++) {
			System.out.println("我错啦！原谅我吧！" + i);
		}
		System.out.println("程序停止");
	}
}
练习
public class Demo09For
{
	public static void main(String[] args) 
	{  
		//++单独使用，没有区别，习惯用++在后
		for (int i = 1 ; i <= 100; i++)
		{ 
			    System.out.println(i + "我错了，原谅我吧！");
		}
		    System.out.println("程序停止 ");
	}
}

```

### while循环

```
标准格式
while （条件判断）{
    循环体
}

扩展格式
while(条件判断){
  循环体；
  步进语句；
}
```

### Do-while循环

```
初始化表达式①
do{
循环体③
步进表达式④
}while(布尔表达式②);

do {
    循环体
}while(条件判断);

扩展格式：
do{
   循环体
   步进语句
}while (条件判断);

```

```java
练习
public class Demo11DoWhile 
{
	public static void main(String[] args) 
	{
		int i =1;
		do
		{
			    System.out.println("原谅你了" + i);
                i++;
		}
		while (i <= 100);
	}
}


//练习
/*
求出1-100之间的偶数和。
*/
public class Demo12HundreSum 
{
	public static void main(String[] args) 
	{
	   int sum = 0;
       for (int i = 1;i <= 100; i++)
       {
            if(i % 2 == 0){
			    sum += i;
			} 
       } System.out.println("结果是" + sum);
	}
}

```

### 三种循环的区别

```
1.如果条件判断从来没有满足过 for 和while将会执行0次，do-while将会循环不止一次
2.for循环的变量在小括号当中定义，只有内部才可以使用。while循环和do-while循环初始化语句本来就在外面，所以出来循环之后还可以继续使用。
```

### break和continue语句

```java
break关键字的用法有常见的两种：
1.可以用在switch语句当中，一旦执行，整个switch语句立刻结束。
2.还可以用在循环语句当中，一旦执行，整个循环语句立刻结束。打断循环。
关于循环的选择，有一个小建议：
凡是次数确定的场景多用for循环；否则多用while循环。|

练习：
public class Demo14Break
{
	public static void main(String[] args) 
	{
		for (int i = 1;i <=10 ;i++ )
		{
			if (i == 4)
			{
				break;
			}
			    System.out.println("Hello" + i);
		}
	}
}


另一种循环控制语句是continue关键字。
一旦执行，立刻跳过当前次循环剩余内容，马上开始下一次循环

练习：
public class Demo15Continue
{
	public static void main(String[] args) 
	{
		 for (int i = 1;i <= 10;i++ )
		 {
			     if (i == 4)
			     {
					 continue;
			     }
			     System.out.println(i + "楼到了。");
		 }
	}
}

```

### 死循环的标准格式

```
死循环的标准格式：
while（true）{
循环体
}
```

### 嵌套循环

```java
练习
public class Demo17LoopHourAndMinute
{
	public static void main(String[] args) 
	{
		for (int hour = 0;hour < 24; hour++ )
		{
			for (int minute = 0;minute <60;minute++ )
			{
                 System.out.println(hour + "点" + minute + "分");
			}
		}
	}
}

```

## 04方法

### 方法的使用

```
定义一个方法的格式：
Public static void 方法名称(){
     方法体
}
方法的命名规则和变量一样，使用小驼峰
方法体：也就是大括号当中可以包含任意条语句

注意事项：
1.方法定义的先后顺序无所谓。
2.方法的定义不能产生嵌套包含关系。3.方法定义好了之后，不会执行的。如果要想执行，一定要进行方法的调用。


```

### 方法的定义格式

```
方法其实就是若干语句的功能集合。

参数（原料）：就是进入方法的数据。
返回值（产出物）：就是从方法中出来的数据。
定义方法的完整格式：

修饰符  返回值  类型方法名称（参数类型    参数名称，…）{
    方法体
     return 返回值；
}

修饰符：现阶段的固定写法，public static
返回值类型：也就是方法最终产生的数据结果是什么类型
方法名称：方法的名字，规则和变量一样，小驼峰
参数类型：进入方法的数据是什么类型
参数名称：进入方法的数据对应的变量名称
PS：参数如果有多个，使用逗号进行分隔
方法体：方法需要做的事情，若干行代码
return：两个作用，第一停止当前方法，第二将后面的返回值还给调用处
返回值：也就是方法执行后最终产生的数据结果
注意：return后面的“返回值”，必须和方法名称前面的“返回值类型”，保持对应。


```

### 方法的三种调用格式

```
方法的三种调用格式。
1.单独调用：方法名称（参数）；
2.打印调用：System.out.println（方法名称（参数））；
3.赋值调用：数据类型  变量名称  =  方法名称（参数）；

注意：此前学习的方法，返回值类型固定写为void，这种方法只能够单独调用，不能进行打印调用或者赋值调用。*
```

### 方法的调用图解

![03-方法调用流程图解](C:/Users/Murphy/Pictures/03-方法调用流程图解.png)

### 对比有返回值和无返回值

![04-方法返回值的有无](C:/Users/Murphy/Pictures/04-方法返回值的有无.png)

### 判断两个数字是否相同

```java
定义一个方法：用来判断两个数字是否相同
Public  class  Demo01MethodSame{
Public  static  void  main(String[]  args){
System.out.println(isSame(10,20));
}
Public  static  boolean  isSame(inta,intb){
//booleansame=a==b;
/*if(a==b){
same=true;
}else{
same=false;
}*/
Return  a==b;
}
}

```

### 方法调用注意事项

```
使用方法的时候，注意事项：
1.方法应该定义在类当中，但是不能在方法当中再定义方法。不能嵌套。
2.方法定义的前后顺序无所谓。
3.方法定义之后不会执行，如果希望执行，一定要调用：单独调用、打印调用、赋值调用。
4.如果方法有返回值，那么必须写上“return返回值；”，不能没有。
5.return后面的返回值数据，必须和方法的返回值类型，对应起来。
6.对于一个void没有返回值的方法，不能写return后面的返回值，只能写return自己。
7.对于void方法当中最后一行的return可以省略不写。
8.一个方法当中可以有多个return语句，但是必须保证同时只有一个会被执行到，两个return不能连写。
```

### 方法的重载

```java
/*
*方法的重载overload，多个方法的名称一样，但是参数列表不一样
*好处，只需要记住唯一一个方法名称，就可以实现类似的功能
*

**/
Public  class  Demo01MethodOverload{
Public  static  void  main(String[]  args){
/*System.out.println(sumTuo(1,2));
System.out.println(sumThree(1,2,3));
System.out.println(sumFour(1,2,3,4));*/
System.out.println(sum(1,2));
System.out.println(sum(1,2,3));
System.out.println(sum(1,2,3,4));
}

Public  static  int  sum(int  a,int  b){
System.out.println("有两个参数的方法");
returna+b;
}

Public  static  int  sum(int  a,intb,int  c){
System.out.println("有三个参数的方法");
returna+b+c;
}

Public  static  int  sum(int  a,int  b,int  c,int  d){
System.out.println("有四个参数的方法");
returna+b+c+d;
}
}

```

### 重载注意事项

```
方法重载与下列因素相关：
1.参数个数不同
2.参数类型不同
3.参数的多类型顺序不同

方法重载与下列因素无关：
1.与参数的名称无关
2.与方法的返回值类型无关
```

## 05_数组

### 概念

```
数组：是一种容器，可同时以存储多个数据值；

数组的特点：
1.数组是一种引用数据类型
2数组当中的多个数据，类型必须统一
3.数组的长度在程序运行期间不可改变

引用数据类型为java两大数据类型之一，引用数据型在被床架时，首先要在zd栈上给其引用（句柄）分配一块内存，而对象的具体信息都存储在堆内存上，然后由栈上面的引用指向堆中对象的地址。
引用数据类型包括：类、接口类型、数组类型、枚举类型、注解类型，字符串型。java另一大数据类型为基本数据类型，其包括包括数值型，字符型和布尔型。
引用类型 由类型的实际值引用（类似于指针）表示的数据类型。如果为某个变量分配一个引用类型，则该变量将引用（或“指向”）原始值。不创建任何副本。引用类型包括类、接口、委托和装箱值类型。

```

### 定义格式：1.动态初始化

```
数组的初始化：在内存当中创建一个数组，并且向其中赋予一些默认值。

两种常见的初始化方式：

1.动态初始化（指定长度）
2.静态初始化（指定内容）

动态初始化数组的格式：

数据类型[]    数组名称    =    new    数据类型[数组长度]；

解析含义：
左侧数据类型：也就是数组当中保存的数据，全都是统一的什么类型
左侧的中括号：代表我是一个数组
左侧数组名称：给数组取一个名字
右侧的new：代表创建数组的动作
右侧数据类型：必须和左边的数据类型保持一致
右侧中括号的长度：也就是数组当中，到底可以保存多少个数据，是一个int数字

```

```java
练习
publicclassDemo01Array{
publicstaticvoidmain(String[]args){
/*intscore1=100;
intscore2=98;
intscore3=99;*/
int[]arrayA=newint[5];
double[]arrayB=newdouble[5];
String[]arrayC=newString[5];
}
}
```

### 2.静态初始化

```
静态初始化基本格式：
数据类型[]    数组名称    =    new    数据类型[ ]{元素1,元素2,….}；

注意事项：
虽然静态初始化没有直接告诉长度，但是根据大括号里面的元素具体内容，也可以自动推算出来长度。

```

### 3.省略的静态初始化

```
省略格式：
数据类型[]数组名称={元素1，元素2，…}；

注意事项：
1.静态初始化没有直接指定长度，但是仍然会自动推算得到长度。
2.静态初始化标准格式可以拆分成为两个步骤。
3.动态初始化也可以拆分成为两个步骤。
4.静态初始化一旦使用省略格式，就不能拆分成为两个步骤了。*

使用建议：
如果不确定数组当中的具体内容，用动态初始化；
否则，已经确定了具体的内容，用静态初始化。

```

```java
public class Demo03Array{
//省略格式
publicstaticvoidmain(String[]args){

int[]arrayA=newint[]{1,2};

//静态初始化标准格式可以拆分成为两个步骤。
int[]arrayB;
arrayB=newint[]{1,2};

//动态初始化也可以拆分成为两个步骤。
int[]arrayC;
arrayC=newint[2];
}
}
```

### 访问数组元素进行获取

```
直接打印数组名称，得到的是数组对应的：内存地址哈希值。


访问数组元素的格式：数组名称[索引值]
索引值：就是一个int数字，代表数组当中元素的编号。
【注意】索引值从0开始，一直到“组的长度-1”为止。
```

```java
public class DemoArrayUse{
public static void main(String[]args){
int[]array={10,20,30};
//System.out.println(array);
System.out.println(array[0]);
System.out.println(array[1]);
System.out.println(array[2]);
System.out.println("============");
intnum=array[1];
System.out.println(num);
}
}
```

### 访问数组元素进行赋值

```
使用动态初始化数组的时候，其中的元素将会自动拥有一个默认值。规则如下：
如果是整数类型，那么默认为0；
如果是浮点类型，那么默认为0.0；
如果是字符类型，那么默认为‘\u0000'；Unicode十六进制，打印不可见
如果是布尔类型，那么默认为false；
如果是引用类型，那么默认为null。

注意事项：
静态初始化其实也有默认值的过程，只不过系统自动马上将默认值替换成为了大括号当中的具体数值。
```

```java
public class Demo05Arrayuse{
	public static void main(String[]args){
	//动态初始化一个数组
	int[]array=newint[3];

	System.out.println(array[0]);
	System.out.println(array[1]);
	System.out.println(array[2]);
	System.out.println("=========");

	array[1]=123;
	System.out.println(array[0]);
	System.out.println(array[1]);
	System.out.println(array[2]);
	}
}
```

### java中的内存划分

![01-Java中的内存划分](C:/Users/Murphy/Pictures/01-Java中的内存划分.png)

```
JVM的内存划分：
区域名称                                                    作用
寄存器              给CPU使用，和我们开发无关。
本地方法栈     JVM在使用操作系统功能的时候使用，和我们开发无关。
方法区             存储可以运行的class文件。
堆内存             存储对象或者数组，new来创建的，都存储在堆内存。
方法栈             方法运行时使用的内存，比如main方法运行，进入方法栈中执行。
```

### 一个数组的内存图

```java
publicclassDemo01ArrayOne{


publicstaticvoidmain(String[]args){
int[]array=newint[3];
System.out.println(array);
System.out.println(array[0]);
System.out.println(array[1]);
System.out.println(array[2]);

//改变数组当中元素的内容
array[1]=10;
array[1]=20;
System.out.println(array);
System.out.println(array[0]);
System.out.println(array[1]);
System.out.println(array[2]);
}
}
输出结果
[I@50cbc42f
0
0
0
[I@50cbc42f
0
20

```

![02-只有一个数组的内存图](C:/Users/Murphy/Pictures/02-只有一个数组的内存图.png)

### 两个数组的内存图

![03-有两个独立数组的内存图](C:/Users/Murphy/Pictures/03-有两个独立数组的内存图.png)

### 数组索引越界异常

![image-20211213173624902](C:/Users/Murphy/Pictures/image-20211213173624902.png)

### 空指针异常

![image-20211213173652324](C:/Users/Murphy/Pictures/image-20211213173652324.png)

### 获取数组的长度

![array.length](C:/Users/Murphy/Pictures/array.length.png)



![05-数组的长度运行期间不可改变](C:/Users/Murphy/Pictures/05-数组的长度运行期间不可改变.png)

### 数组的遍历

![数组的遍历](C:/Users/Murphy/Pictures/数组的遍历.png)

### 求数组最值

![求数组最值](C:/Users/Murphy/Pictures/求数组最值.png)

### 数组元素反转

```java
package cn.itcast.day05.demo03;

/*
数组元素的反转：
本来的样子：[1, 2, 3, 4]
之后的样子：[4, 3, 2, 1]

要求不能使用新数组，就用原来的唯一一个数组。
 */
public class Demo07ArrayReverse {

    public static void main(String[] args) {
        int[] array = { 10, 20, 30, 40, 50 };

        // 遍历打印数组本来的样子
        for (int i = 0; i < array.length; i++) {
            System.out.println(array[i]);
        }
        System.out.println("============");

        /*
        初始化语句：int min = 0, max = array.length - 1
        条件判断：min < max
        步进表达式：min++, max--
        循环体：用第三个变量倒手
         */
        for (int min = 0, max = array.length - 1; min < max; min++, max--) {
            int temp = array[min];
            array[min] = array[max];
            array[max] = temp;
        }

        // 再次打印遍历输出数组后来的样子
        for (int i = 0; i < array.length; i++) {
            System.out.println(array[i]);
        }
    }

}

```

### 数组作为方法参数-传递地址

```java
public class Demo01ArrayParam{
	public static void main(String[]args){
		int[]array={10,20};
		printArray(array);
		System.out.println("aaa");
}

public static void printArray(intarray[]){
	for(inti=0;i<array.length;i++){
		System.out.println(array[i]);
		}
	}
}

```

### 数组作为方法返回值

```
一个方法可以有e、1、多个参数；但是只能有e或者1个返回值，不能有多个返回值。
如果希望一个方法当中产生了多个结果数据进行返回，怎么办？
解决方案：使用一个数组作为返回值类型即可。

任何数据类型都能作为方法的参数类型，或者返回值类型。
数组作为方法的参数，传递进去的其实是数组的地址值。
数组作为方法的返回值，返回的其实也是数组的地址值。
```

```
public class Demo02ArrayReturn {

    public static void main(String[] args) {
        int[] result = calculate(10, 20, 30);

        System.out.println("main方法接收到的返回值数组是：");
        System.out.println(result); // 地址值

        System.out.println("总和：" + result[0]);
        System.out.println("平均数：" + result[1]);
    }

    public static int[] calculate(int a, int b, int c) {
        int sum = a + b + c; // 总和
        int avg = sum / 3; // 平均数
        // 两个结果都希望进行返回

        // 需要一个数组，也就是一个塑料兜，数组可以保存多个结果
        /*
        int[] array = new int[2];
        array[0] = sum; // 总和
        array[1] = avg; // 平均数
        */

        int[] array = { sum, avg };
        System.out.println("calculate方法内部数组是：");
        System.out.println(array); // 地址值
        return array;
    }

}
```

## 06_类与对象、封装、构造方法

### 面向对象概述

```java
public class Demo01PrintArray{
    public static void main(String[]args){
        int[]array={10,20,30,40,50,60};
        //要求打印格式为[10,20,30,40,50,]
        //面向过程
        System.out.print("[");
        for(inti=0;i<array.length;i++){
            if(i==array.length-1){
                System.out.print(array[i]+"]");
                break;
            }

            System.out.print(array[i]+",");
        }

        System.out.println("===========*===========");
        //面向对象
        System.out.println(Arrays.toString(array));
    }
}
```

### 类和对象

```
类与对象的关系
·类是对一类事物的描述，是抽象的。
·对象是一类事物的实例，是具体的。
·类是对象的模板，对象是类的实体。

事物：
属性：事物的状态信息。
行为：事物能够做什么。
Java中用class描述事物也是如此：
成员变量：对应事物的属性成员方法：对应事物的行为
```

### 类的定义

```
public class ClassName {
//成员变量
//成员方法
}

注意事项：
1成员变量是直接定义在类当中的，在方法外边。
2.成员方法不要写static关键字。
```

```
public class Student{

    String name;
    int age;

    public void eat(){
        System.out.println("吃饭");
    }

    public void sleep(){
        System.out.println("睡觉");
    }

    public void study(){
        System.out.println("学习");
    }
}
```

### 对象的创建及其使用

```
通常情况下，一个类并不能直接使用，需要根据类创建一个对象，才能使用。

1.导包：也就是指出需要使用的类，在什么位置。
import包名称.类名称；
import cn.itcast.day06.demoe1.Student；
对于和当前类属于同一个包的情况，可以省略导包语句不写。

2.创建，格式：
类名称对象名=new类名称（）；
Student stu=new Student（）；

3.使用，分为两种情况：
使用成员变量：对象名.成员变量名
使用成员方法：对象名.成员方法名（参数）
（也就是，想用谁，就用对象名点儿谁。）
```

```java
public class Demo02Student {

    public static void main(String[] args) {
        // 1. 导包。
        // 我需要使用的Student类，和我自己Demo02Student位于同一个包下，所以省略导包语句不写

        // 2. 创建，格式：
        // 类名称 对象名 = new 类名称();
        // 根据Student类，创建了一个名为stu的对象
        Student stu = new Student();

        // 3. 使用其中的成员变量，格式：
        // 对象名.成员变量名
        System.out.println(stu.name); // null
        System.out.println(stu.age); // 0
        System.out.println("=============");

        // 改变对象当中的成员变量数值内容
        // 将右侧的字符串，赋值交给stu对象当中的name成员变量
        stu.name = "赵丽颖";
        stu.age = 18;
        System.out.println(stu.name); // 赵丽颖
        System.out.println(stu.age); // 18
        System.out.println("=============");

        // 4. 使用对象的成员方法，格式：
        // 对象名.成员方法名()
        stu.eat();
        stu.sleep();
        stu.study();
    }

}
```

### 手机类练习

```java
package cn.itcast.day06.demo02;

public class Demo01PhoneOne {

    public static void main(String[] args) {
        // 根据Phone类，创建一个名为one的对象
        // 格式：类名称 对象名 = new 类名称();
        Phone one = new Phone();
        System.out.println(one.brand); // null
        System.out.println(one.price); // 0.0
        System.out.println(one.color); // null
        System.out.println("=========");

        one.brand = "苹果";
        one.price = 8388.0;
        one.color = "黑色";
        System.out.println(one.brand); // 苹果
        System.out.println(one.price); // 8388.0
        System.out.println(one.color); // 黑色
        System.out.println("=========");

        one.call("乔布斯"); // 给乔布斯打电话
        one.sendMessage(); // 群发短信
    }

}

```

### 一个对象的内存图

![01-只有一个对象的内存图](C:/Users/Murphy/Pictures/01-只有一个对象的内存图.png)

### 两个对象使用同一个方法的内存图

![02-两个对象使用同一个方法的内存图](C:/Users/Murphy/Pictures/02-两个对象使用同一个方法的内存图.png)

### 两个引用指向同一个对象的内存图

![03-两个引用指向同一个对象的内存图](C:/Users/Murphy/Pictures/03-两个引用指向同一个对象的内存图.png)

### 使用对象类型作为方法的参数

![04-使用对象类型作为方法的参数](C:/Users/Murphy/Pictures/04-使用对象类型作为方法的参数.png)

### 使用对象类型作为方法的返回值

![05-使用对象类型作为方法的返回值](C:/Users/Murphy/Pictures/05-使用对象类型作为方法的返回值.png)

### 成员变量和局部变量的区别

```java
1.定义的位置不一样【重点】
局部变量：在方法的内部
成员变量：在方法的外部，直接写在类当中
2.作用范围不一样【重点】
局部变量：只有方法当中才可以使用，出了方法就不能再用成员变量：整个类全都可以通用。
3.默认值不一样【重点】
package cn.itcast.day06.demo03;

/*
局部变量和成员变量

1. 定义的位置不一样【重点】
局部变量：在方法的内部
成员变量：在方法的外部，直接写在类当中

2. 作用范围不一样【重点】
局部变量：只有方法当中才可以使用，出了方法就不能再用
成员变量：整个类全都可以通用。

3. 默认值不一样【重点】
局部变量：没有默认值，如果要想使用，必须手动进行赋值
成员变量：如果没有赋值，会有默认值，规则和数组一样

4. 内存的位置不一样（了解）
局部变量：位于栈内存
成员变量：位于堆内存

5. 生命周期不一样（了解）
局部变量：随着方法进栈而诞生，随着方法出栈而消失
成员变量：随着对象创建而诞生，随着对象被垃圾回收而消失
 */
public class Demo01VariableDifference {

    String name; // 成员变量

    public void methodA() {
        int num = 20; // 局部变量
        System.out.println(num);
        System.out.println(name);
    }

    public void methodB(int param) { // 方法的参数就是局部变量
        // 参数在方法调用的时候，必然会被赋值的。
        System.out.println(param);

        int age; // 局部变量
//        System.out.println(age); // 没赋值不能用

//        System.out.println(num); // 错误写法！
        System.out.println(name);
    }

}

```

面向对象三大特征之封装性

```java
package cn.itcast.day06.demo03;

/*
面向对象三大特征：封装、继承、多态。

封装性在Java当中的体现：
1. 方法就是一种封装
2. 关键字private也是一种封装

封装就是将一些细节信息隐藏起来，对于外界不可见。
 */
public class Demo02Method {

    public static void main(String[] args) {
        int[] array = {5, 15, 25, 20, 100};

        int max = getMax(array);
        System.out.println("最大值：" + max);
    }

    // 给我一个数组，我还给你一个最大值
    public static int getMax(int[] array) {
        int max = array[0];
        for (int i = 1; i < array.length; i++) {
            if (array[i] > max) {
                max = array[i];
            }
        }
        return max;
    }


```

### private关键字的作用及使用

```java
/*
问题描述：定义Person的年龄时，无法阻止不合理的数值被设置进来。
解决方案：用private关键字将需要保护的成员变量进行修饰。

一旦使用了private进行修饰，那么本类当中仍然可以随意访问。
但是！超出了本类范围之外就不能再直接访问了。

间接访问private成员变量，就是定义一对儿Getter/Setter方法

必须叫setXxx或者是getXxx命名规则。
对于Getter来说，不能有参数，返回值类型和成员变量对应；
对于Setter来说，不能有返回值，参数类型和成员变量对应。
 */
public class Person {

    String name; // 姓名
    private int age; // 年龄

    public void show() {
        System.out.println("我叫：" + name + "，年龄：" + age);
    }

    // 这个成员方法，专门用于向age设置数据
    public void setAge(int num) {
        if (num < 100 && num >= 9) { // 如果是合理情况
            age = num;
        } else {
            System.out.println("数据不合理！");
        }
    }

    // 这个成员方法，专门私语获取age的数据
    public int getAge() {
        return age;
    }

}

//调用

package cn.itcast.day06.demo03;

public class Demo03Person {

    public static void main(String[] args) {
        Person person = new Person();
        person.show();

        person.name = "赵丽颖";
//        person.age = -20; // 直接访问private内容，错误写法！
        person.setAge(20);
        person.show();
    }
}
```

### 学生类练习

```java
对于基本类型当中的boolean值，Getter方法一定要写成isxxx的形式，而setXxx规则不变。

package cn.itcast.day06.demo03;

/*
对于基本类型当中的boolean值，Getter方法一定要写成isXxx的形式，而setXxx规则不变。
 */
public class Student {

    private String name; // 姓名
    private int age; // 年龄
    private boolean male; // 是不是爷们儿

    public void setMale(boolean b) {
        male = b;
    }

    public boolean isMale() {
        return male;
    }

    public void setName(String str) {
        name = str;
    }

    public String getName() {
        return name;
    }

    public void setAge(int num) {
        age = num;
    }

    public int getAge() {
        return age;
    }
}

    
packagecn.itcast.day06.Demo03;

Public  class  Demo04Student{
Public  static  void  main(String[]  args){
Student  stu  =  new  Student();
stu.setName("鹿晗");
stu.setAge(18);
stu.setMale(true);

System.out.println("姓名"  +  stu.getName());
System.out.println("年龄"  +  stu.getAge());
System.out.println("是不是爷们儿"  +  stu.isMale());
}
}

```

### this关键字的作用

```java
/*
当方法的局部变量和类的成员变量重名的时候，根据“就近原则”，优先使用局部变量。
如果需要访问本类当中的成员变量，需要使用格式：
this.成员变量名

“通过谁调用的方法，谁就是this。”
 */
public class Person {

    String name; // 我自己的名字

    // 参数name是对方的名字
    // 成员变量name是自己的名字
    public void sayHello(String name) {
        System.out.println(name + "，你好。我是" + this.name);
        System.out.println(this);
    }

}

public class Demo01Person {

    public static void main(String[] args) {
        Person person = new Person();
        // 设置我自己的名字
        person.name = "王健林";
        person.sayHello("王思聪");

        System.out.println(person); // 地址值
    }
}
```

### 构造方法

```java
/*
构造方法是专门用来创建对象的方法，当我们通过关键字new来创建对象时，其实就是在调用构造方法。
格式：
public 类名称(参数类型 参数名称) {
    方法体
}

注意事项：
1. 构造方法的名称必须和所在的类名称完全一样，就连大小写也要一样
2. 构造方法不要写返回值类型，连void都不写
3. 构造方法不能return一个具体的返回值
4. 如果没有编写任何构造方法，那么编译器将会默认赠送一个构造方法，没有参数、方法体什么事情都不做。
public Student() {}
5. 一旦编写了至少一个构造方法，那么编译器将不再赠送。
6. 构造方法也是可以进行重载的。
重载：方法名称相同，参数列表不同。
 */
public class Student {

    // 成员变量
    private String name;
    private int age;

    // 无参数的构造方法
    public Student() {
        System.out.println("无参构造方法执行啦！");
    }

    // 全参数的构造方法
    public Student(String name, int age) {
        System.out.println("全参构造方法执行啦！");
        this.name = name;
        this.age = age;
    }

    // Getter Setter
    public void setName(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public int getAge() {
        return age;
    }

}

packagecn.itcast.day06.Demo04;

Public class Demo01Student{
Public static void main (String[] args){
Student stu1= new Student();//无参构造
System.out.println("==============");
Students tu2 = new Student("Jack",18);//全参构造
System.out.println("姓名"+stu2.name);
System.out.println("年龄"+stu2.age);
//如果需要改变对象当中的成员变量的内容，任然需要使用setXxx方法
stu2.setAge(20);
System.out.println("姓名"+stu2.name+"年龄"+stu2.age);
}
}

```

### 定义一个标准的类

```java
/*
一个标准的类通常要拥有下面四个组成部分：

1. 所有的成员变量都要使用private关键字修饰
2. 为每一个成员变量编写一对儿Getter/Setter方法
3. 编写一个无参数的构造方法
4. 编写一个全参数的构造方法

这样标准的类也叫做Java Bean
 */
public class Student {

    private String name; // 姓名
    private int age; // 年龄

    public Student() {
    }

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}

```

## 07_Scanner类、Random类、ArrayList类

### 键盘输入两个数字求和

```
import java.util.Scanner;

/*
题目：
键盘输入两个int数字，并且求出和值。

思路：
1. 既然需要键盘输入，那么就用Scanner
2. Scanner的三个步骤：导包、创建、使用
3. 需要的是两个数字，所以要调用两次nextInt方法
4. 得到了两个数字，就需要加在一起。
5. 将结果打印输出。
 */
public class Demo02ScannerSum {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        System.out.println("请输入第一个数字：");
        int a = sc.nextInt();
        System.out.println("请输入第二个数字：");
        int b = sc.nextInt();

        int result = a + b;
        System.out.println("结果是：" + result);
    }
}
```

### 键盘输入三个数求最大值-三元运算符

```java
public class Demo03ScannerMax {
  public static void main(String[] args) {
    Scannersc = newScanner(System.in);
    System.out.println("请输入第一个数字");
    inta = sc.nextInt();
    System.out.println("请输入第二个数字");
    intb = sc.nextInt();
    System.out.println("请输入第三个数字");
    intc = sc.nextInt();
    inttemp = a > b ? a : b;
    intmax = temp > c ? temp : c;
    System.out.println("最大值是" + max);
    /*if(a>b){
    if(a>c){
    System.out.println("最大值是"+a);
    }else{
    System.out.println("最大值是"+c);
    }
    }else{
    if(b>c){
    System.out.println("最大值是"+b);
    }else{
    System.out.println("最大值是"+c);
    }
    }*/
  }
}

```

### Scanner的使用步骤

```java
import java.util.Scanner; // 1. 导包

/*
Scanner类的功能：可以实现键盘输入数据，到程序当中。

引用类型的一般使用步骤：

1. 导包
import 包路径.类名称;
如果需要使用的目标类，和当前类位于同一个包下，则可以省略导包语句不写。
只有java.lang包下的内容不需要导包，其他的包都需要import语句。

2. 创建
类名称 对象名 = new 类名称();

3. 使用
对象名.成员方法名()

获取键盘输入的一个int数字：int num = sc.nextInt();
获取键盘输入的一个字符串：String str = sc.next();
 */
public class Demo01Scanner {

    public static void main(String[] args) {
        // 2. 创建
        // 备注：System.in代表从键盘进行输入
        Scanner sc = new Scanner(System.in);

        // 3. 获取键盘输入的int数字
        int num = sc.nextInt();
        System.out.println("输入的int数字是：" + num);

        // 4. 获取键盘输入的字符串
        String str = sc.next();
        System.out.println("输入的字符串是：" + str);
    }
}
```

### 匿名对象的使用

```java
package cn.itcast.day07.demo02;

/*
创建对象的标准格式：
类名称 对象名 = new 类名称();

匿名对象就是只有右边的对象，没有左边的名字和赋值运算符。
new 类名称();

注意事项：匿名对象只能使用唯一的一次，下次再用不得不再创建一个新对象。
使用建议：如果确定有一个对象只需要使用唯一的一次，就可以用匿名对象。
 */
public class Demo01Anonymous {

    public static void main(String[] args) {
        // 左边的one就是对象的名字
        Person one = new Person();
        one.name = "高圆圆";
        one.showName(); // 我叫高圆圆
        System.out.println("===============");

        // 匿名对象
        new Person().name = "赵又廷";
        new Person().showName(); // 我叫：null
    }

}

```

### 匿名对象作为方法的参数和返回值

```java
import java.util.Scanner;

public class Demo02Anonymous {

    public static void main(String[] args) {
        // 普通使用方式
//        Scanner sc = new Scanner(System.in);
//        int num = sc.nextInt();

        // 匿名对象的方式
//        int num = new Scanner(System.in).nextInt();
//        System.out.println("输入的是：" + num);

        // 使用一般写法传入参数
//        Scanner sc = new Scanner(System.in);
//        methodParam(sc);

        // 使用匿名对象来进行传参
//        methodParam(new Scanner(System.in));

        Scanner sc = methodReturn();
        int num = sc.nextInt();
        System.out.println("输入的是：" + num);
    }

    public static void methodParam(Scanner sc) {
        int num = sc.nextInt();
        System.out.println("输入的是：" + num);
    }

    public static Scanner methodReturn() {
//        Scanner sc = new Scanner(System.in);
//        return sc;
        return new Scanner(System.in);
    }

}

```

### Random概述和基本使用

```java
import java.util.Random;

/*
Random类用来生成随机数字。使用起来也是三个步骤：

1. 导包
import java.util.Random;

2. 创建
Random r = new Random(); // 小括号当中留空即可

3. 使用
获取一个随机的int数字（范围是int所有范围，有正负两种）：int num = r.nextInt()
获取一个随机的int数字（参数代表了范围，左闭右开区间）：int num = r.nextInt(3)

 */
public class Demo01Random {

    public static void main(String[] args) {
        Random r = new Random();

        int num = r.nextInt();
        System.out.println("随机数是：" + num);
    }

}

```

### 生成1-n之间的随机数

```java
import java.util.Random;

/*
题目要求：
根据int变量n的值，来获取随机数字，范围是[1,n]，可以取到1也可以取到n。

思路：
1. 定义一个int变量n，随意赋值
2. 要使用Random：三个步骤，导包、创建、使用
3. 如果写10，那么就是0~9，然而想要的是1~10，可以发现：整体+1即可。
4. 打印随机数字
 */
public class Demo03Random {

    public static void main(String[] args) {
        int n = 5;
        Random r = new Random();

        for (int i = 0; i < 100; i++) {
            // 本来范围是[0,n)，整体+1之后变成了[1,n+1)，也就是[1,n]
            int result = r.nextInt(n) + 1;
            System.out.println(result);
        }

    }

}

```

### 猜数字小游戏

```java
import java.util.Random;
import java.util.Scanner;

/*
题目：
用代码模拟猜数字的小游戏。

思路：
1. 首先需要产生一个随机数字，并且一旦产生不再变化。用Random的nextInt方法
2. 需要键盘输入，所以用到了Scanner
3. 获取键盘输入的数字，用Scanner当中的nextInt方法
4. 已经得到了两个数字，判断（if）一下：
    如果太大了，提示太大，并且重试；
    如果太小了，提示太小，并且重试；
    如果猜中了，游戏结束。
5. 重试就是再来一次，循环次数不确定，用while(true)。
 */
public class Demo04RandomGame {

    public static void main(String[] args) {
        Random r = new Random();
        int randomNum = r.nextInt(100) + 1; // [1,100]
        Scanner sc = new Scanner(System.in);

        while (true) {
            System.out.println("请输入你猜测的数字：");
            int guessNum = sc.nextInt(); // 键盘输入猜测的数字

            if (guessNum > randomNum) {
                System.out.println("太大了，请重试。");
            } else if (guessNum < randomNum) {
                System.out.println("太小了，请重试。");
            } else {
                System.out.println("恭喜你，猜中啦！");
                break; // 如果猜中，不再重试
            }
        }

        System.out.println("游戏结束。");
    }

}

```

### 对象数组

```java
/*
题目：
定义一个数组，用来存储3个Person对象。

数组有一个缺点：一旦创建，程序运行期间长度不可以发生改变。
 */
public class Demo01Array {

    public static void main(String[] args) {
        // 首先创建一个长度为3的数组，里面用来存放Person类型的对象
        Person[] array = new Person[3];

        Person one = new Person("迪丽热巴", 18);
        Person two = new Person("古力娜扎", 28);
        Person three = new Person("玛尔扎哈", 38);

        // 将one当中的地址值赋值到数组的0号元素位置
        array[0] = one;
        array[1] = two;
        array[2] = three;

        System.out.println(array[0]); // 地址值
        System.out.println(array[1]); // 地址值
        System.out.println(array[2]); // 地址值

        System.out.println(array[1].getName()); // 古力娜扎
    }

}
```

### ArrayList集合概述和基本使用-**<E>**泛型

```java
import java.util.ArrayList;

/*
数组的长度不可以发生改变。
但是ArrayList集合的长度是可以随意变化的。

对于ArrayList来说，有一个尖括号<E>代表泛型。
泛型：也就是装在集合当中的所有元素，全都是统一的什么类型。
注意：泛型只能是引用类型，不能是基本类型。

注意事项：
对于ArrayList集合来说，直接打印得到的不是地址值，而是内容。
如果内容是空，得到的是空的中括号：[]
 */
public class Demo02ArrayList {

    public static void main(String[] args) {
        // 创建了一个ArrayList集合，集合的名称是list，里面装的全都是String字符串类型的数据
        // 备注：从JDK 1.7+开始，右侧的尖括号内部可以不写内容，但是<>本身还是要写的。
        ArrayList<String> list = new ArrayList<>();
        System.out.println(list); // []

        // 向集合当中添加一些数据，需要用到add方法。
        list.add("赵丽颖");
        System.out.println(list); // [赵丽颖]

        list.add("迪丽热巴");
        list.add("古力娜扎");
        list.add("玛尔扎哈");
        System.out.println(list); // [赵丽颖, 迪丽热巴, 古力娜扎, 玛尔扎哈]

//        list.add(100); // 错误写法！因为创建的时候尖括号泛型已经说了是字符串，添加进去的元素就必须都是字符串才行
    }

}

```

### ArrayList集合的常用方法和遍历

```java
import java.util.ArrayList;

/*
ArrayList当中的常用方法有：

public boolean add(E e)：向集合当中添加元素，参数的类型和泛型一致。返回值代表添加是否成功。
备注：对于ArrayList集合来说，add添加动作一定是成功的，所以返回值可用可不用。
但是对于其他集合（今后学习）来说，add添加动作不一定成功。

public E get(int index)：从集合当中获取元素，参数是索引编号，返回值就是对应位置的元素。

public E remove(int index)：从集合当中删除元素，参数是索引编号，返回值就是被删除掉的元素。

public int size()：获取集合的尺寸长度，返回值是集合中包含的元素个数。
 */
public class Demo03ArrayListMethod {

    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        System.out.println(list); // []

        // 向集合中添加元素：add
        boolean success = list.add("柳岩");
        System.out.println(list); // [柳岩]
        System.out.println("添加的动作是否成功：" + success); // true

        list.add("高圆圆");
        list.add("赵又廷");
        list.add("李小璐");
        list.add("贾乃亮");
        System.out.println(list); // [柳岩, 高圆圆, 赵又廷, 李小璐, 贾乃亮]

        // 从集合中获取元素：get。索引值从0开始
        String name = list.get(2);
        System.out.println("第2号索引位置：" + name); // 赵又廷

        // 从集合中删除元素：remove。索引值从0开始。
        String whoRemoved = list.remove(3);
        System.out.println("被删除的人是：" + whoRemoved); // 李小璐
        System.out.println(list); // [柳岩, 高圆圆, 赵又廷, 贾乃亮]

        // 获取集合的长度尺寸，也就是其中元素的个数
        int size = list.size();
        System.out.println("集合的长度是：" + size);
    }

}



遍历
package cn.itcast.day07.demo04;

import java.util.ArrayList;

public class Demo04ArrayListEach {

    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        list.add("迪丽热巴");
        list.add("古力娜扎");
        list.add("玛尔扎哈");

        // 遍历集合
        for (int i = 0; i < list.size(); i++) {
            System.out.println(list.get(i));
        }
    }

}

```

### ArrayList集合存储基本数据类型

```java
1.基本数据类型：     boolean，char，byte，short，int，long，float，double     
                                 一共有8种，可以在栈中直接分配内存；
2.引用数据类型：    除了基本数据类型以外其他所有的数据类型，比如 Integer 、String、用户自定义的类等等
                                他们是对象的引用在栈中，对象实际存放在堆中
    
import java.util.ArrayList;

/*
如果希望向集合ArrayList当中存储基本类型数据，必须使用基本类型对应的“包装类”。

基本类型    包装类（引用类型，包装类都位于java.lang包下）
byte        Byte
short       Short
int         Integer     【特殊】
long        Long
float       Float
double      Double
char        Character   【特殊】
boolean     Boolean

从JDK 1.5+开始，支持自动装箱、自动拆箱。

自动装箱：基本类型 --> 包装类型
自动拆箱：包装类型 --> 基本类型
 */
public class Demo05ArrayListBasic {

    public static void main(String[] args) {
        ArrayList<String> listA = new ArrayList<>();
        // 错误写法！泛型只能是引用类型，不能是基本类型
//        ArrayList<int> listB = new ArrayList<>();

        ArrayList<Integer> listC = new ArrayList<>();
        listC.add(100);
        listC.add(200);
        System.out.println(listC); // [100, 200]

        int num = listC.get(1);
        System.out.println("第1号元素是：" + num);
    }
}
```

### 练习一_存储随机数字

```java
import java.util.ArrayList;
import java.util.Random;

/*
题目：
生成6个1~33之间的随机整数，添加到集合，并遍历集合。

思路：
1. 需要存储6个数字，创建一个集合，<Integer>
2. 产生随机数，需要用到Random
3. 用循环6次，来产生6个随机数字：for循环
4. 循环内调用r.nextInt(int n)，参数是33，0~32，整体+1才是1~33
5. 把数字添加到集合中：add
6. 遍历集合：for、size、get
 */
public class Demo01ArrayListRandom {

    public static void main(String[] args) {
        ArrayList<Integer> list = new ArrayList<>();
        Random r = new Random();
        for (int i = 0; i < 6; i++) {
            int num = r.nextInt(33) + 1;
            list.add(num);
        }
        // 遍历集合
        for (int i = 0; i < list.size(); i++) {
            System.out.println(list.get(i));
        }
    }

}

```

### 练习二_存储自定义对象

```java
import java.util.ArrayList;

/*
题目：
自定义4个学生对象，添加到集合，并遍历。

思路：
1. 自定义Student学生类，四个部分。
2. 创建一个集合，用来存储学生对象。泛型：<Student>
3. 根据类，创建4个学生对象。
4. 将4个学生对象添加到集合中：add
5. 遍历集合：for、size、get
 */
public class Demo02ArrayListStudent {

    public static void main(String[] args) {
        ArrayList<Student> list = new ArrayList<>();

        Student one = new Student("洪七公", 20);
        Student two = new Student("欧阳锋", 21);
        Student three = new Student("黄药师", 22);
        Student four = new Student("段智兴", 23);

        list.add(one);
        list.add(two);
        list.add(three);
        list.add(four);

        // 遍历集合
        for (int i = 0; i < list.size(); i++) {
            Student stu = list.get(i);
            System.out.println("姓名：" + stu.getName() + "，年龄" + stu.getAge());
        }
    }

}
```

### 练习三_按指定格式遍历集合字符串

```java
import java.util.ArrayList;

/*
题目：
定义以指定格式打印集合的方法(ArrayList类型作为参数)，使用{}扩起集合，使用@分隔每个元素。
格式参照 {元素@元素@元素}。

System.out.println(list);       [10, 20, 30]
printArrayList(list);           {10@20@30}
 */
public class Demo03ArrayListPrint {

    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        list.add("张三丰");
        list.add("宋远桥");
        list.add("张无忌");
        list.add("张翠山");
        System.out.println(list); // [张三丰, 宋远桥, 张无忌, 张翠山]

        printArrayList(list);
    }

    /*
    定义方法的三要素
    返回值类型：只是进行打印而已，没有运算，没有结果；所以用void
    方法名称：printArrayList
    参数列表：ArrayList
     */
    public static void printArrayList(ArrayList<String> list) {
        // {10@20@30}
        System.out.print("{");
        for (int i = 0; i < list.size(); i++) {
            String name = list.get(i);
            if (i == list.size() - 1) {
                System.out.println(name + "}");
            } else {
                System.out.print(name + "@");
            }
        }
    }

}

```

### 练习四_筛选集合中的随机数

```java
import java.util.ArrayList;
import java.util.Random;

/*
题目：
用一个大集合存入20个随机数字，然后筛选其中的偶数元素，放到小集合当中。
要求使用自定义的方法来实现筛选。

分析：
1. 需要创建一个大集合，用来存储int数字：<Integer>
2. 随机数字就用Random nextInt
3. 循环20次，把随机数字放入大集合：for循环、add方法
4. 定义一个方法，用来进行筛选。
筛选：根据大集合，筛选符合要求的元素，得到小集合。
三要素
返回值类型：ArrayList小集合（里面元素个数不确定）
方法名称：getSmallList
参数列表：ArrayList大集合（装着20个随机数字）
5. 判断（if）是偶数：num % 2 == 0
6. 如果是偶数，就放到小集合当中，否则不放。
 */
public class Demo04ArrayListReturn {

    public static void main(String[] args) {
        ArrayList<Integer> bigList = new ArrayList<>();
        Random r = new Random();
        for (int i = 0; i < 20; i++) {
            int num = r.nextInt(100) + 1; // 1~100
            bigList.add(num);
        }

        ArrayList<Integer> smallList = getSmallList(bigList);

        System.out.println("偶数总共有多少个：" + smallList.size());
        for (int i = 0; i < smallList.size(); i++) {
            System.out.println(smallList.get(i));
        }
    }

    // 这个方法，接收大集合参数，返回小集合结果
    public static ArrayList<Integer> getSmallList(ArrayList<Integer> bigList) {
        // 创建一个小集合，用来装偶数结果
        ArrayList<Integer> smallList = new ArrayList<>();
        for (int i = 0; i < bigList.size(); i++) {
            int num = bigList.get(i);
            if (num % 2 == 0) {
                smallList.add(num);
            }
        }
        return smallList;
    }

}

```

## 08_String类、static、Arrays类、Math类

### 字符串概述和特点

### 字符串的构造方法和直接创建

```java
/*
java.lang.String类代表字符串。
API当中说：Java 程序中的所有字符串字面值（如 "abc" ）都作为此类的实例实现。
其实就是说：程序当中所有的双引号字符串，都是String类的对象。（就算没有new，也照样是。）

字符串的特点：
1. 字符串的内容永不可变。【重点】
2. 正是因为字符串不可改变，所以字符串是可以共享使用的。
3. 字符串效果上相当于是char[]字符数组，但是底层原理是byte[]字节数组。

创建字符串的常见3+1种方式。
三种构造方法：
public String()：创建一个空白字符串，不含有任何内容。
public String(char[] array)：根据字符数组的内容，来创建对应的字符串。
public String(byte[] array)：根据字节数组的内容，来创建对应的字符串。
一种直接创建：
String str = "Hello"; // 右边直接用双引号

注意：直接写上双引号，就是字符串对象。
 */
public class Demo01String {

    public static void main(String[] args) {
        // 使用空参构造
        String str1 = new String(); // 小括号留空，说明字符串什么内容都没有。
        System.out.println("第1个字符串：" + str1);

        // 根据字符数组创建字符串
        char[] charArray = { 'A', 'B', 'C' };
        String str2 = new String(charArray);
        System.out.println("第2个字符串：" + str2);

        // 根据字节数组创建字符串
        byte[] byteArray = { 97, 98, 99 };
        String str3 = new String(byteArray);
        System.out.println("第3个字符串：" + str3);

        // 直接创建
        String str4 = "Hello";
        System.out.println("第4个字符串：" + str4);
    }
}
```

### 字符串的常量池

![01-字符串的常量池](C:/Users/Murphy/Pictures/01-字符串的常量池.png)

```java
/*
字符串常量池：程序当中直接写上的双引号字符串，就在字符串常量池中。

对于基本类型来说，==是进行数值的比较。
对于引用类型来说，==是进行【地址值】的比较。
 */
public class Demo02StringPool {

    public static void main(String[] args) {
        String str1 = "abc";
        String str2 = "abc";

        char[] charArray = {'a', 'b', 'c'};
        String str3 = new String(charArray);

        System.out.println(str1 == str2); // true
        System.out.println(str1 == str3); // false
        System.out.println(str2 == str3); // false
    }

}

```

### 字符串的比较方法

```java
/*
==是进行对象的地址值比较，如果确实需要字符串的内容比较，可以使用两个方法：

public boolean equals(Object obj)：参数可以是任何对象，只有参数是一个字符串并且内容相同的才会给true；否则返回false。
注意事项：
1. 任何对象都能用Object进行接收。
2. equals方法具有对称性，也就是a.equals(b)和b.equals(a)效果一样。
3. 如果比较双方一个常量一个变量，推荐把常量字符串写在前面。
推荐："abc".equals(str)    不推荐：str.equals("abc")

public boolean equalsIgnoreCase(String str)：忽略大小写，进行内容比较。
 */
public class Demo01StringEquals {

    public static void main(String[] args) {
        String str1 = "Hello";
        String str2 = "Hello";
        char[] charArray = {'H', 'e', 'l', 'l', 'o'};
        String str3 = new String(charArray);

        System.out.println(str1.equals(str2)); // true
        System.out.println(str2.equals(str3)); // true
        System.out.println(str3.equals("Hello")); // true
        System.out.println("Hello".equals(str1)); // true

        String str4 = "hello";
        System.out.println(str1.equals(str4)); // false
        System.out.println("=================");

        String str5 = null;
        System.out.println("abc".equals(str5)); // 推荐：false
//        System.out.println(str5.equals("abc")); // 不推荐：报错，空指针异常NullPointerException
        System.out.println("=================");

        String strA = "Java";
        String strB = "java";
        System.out.println(strA.equals(strB)); // false，严格区分大小写
        System.out.println(strA.equalsIgnoreCase(strB)); // true，忽略大小写

        // 注意，只有英文字母区分大小写，其他都不区分大小写
        System.out.println("abc一123".equalsIgnoreCase("abc壹123")); // false
    }

}

```

### 字符串的获取相关方法

```java
/*
String当中与获取相关的常用方法有：

public int length()：获取字符串当中含有的字符个数，拿到字符串长度。
public String concat(String str)：将当前字符串和参数字符串拼接成为返回值新的字符串。
public char charAt(int index)：获取指定索引位置的单个字符。（索引从0开始。）
public int indexOf(String str)：查找参数字符串在本字符串当中首次出现的索引位置，如果没有返回-1值。
 */
public class Demo02StringGet {

    public static void main(String[] args) {
        // 获取字符串的长度
        int length = "asdasfeutrvauevbueyvb".length();
        System.out.println("字符串的长度是：" + length);

        // 拼接字符串
        String str1 = "Hello";
        String str2 = "World";
        String str3 = str1.concat(str2);
        System.out.println(str1); // Hello，原封不动
        System.out.println(str2); // World，原封不动
        System.out.println(str3); // HelloWorld，新的字符串
        System.out.println("==============");

        // 获取指定索引位置的单个字符
        char ch = "Hello".charAt(1);
        System.out.println("在1号索引位置的字符是：" + ch);
        System.out.println("==============");

        // 查找参数字符串在本来字符串当中出现的第一次索引位置
        // 如果根本没有，返回-1值
        String original = "HelloWorldHelloWorld";
        int index = original.indexOf("llo");
        System.out.println("第一次索引值是：" + index); // 2

        System.out.println("HelloWorld".indexOf("abc")); // -1
    }

}

```

### 字符串的截取方法

```java
/*
字符串的截取方法：

public String substring(int index)：截取从参数位置一直到字符串末尾，返回新字符串。
public String substring(int begin, int end)：截取从begin开始，一直到end结束，中间的字符串。
备注：[begin,end)，包含左边，不包含右边。
 */
public class Demo03Substring {

    public static void main(String[] args) {
        String str1 = "HelloWorld";
        String str2 = str1.substring(5);
        System.out.println(str1); // HelloWorld，原封不动
        System.out.println(str2); // World，新字符串
        System.out.println("================");

        String str3 = str1.substring(4, 7);
        System.out.println(str3); // oWo
        System.out.println("================");

        // 下面这种写法，字符串的内容仍然是没有改变的
        // 下面有两个字符串："Hello"，"Java"
        // strA当中保存的是地址值。
        // 本来地址值是Hello的0x666，
        // 后来地址值变成了Java的0x999
        String strA = "Hello";
        System.out.println(strA); // Hello
        strA = "Java";
        System.out.println(strA); // Java
    }

}

```

### 字符串的截取方法

```java
/*
字符串的截取方法：

public String substring(int index)：截取从参数位置一直到字符串末尾，返回新字符串。
public String substring(int begin, int end)：截取从begin开始，一直到end结束，中间的字符串。
备注：[begin,end)，包含左边，不包含右边。
 */
public class Demo03Substring {

    public static void main(String[] args) {
        String str1 = "HelloWorld";
        String str2 = str1.substring(5);
        System.out.println(str1); // HelloWorld，原封不动
        System.out.println(str2); // World，新字符串
        System.out.println("================");

        String str3 = str1.substring(4, 7);
        System.out.println(str3); // oWo
        System.out.println("================");

        // 下面这种写法，字符串的内容仍然是没有改变的
        // 下面有两个字符串："Hello"，"Java"
        // strA当中保存的是地址值。
        // 本来地址值是Hello的0x666，
        // 后来地址值变成了Java的0x999
        String strA = "Hello";
        System.out.println(strA); // Hello
        strA = "Java";
        System.out.println(strA); // Java
    }

}

```

### 字符串的转换相关方法

```java
/*
String当中与转换相关的常用方法有：

public char[] toCharArray()：将当前字符串拆分成为字符数组作为返回值。
public byte[] getBytes()：获得当前字符串底层的字节数组。
public String replace(CharSequence oldString, CharSequence newString)：
将所有出现的老字符串替换成为新的字符串，返回替换之后的结果新字符串。
备注：CharSequence意思就是说可以接受字符串类型。
 */
public class Demo04StringConvert {

    public static void main(String[] args) {
        // 转换成为字符数组
        char[] chars = "Hello".toCharArray();
        System.out.println(chars[0]); // H
        System.out.println(chars.length); // 5
        System.out.println("==============");

        // 转换成为字节数组
        byte[] bytes = "abc".getBytes();
        for (int i = 0; i < bytes.length; i++) {
            System.out.println(bytes[i]);
        }
        System.out.println("==============");

        // 字符串的内容替换
        String str1 = "How do you do?";
        String str2 = str1.replace("o", "*");
        System.out.println(str1); // How do you do?
        System.out.println(str2); // H*w d* y*u d*?
        System.out.println("==============");

        String lang1 = "会不会玩儿呀！你大爷的！你大爷的！你大爷的！！！";
        String lang2 = lang1.replace("你大爷的", "****");
        System.out.println(lang2); // 会不会玩儿呀！****！****！****！！！
    }

}

```

### 字符串的分割方法

```java
/*
分割字符串的方法：
public String[] split(String regex)：按照参数的规则，将字符串切分成为若干部分。

注意事项：
split方法的参数其实是一个“正则表达式”，今后学习。
今天要注意：如果按照英文句点“.”进行切分，必须写"\\."（两个反斜杠）
 */
public class Demo05StringSplit {

    public static void main(String[] args) {
        String str1 = "aaa,bbb,ccc";
        String[] array1 = str1.split(",");
        for (int i = 0; i < array1.length; i++) {
            System.out.println(array1[i]);
        }
        System.out.println("===============");

        String str2 = "aaa bbb ccc";
        String[] array2 = str2.split(" ");
        for (int i = 0; i < array2.length; i++) {
            System.out.println(array2[i]);
        }
        System.out.println("===============");

        String str3 = "XXX.YYY.ZZZ";
        String[] array3 = str3.split("\\.");
        System.out.println(array3.length); // 0
        for (int i = 0; i < array3.length; i++) {
            System.out.println(array3[i]);
        }
    }

}

```

### 练习：按指定格式拼接字符串

```java
/*
题目：
定义一个方法，把数组{1,2,3}按照指定格式拼接成一个字符串。格式参照如下：[word1#word2#word3]。

分析：
1. 首先准备一个int[]数组，内容是：1、2、3
2. 定义一个方法，用来将数组变成字符串
三要素
返回值类型：String
方法名称：fromArrayToString
参数列表：int[]
3. 格式：[word1#word2#word3]
用到：for循环、字符串拼接、每个数组元素之前都有一个word字样、分隔使用的是#、区分一下是不是最后一个
4. 调用方法，得到返回值，并打印结果字符串
 */
public class Demo06StringPractise {

    public static void main(String[] args) {
        int[] array = {1, 2, 3, 4};

        String result = fromArrayToString(array);
        System.out.println(result);
    }

    public static String fromArrayToString(int[] array) {
        String str = "[";
        for (int i = 0; i < array.length; i++) {
            if (i == array.length - 1) {
                str += "word" + array[i] + "]";
            } else {
                str += "word" + array[i] + "#";
            }
        }
        return str;
    }

}

```

### 练习：统计输入的字符串中各种字符的个数

```java
import java.util.Scanner;

/*
题目：
键盘输入一个字符串，并且统计其中各种字符出现的次数。
种类有：大写字母、小写字母、数字、其他

思路：
1. 既然用到键盘输入，肯定是Scanner
2. 键盘输入的是字符串，那么：String str = sc.next();
3. 定义四个变量，分别代表四种字符各自的出现次数。
4. 需要对字符串一个字、一个字检查，String-->char[]，方法就是toCharArray()
5. 遍历char[]字符数组，对当前字符的种类进行判断，并且用四个变量进行++动作。
6. 打印输出四个变量，分别代表四种字符出现次数。
 */
public class Demo07StringCount {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println("请输入一个字符串：");
        String input = sc.next(); // 获取键盘输入的一个字符串

        int countUpper = 0; // 大写字母
        int countLower = 0; // 小写字母
        int countNumber = 0; // 数字
        int countOther = 0; // 其他字符

        char[] charArray = input.toCharArray();
        for (int i = 0; i < charArray.length; i++) {
            char ch = charArray[i]; // 当前单个字符
            if ('A' <= ch && ch <= 'Z') {
                countUpper++;
            } else if ('a' <= ch && ch <= 'z') {
                countLower++;
            } else if ('0' <= ch && ch <= '9') {
                countNumber++;
            } else {
                countOther++;
            }
        }

        System.out.println("大写字母有：" + countUpper);
        System.out.println("小写字母有：" + countLower);
        System.out.println("数字有：" + countNumber);
        System.out.println("其他字符有：" + countOther);
    }

}

```

### 静态static关键字概述

![02-静态static关键字概述](C:/Users/Murphy/Pictures/02-静态static关键字概述.png)

### 静态static关键字修饰成员变量

```java
/*
如果一个成员变量使用了static关键字，那么这个变量不再属于对象自己，而是属于所在的类。多个对象共享同一份数据。
 */
public class Demo01StaticField {

    public static void main(String[] args) {

        Student two = new Student("黄蓉", 16);
        two.room = "101教室";
        System.out.println("姓名：" + two.getName()
                + "，年龄：" + two.getAge() + "，教室：" + two.room
                + "，学号：" + two.getId());

        Student one = new Student("郭靖", 19);
        System.out.println("姓名：" + one.getName()
                + "，年龄：" + one.getAge() + "，教室：" + one.room
                + "，学号：" + one.getId());
    }

}


调用
package cn.itcast.day08.demo03;

public class Student {

    private int id; // 学号
    private String name; // 姓名
    private int age; // 年龄
    static String room; // 所在教室
    private static int idCounter = 0; // 学号计数器，每当new了一个新对象的时候，计数器++

    public Student() {
        this.id = ++idCounter;
    }

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
        this.id = ++idCounter;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}

```

### 静态static关键字修饰成员方法

```java
/*
一旦使用static修饰成员方法，那么这就成为了静态方法。静态方法不属于对象，而是属于类的。

如果没有static关键字，那么必须首先创建对象，然后通过对象才能使用它。
如果有了static关键字，那么不需要创建对象，直接就能通过类名称来使用它。

无论是成员变量，还是成员方法。如果有了static，都推荐使用类名称进行调用。
静态变量：类名称.静态变量
静态方法：类名称.静态方法()

注意事项：
1. 静态不能直接访问非静态。
原因：因为在内存当中是【先】有的静态内容，【后】有的非静态内容。
“先人不知道后人，但是后人知道先人。”
2. 静态方法当中不能用this。
原因：this代表当前对象，通过谁调用的方法，谁就是当前对象。
 */
public class Demo02StaticMethod {

    public static void main(String[] args) {
        MyClass obj = new MyClass(); // 首先创建对象
        // 然后才能使用没有static关键字的内容
        obj.method();

        // 对于静态方法来说，可以通过对象名进行调用，也可以直接通过类名称来调用。
        obj.methodStatic(); // 正确，不推荐，这种写法在编译之后也会被javac翻译成为“类名称.静态方法名”
        MyClass.methodStatic(); // 正确，推荐

        // 对于本来当中的静态方法，可以省略类名称
        myMethod();
        Demo02StaticMethod.myMethod(); // 完全等效
    }

    public static void myMethod() {
        System.out.println("自己的方法！");
    }

}

调用
package cn.itcast.day08.demo03;

public class MyClass {

    int num; // 成员变量
    static int numStatic; // 静态变量

    // 成员方法
    public void method() {
        System.out.println("这是一个成员方法。");
        // 成员方法可以访问成员变量
        System.out.println(num);
        // 成员方法可以访问静态变量
        System.out.println(numStatic);
    }

    // 静态方法
    public static void methodStatic() {
        System.out.println("这是一个静态方法。");
        // 静态方法可以访问静态变量
        System.out.println(numStatic);
        // 静态不能直接访问非静态【重点】
//        System.out.println(num); // 错误写法！

        // 静态方法中不能使用this关键字。
//        System.out.println(this); // 错误写法！
    }

}

```

### 静态static的内存图

![03-静态的内存图](C:/Users/Murphy/Pictures/03-静态的内存图.png)

### 静态代码块

```java
/*
静态代码块的格式是：

public class 类名称 {
    static {
        // 静态代码块的内容
    }
}

特点：当第一次用到本类时，静态代码块执行唯一的一次。
静态内容总是优先于非静态，所以静态代码块比构造方法先执行。

静态代码块的典型用途：
用来一次性地对静态成员变量进行赋值。
 */
public class Demo04Static {

    public static void main(String[] args) {
        Person one = new Person();
        Person two = new Person();
    }

}

调用
package cn.itcast.day08.demo03;


public class Person {

    static {
        System.out.println("静态代码块执行！");
    }

    public Person() {
        System.out.println("构造方法执行！");
    }

}

```

### 数组工具类Arrays

```java
import java.util.Arrays;

/*
java.util.Arrays是一个与数组相关的工具类，里面提供了大量静态方法，用来实现数组常见的操作。

public static String toString(数组)：将参数数组变成字符串（按照默认格式：[元素1, 元素2, 元素3...]）
public static void sort(数组)：按照默认升序（从小到大）对数组的元素进行排序。

备注：
1. 如果是数值，sort默认按照升序从小到大
2. 如果是字符串，sort默认按照字母升序
3. 如果是自定义的类型，那么这个自定义的类需要有Comparable或者Comparator接口的支持。（今后学习）
 */
public class Demo01Arrays {

    public static void main(String[] args) {
        int[] intArray = {10, 20, 30};
        // 将int[]数组按照默认格式变成字符串
        String intStr = Arrays.toString(intArray);
        System.out.println(intStr); // [10, 20, 30]

        int[] array1 = {2, 1, 3, 10, 6};
        Arrays.sort(array1);
        System.out.println(Arrays.toString(array1)); // [1, 2, 3, 6, 10]

        String[] array2 = {"bbb", "aaa", "ccc"};
        Arrays.sort(array2);
        System.out.println(Arrays.toString(array2)); // [aaa, bbb, ccc]
    }

}

```

### Arrays练习：字符串倒序排列

```java
import java.util.Arrays;

/*
题目：
请使用Arrays相关的API，将一个随机字符串中的所有字符升序排列，并倒序打印。
 */
public class Demo02ArraysPractise {

    public static void main(String[] args) {
        String str = "asv76agfqwdfvasdfvjh";

        // 如何进行升序排列：sort
        // 必须是一个数组，才能用Arrays.sort方法
        // String --> 数组，用toCharArray
        char[] chars = str.toCharArray();
        Arrays.sort(chars); // 对字符数组进行升序排列

        // 需要倒序遍历
        for (int i = chars.length - 1; i >= 0; i--) {
            System.out.println(chars[i]);
        }
    }

}

```

### 数学工具类Math

```java
/*
java.util.Math类是数学相关的工具类，里面提供了大量的静态方法，完成与数学运算相关的操作。

public static double abs(double num)：获取绝对值。有多种重载。
public static double ceil(double num)：向上取整。
public static double floor(double num)：向下取整。
public static long round(double num)：四舍五入。

Math.PI代表近似的圆周率常量（double）。
 */
public class Demo03Math {

    public static void main(String[] args) {
        // 获取绝对值
        System.out.println(Math.abs(3.14)); // 3.14
        System.out.println(Math.abs(0)); // 0
        System.out.println(Math.abs(-2.5)); // 2.5
        System.out.println("================");

        // 向上取整
        System.out.println(Math.ceil(3.9)); // 4.0
        System.out.println(Math.ceil(3.1)); // 4.0
        System.out.println(Math.ceil(3.0)); // 3.0
        System.out.println("================");

        // 向下取整，抹零
        System.out.println(Math.floor(30.1)); // 30.0
        System.out.println(Math.floor(30.9)); // 30.0
        System.out.println(Math.floor(31.0)); // 31.0
        System.out.println("================");

        System.out.println(Math.round(20.4)); // 20
        System.out.println(Math.round(10.5)); // 11
    }

}

```

### Math练习：小学数学真题

```java
/*
题目：
计算在-10.8到5.9之间，绝对值大于6或者小于2.1的整数有多少个？

分析：
1. 既然已经确定了范围，for循环
2. 起点位置-10.8应该转换成为-10，两种办法：
    2.1 可以使用Math.ceil方法，向上（向正方向）取整
    2.2 强转成为int，自动舍弃所有小数位
3. 每一个数字都是整数，所以步进表达式应该是num++，这样每次都是+1的。
4. 如何拿到绝对值：Math.abs方法。
5. 一旦发现了一个数字，需要让计数器++进行统计。

备注：如果使用Math.ceil方法，-10.8可以变成-10.0。注意double也是可以进行++的。
 */
public class Demo04MathPractise {

    public static void main(String[] args) {
        int count = 0; // 符合要求的数量

        double min = -10.8;
        double max = 5.9;
        // 这样处理，变量i就是区间之内所有的整数
        for (int i = (int) min; i < max; i++) {
            int abs = Math.abs(i); // 绝对值
            if (abs > 6 || abs < 2.1) {
                System.out.println(i);
                count++;
            }
        }

        System.out.println("总共有：" + count); // 9
    }

}

```

## 09_继承、super、this、抽象类

### 01_继承的概述

面向对象的三大特征：封装性、继承性、多态性。继承是多态的前提，如果没有继承，就没有多态。

![01-继承的基本概念](C:/Users/Murphy/Pictures/01-继承的基本概念.png)

### 02_继承的格式

```java
/*
在继承的关系中，“子类就是一个父类”。也就是说，子类可以被当做父类看待。
例如父类是员工，子类是讲师，那么“讲师就是一个员工”。关系：is-a。

定义父类的格式：（一个普通的类定义）
public class 父类名称 {
    // ...
}

定义子类的格式：
public class 子类名称 extends 父类名称 {
    // ...
}
 */
public class Demo01Extends {

    public static void main(String[] args) {
        // 创建了一个子类对象
        Teacher teacher = new Teacher();
        // Teacher类当中虽然什么都没写，但是会继承来自父类的method方法。
        teacher.method();

        // 创建另一个子类助教的对象
        Assistant assistant = new Assistant();
        assistant.method();
    }

}

父类
package cn.itcast.day09.demo01;

// 定义一个父类：员工
public class Employee {

    public void method() {
        System.out.println("方法执行！");
    }

}

继承
package cn.itcast.day09.demo01;

// 定义了员工的另一个子类：助教
public class Assistant extends Employee {
}
继承

```

### 03_继承中成员变量的访问特点

```java
/*
在父子类的继承关系当中，如果成员变量重名，则创建子类对象时，访问有两种方式：

直接通过子类对象访问成员变量：
    等号左边是谁，就优先用谁，没有则向上找。
间接通过成员方法访问成员变量：
    该方法属于谁，就优先用谁，没有则向上找。
 */
public class Demo01ExtendsField {

    public static void main(String[] args) {
        Fu fu = new Fu(); // 创建父类对象
        System.out.println(fu.numFu); // 只能使用父类的东西，没有任何子类内容
        System.out.println("===========");

        Zi zi = new Zi();

        System.out.println(zi.numFu); // 10
        System.out.println(zi.numZi); // 20
        System.out.println("===========");

        // 等号左边是谁，就优先用谁
        System.out.println(zi.num); // 优先子类，200
//        System.out.println(zi.abc); // 到处都没有，编译报错！
        System.out.println("===========");

        // 这个方法是子类的，优先用子类的，没有再向上找
        zi.methodZi(); // 200
        // 这个方法是在父类当中定义的，
        zi.methodFu(); // 100
    }

}

父类
package cn.itcast.day09.demo02;

public class Fu {

    int numFu = 10;

    int num = 100;

    public void methodFu() {
        // 使用的是本类当中的，不会向下找子类的
        System.out.println(num);
    }

}

子类
package cn.itcast.day09.demo02;

public class Zi extends Fu {

    int numZi = 20;

    int num = 200;

    public void methodZi() {
        // 因为本类当中有num，所以这里用的是本类的num
        System.out.println(num);
    }

}

```

### 04_区分子类方法中重名的三种变量

```java
/*
局部变量：         直接写成员变量名
本类的成员变量：    this.成员变量名
父类的成员变量：    super.成员变量名
 */
public class Demo01ExtendsField {

    public static void main(String[] args) {
        Zi zi = new Zi();

        zi.method();
    }

}

父类
package cn.itcast.day09.demo03;

public class Fu {

    int num = 10;

}

子类
package cn.itcast.day09.demo03;

public class Zi extends Fu {

    int num = 20;

    public void method() {
        int num = 30;
        System.out.println(num); // 30，局部变量
        System.out.println(this.num); // 20，本类的成员变量
        System.out.println(super.num); // 10，父类的成员变量
    }

}

```

### 05_继承中成员方法的访问特点

```java
/*
在父子类的继承关系当中，创建子类对象，访问成员方法的规则：
    创建的对象是谁，就优先用谁，如果没有则向上找。

注意事项：
无论是成员方法还是成员变量，如果没有都是向上找父类，绝对不会向下找子类的。

 */
public class Demo01ExtendsMethod {

    public static void main(String[] args) {
        Zi zi = new Zi();

        zi.methodFu();
        zi.methodZi();

        // 创建的是new了子类对象，所以优先用子类方法
        zi.method();
    }

}

```

### 06_继承中方法的覆盖重写_概念与特点

```
重写（Override）
概念：在继承关系当中，方法的名称一样，参数列表也一样。

重写（Override）：方法的名称一样，参数列表【也一样】。覆盖、覆写。
重载（Overload）：方法的名称一样，参数列表【不一样】。

方法的覆盖重写特点：创建的是子类对象，则优先用子类方法。
```

### 07_继承中方法的覆盖重写_注意事项

```java
/*
方法覆盖重写的注意事项：

1. 必须保证父子类之间方法的名称相同，参数列表也相同。
@Override：写在方法前面，用来检测是不是有效的正确覆盖重写。
这个注解就算不写，只要满足要求，也是正确的方法覆盖重写。

2. 子类方法的返回值必须【小于等于】父类方法的返回值范围。
小扩展提示：java.lang.Object类是所有类的公共最高父类（祖宗类），java.lang.String就是Object的子类。

3. 子类方法的权限必须【大于等于】父类方法的权限修饰符。
小扩展提示：public > protected > (default) > private
备注：(default)不是关键字default，而是什么都不写，留空。
 */
public class Demo01Override {

}

父类
package cn.itcast.day09.demo05;

public class Fu {

    public String method() {
        return null;
    }

}

子类
package cn.itcast.day09.demo05;

public class Zi extends Fu {

    @Override
    public String method() {
        return null;
    }

}

```

### 08_继承中方法的覆盖重写_应用场景

![02-方法覆盖重写的应用场景](C:/Users/Murphy/Pictures/02-方法覆盖重写的应用场景.png)

```java
public class Demo01Phone {

    public static void main(String[] args) {
        Phone phone = new Phone();
        phone.call();
        phone.send();
        phone.show();
        System.out.println("==========");

        NewPhone newPhone = new NewPhone();
        newPhone.call();
        newPhone.send();
        newPhone.show();
    }

}

父类
package cn.itcast.day09.demo06;

// 本来的老款手机
public class Phone {

    public void call() {
        System.out.println("打电话");
    }

    public void send() {
        System.out.println("发短信");
    }

    public void show() {
        System.out.println("显示号码");
    }

}
子类
package cn.itcast.day09.demo06;

// 定义一个新手机，使用老手机作为父类
public class NewPhone extends Phone {

    @Override
    public void show() {
        super.show(); // 把父类的show方法拿过来重复利用
        // 自己子类再来添加更多内容
        System.out.println("显示姓名");
        System.out.println("显示头像");
    }
}

```

### 09_继承中构造方法的访问特点

```java
/*
继承关系中，父子类构造方法的访问特点：

1. 子类构造方法当中有一个默认隐含的“super()”调用，所以一定是先调用的父类构造，后执行的子类构造。
2. 子类构造可以通过super关键字来调用父类重载构造。
3. super的父类构造调用，必须是子类构造方法的第一个语句。不能一个子类构造调用多次super构造。
总结：
子类必须调用父类构造方法，不写则赠送super()；写了则用写的指定的super调用，super只能有一个，还必须是第一个。
 */
public class Demo01Constructor {

    public static void main(String[] args) {
        Zi zi = new Zi();
    }

}

父类
package cn.itcast.day09.demo07;

public class Fu {

    public Fu() {
        System.out.println("父类无参构造");
    }

    public Fu(int num) {
        System.out.println("父类有参构造！");
    }

}

子类
package cn.itcast.day09.demo07;

public class Zi extends Fu {

    public Zi() {
        super(); // 在调用父类无参构造方法
//        super(20); // 在调用父类重载的构造方法
        System.out.println("子类构造方法！");
    }

    public void method() {
//        super(); // 错误写法！只有子类构造方法，才能调用父类构造方法。
    }

}


```

### 10_super关键字的三种用法

```java
父类

package cn.itcast.day09.demo08;

public class Fu {

    int num = 10;

    public void method() {
        System.out.println("父类方法");
    }

}

子类

package cn.itcast.day09.demo08;

/*
super关键字的用法有三种：
1. 在子类的成员方法中，访问父类的成员变量。
2. 在子类的成员方法中，访问父类的成员方法。
3. 在子类的构造方法中，访问父类的构造方法。
 */
public class Zi extends Fu {

    int num = 20;

    public Zi() {
        super();
    }

    public void methodZi() {
        System.out.println(super.num); // 父类中的num
    }

    public void method() {
        super.method(); // 访问父类中的method
        System.out.println("子类方法");
    }

}

```

### 11_this关键字的三种用法

```java
父类
package cn.itcast.day09.demo09;

public class Fu {

    int num = 30;

}

package cn.itcast.day09.demo09;

/*
super关键字用来访问父类内容，而this关键字用来访问本类内容。用法也有三种：

1. 在本类的成员方法中，访问本类的成员变量。
2. 在本类的成员方法中，访问本类的另一个成员方法。
3. 在本类的构造方法中，访问本类的另一个构造方法。
在第三种用法当中要注意：
A. this(...)调用也必须是构造方法的第一个语句，唯一一个。
B. super和this两种构造调用，不能同时使用。
 */
public class Zi extends Fu {

    int num = 20;

    public Zi() {
//        super(); // 这一行不再赠送
        this(123); // 本类的无参构造，调用本类的有参构造
//        this(1, 2); // 错误写法！
    }

    public Zi(int n) {
        this(1, 2);
    }

    public Zi(int n, int m) {
    }

    public void showNum() {
        int num = 10;
        System.out.println(num); // 局部变量
        System.out.println(this.num); // 本类中的成员变量
        System.out.println(super.num); // 父类中的成员变量
    }

    public void methodA() {
        System.out.println("AAA");
    }

    public void methodB() {
        this.methodA();
        System.out.println("BBB");
    }

}

```

### 12_super与this关键字图解

![03-super与this的内存图](C:/Users/Murphy/Pictures/03-super与this的内存图.png)

```java
public class Demo {

    public static void main(String[] args) {
        Zi zi = new Zi();

        zi.show();
        zi.method();
    }

}

父类
package cn.itcast.day09.demo10;

public class Fu {

    int num = 10;

    public void method() {
        System.out.println("父类方法");
    }

}

子类
package cn.itcast.day09.demo10;

public class Zi extends Fu {

    int num = 20;

    @Override
    public void method() {
        super.method(); // 调用了父类方法
        System.out.println("子类方法");
    }

    public void show() {
        int num = 30;
        System.out.println(num); // 30
        System.out.println(this.num); // 20
        System.out.println(super.num); // 10
    }

}


```

### 13_Java继承的三个特点

![04-Java继承的三个特点](C:/Users/Murphy/Pictures/04-Java继承的三个特点.png)

### 14_抽象的概念

![05-抽象的概念](C:/Users/Murphy/Pictures/05-抽象的概念.png)

### 15_抽象方法和抽象类的格式

```java

/*
抽象方法：就是加上abstract关键字，然后去掉大括号，直接分号结束。
抽象类：抽象方法所在的类，必须是抽象类才行。在class之前写上abstract即可。

如何使用抽象类和抽象方法：
1. 不能直接创建new抽象类对象。
2. 必须用一个子类来继承抽象父类。
3. 子类必须覆盖重写抽象父类当中所有的抽象方法。
覆盖重写（实现）：子类去掉抽象方法的abstract关键字，然后补上方法体大括号。
4. 创建子类对象进行使用。
 */
public abstract class Animal {

    // 这是一个抽象方法，代表吃东西，但是具体吃什么（大括号的内容）不确定。
    public abstract void eat();

    // 这是普通的成员方法
//    public void normalMethod() {
//
//    }

}
```

### 16_抽象方法和抽象类的使用

```java
public class DemoMain {

    public static void main(String[] args) {
//        Animal animal = new Animal(); // 错误写法！不能直接创建抽象类对象

        Cat cat = new Cat();
        cat.eat();
    }

}


父类
package cn.itcast.day09.demo11;

/*
抽象方法：就是加上abstract关键字，然后去掉大括号，直接分号结束。
抽象类：抽象方法所在的类，必须是抽象类才行。在class之前写上abstract即可。

如何使用抽象类和抽象方法：
1. 不能直接创建new抽象类对象。
2. 必须用一个子类来继承抽象父类。
3. 子类必须覆盖重写抽象父类当中所有的抽象方法。
覆盖重写（实现）：子类去掉抽象方法的abstract关键字，然后补上方法体大括号。
4. 创建子类对象进行使用。
 */
public abstract class Animal {

    // 这是一个抽象方法，代表吃东西，但是具体吃什么（大括号的内容）不确定。
    public abstract void eat();

    // 这是普通的成员方法
//    public void normalMethod() {
//
//    }

}

子类
package cn.itcast.day09.demo11;

public class Cat extends Animal {

    @Override
    public void eat() {
        System.out.println("猫吃鱼");
    }

}

```

### 17_抽象方法和抽象类的注意事项

![抽象类](C:/Users/Murphy/Pictures/抽象类.png)

```java
public class DemoMain {

    public static void main(String[] args) {
//        Animal animal = new Animal(); // 错误！

//        Dog dog = new Dog(); // 错误，这也是抽象类

        Dog2Ha ha = new Dog2Ha(); // 这是普通类，可以直接new对象。
        ha.eat();
        ha.sleep();
        System.out.println("==========");

        DogGolden golden = new DogGolden();
        golden.eat();
        golden.sleep();
    }


}

父类
package cn.itcast.day09.demo13;

// 最高的抽象父类
public abstract class Animal {

    public abstract void eat();

    public abstract void sleep();

}

父类
package cn.itcast.day09.demo13;

// 子类也是一个抽象类
public abstract class Dog extends Animal {

    @Override
    public void eat() {
        System.out.println("狗吃骨头");
    }

    // public abstract void sleep();
}
子类
package cn.itcast.day09.demo13;

public class Dog2Ha extends Dog {
    @Override
    public void sleep() {
        System.out.println("嘿嘿嘿……");
    }
}

子类
package cn.itcast.day09.demo13;

public class DogGolden extends Dog {
    @Override
    public void sleep() {
        System.out.println("呼呼呼……");
    }

```

### 18_发红包案例

![06-发红包案例的分析](C:/Users/Murphy/Pictures/06-发红包案例的分析.png)

### 19_发红包代码

```java
import java.util.ArrayList;

public class MainRedPacket {

    public static void main(String[] args) {
        Manager manager = new Manager("群主", 100);

        Member one = new Member("成员A", 0);
        Member two = new Member("成员B", 0);
        Member three = new Member("成员C", 0);

        manager.show(); // 100
        one.show(); // 0
        two.show(); // 0
        three.show(); // 0
        System.out.println("===============");

        // 群主总共发20块钱，分成3个红包
        ArrayList<Integer> redList = manager.send(20, 3);
        // 三个普通成员收红包
        one.receive(redList);
        two.receive(redList);
        three.receive(redList);

        manager.show(); // 100-20=80
        // 6、6、8，随机分给三个人
        one.show();
        two.show();
        three.show();
    }

}

父类
package cn.itcast.day09.demo14;

public class User {

    private String name; // 姓名
    private int money; // 余额，也就是当前用户拥有的钱数

    public User() {
    }

    public User(String name, int money) {
        this.name = name;
        this.money = money;
    }

    // 展示一下当前用户有多少钱
    public void show() {
        System.out.println("我叫：" + name + "，我有多少钱：" + money);
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getMoney() {
        return money;
    }

    public void setMoney(int money) {
        this.money = money;
    }
}

子类
package cn.itcast.day09.demo14;

import java.util.ArrayList;

// 群主的类
public class Manager extends User {

    public Manager() {
    }

    public Manager(String name, int money) {
        super(name, money);
    }

    public ArrayList<Integer> send(int totalMoney, int count) {
        // 首先需要一个集合，用来存储若干个红包的金额
        ArrayList<Integer> redList = new ArrayList<>();

        // 首先看一下群主自己有多少钱
        int leftMoney = super.getMoney(); // 群主当前余额
        if (totalMoney > leftMoney) {
            System.out.println("余额不足");
            return redList; // 返回空集合
        }

        // 扣钱，其实就是重新设置余额
        super.setMoney(leftMoney - totalMoney);

        // 发红包需要平均拆分成为count份
        int avg = totalMoney / count;
        int mod = totalMoney % count; // 余数，也就是甩下的零头

        // 除不开的零头，包在最后一个红包当中
        // 下面把红包一个一个放到集合当中
        for (int i = 0; i < count - 1; i++) {
            redList.add(avg);
        }

        // 最后一个红包
        int last = avg + mod;
        redList.add(last);

        return redList;
    }
}

子类

package cn.itcast.day09.demo14;

import java.util.ArrayList;
import java.util.Random;

// 普通成员
public class Member extends User {

    public Member() {
    }

    public Member(String name, int money) {
        super(name, money);
    }

    public void receive(ArrayList<Integer> list) {
        // 从多个红包当中随便抽取一个，给我自己。
        // 随机获取一个集合当中的索引编号
        int index = new Random().nextInt(list.size());
        // 根据索引，从集合当中删除，并且得到被删除的红包，给我自己
        int delta = list.remove(index);
        // 当前成员自己本来有多少钱：
        int money = super.getMoney();
        // 加法，并且重新设置回去
        super.setMoney(money + delta);
    }
}

```

## 10_接口、多态

### 02_接口的定义基本格式

```java
/*
接口就是多个类的公共规范。
接口是一种引用数据类型，最重要的内容就是其中的：抽象方法。

如何定义一个接口的格式：
public interface 接口名称 {
    // 接口内容
}

备注：换成了关键字interface之后，编译生成的字节码文件仍然是：.java --> .class。

如果是Java 7，那么接口中可以包含的内容有：
1. 常量
2. 抽象方法

如果是Java 8，还可以额外包含有：
3. 默认方法
4. 静态方法

如果是Java 9，还可以额外包含有：
5. 私有方法

接口使用步骤：
1. 接口不能直接使用，必须有一个“实现类”来“实现”该接口。
格式：
public class 实现类名称 implements 接口名称 {
    // ...
}
2. 接口的实现类必须覆盖重写（实现）接口中所有的抽象方法。
实现：去掉abstract关键字，加上方法体大括号。
3. 创建实现类的对象，进行使用。

注意事项：
如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类自己就必须是抽象类。
 */
public class Demo01Interface {

    public static void main(String[] args) {
        // 错误写法！不能直接new接口对象使用。
//        MyInterfaceAbstract inter = new MyInterfaceAbstract();

        // 创建实现类的对象使用
        MyInterfaceAbstractImpl impl = new MyInterfaceAbstractImpl();
        impl.methodAbs1();
        impl.methodAbs2();
    }

}
```

### 03_接口的抽象方法定义

```java
/*
在任何版本的Java中，接口都能定义抽象方法。
格式：
public abstract 返回值类型 方法名称(参数列表);

注意事项：
1. 接口当中的抽象方法，修饰符必须是两个固定的关键字：public abstract
2. 这两个关键字修饰符，可以选择性地省略。（今天刚学，所以不推荐。）
3. 方法的三要素，可以随意定义。
 */
public interface MyInterfaceAbstract {

    // 这是一个抽象方法
    public abstract void methodAbs1();

    // 这也是抽象方法
    abstract void methodAbs2();

    // 这也是抽象方法
    public void methodAbs3();

    // 这也是抽象方法
    void methodAbs4();

}

```

### 04_接口的抽象方法使用

```java
main见02
抽象方法见03
实现类
package cn.itcast.day10.demo01;

public class MyInterfaceAbstractImpl implements MyInterfaceAbstract {
    @Override
    public void methodAbs1() {
        System.out.println("这是第一个方法！");
    }

    @Override
    public void methodAbs2() {
        System.out.println("这是第二个方法！");
    }

    @Override
    public void methodAbs3() {
        System.out.println("这是第三个方法！");
    }

    @Override
    public void methodAbs4() {
        System.out.println("这是第四个方法！");
    }
}


```

### 05_接口的默认方法定义

```
/*
从Java 8开始，接口里允许定义默认方法。
格式：
public default 返回值类型 方法名称(参数列表) {
    方法体
}
```

### 06_接口的默认方法使用

```java
main方法

package cn.itcast.day10.demo01;

/*
1. 接口的默认方法，可以通过接口实现类对象，直接调用。
2. 接口的默认方法，也可以被接口实现类进行覆盖重写。
 */
public class Demo02Interface {

    public static void main(String[] args) {
        // 创建了实现类对象
        MyInterfaceDefaultA a = new MyInterfaceDefaultA();
        a.methodAbs(); // 调用抽象方法，实际运行的是右侧实现类。

        // 调用默认方法，如果实现类当中没有，会向上找接口
        a.methodDefault(); // 这是新添加的默认方法
        System.out.println("==========");

        MyInterfaceDefaultB b = new MyInterfaceDefaultB();
        b.methodAbs();
        b.methodDefault(); // 实现类B覆盖重写了接口的默认方法
    }

}
接口
package cn.itcast.day10.demo01;

/*
从Java 8开始，接口里允许定义默认方法。
格式：
public default 返回值类型 方法名称(参数列表) {
    方法体
}

备注：接口当中的默认方法，可以解决接口升级的问题。
 */
public interface MyInterfaceDefault {

    // 抽象方法
    public abstract void methodAbs();

    // 新添加了一个抽象方法
//    public abstract void methodAbs2();

    // 新添加的方法，改成默认方法
    public default void methodDefault() {
        System.out.println("这是新添加的默认方法");
    }

}

接口实现类对象A
package cn.itcast.day10.demo01;

public class MyInterfaceDefaultA implements MyInterfaceDefault {
    @Override
    public void methodAbs() {
        System.out.println("实现了抽象方法，AAA");
    }
}
接口实现类对象B
package cn.itcast.day10.demo01;

public class MyInterfaceDefaultB implements MyInterfaceDefault {
    @Override
    public void methodAbs() {
        System.out.println("实现了抽象方法，BBB");
    }

    @Override
    public void methodDefault() {
        System.out.println("实现类B覆盖重写了接口的默认方法");
    }
}

```

### 07_接口的静态方法定义

```
/*
*从java8开始，接口允许定义静态方法
*格式：
*public static   返回值类型  方法名称(){
*方法体
*}
*提示：就是将abstract或者default即可，带上方法体
**/

```

### 08_接口的静态方法使用

```java
/*
注意事项：不能通过接口实现类的对象来调用接口当中的静态方法。
正确用法：通过接口名称，直接调用其中的静态方法。
格式：
接口名称.静态方法名(参数);
 */
public class Demo03Interface {

    public static void main(String[] args) {
        // 创建了实现类对象
        MyInterfaceStaticImpl impl = new MyInterfaceStaticImpl();

        // 错误写法！
//        impl.methodStatic();

        // 直接通过接口名称调用静态方法
        MyInterfaceStatic.methodStatic();
    }

}

接口
package cn.itcast.day10.demo01;

/*
从Java 8开始，接口当中允许定义静态方法。
格式：
public static 返回值类型 方法名称(参数列表) {
    方法体
}
提示：就是将abstract或者default换成static即可，带上方法体。
 */
public interface MyInterfaceStatic {

    public static void methodStatic() {
        System.out.println("这是接口的静态方法！");
    }

}

接口实现类
package cn.itcast.day10.demo01;

public class MyInterfaceStaticImpl implements MyInterfaceStatic {
}

```

### 09_接口的私有方法定义

```java
package cn.itcast.day10.demo01;

/*
问题描述：
我们需要抽取一个共有方法，用来解决两个默认方法之间重复代码的问题。
但是这个共有方法不应该让实现类使用，应该是私有化的。

解决方案：
从Java 9开始，接口当中允许定义私有方法。
1. 普通私有方法，解决多个默认方法之间重复代码问题
格式：
private 返回值类型 方法名称(参数列表) {
    方法体
}

2. 静态私有方法，解决多个静态方法之间重复代码问题
格式：
private static 返回值类型 方法名称(参数列表) {
    方法体
}
 */
public interface MyInterfacePrivateA {

    public default void methodDefault1() {
        System.out.println("默认方法1");
        methodCommon();
    }

    public default void methodDefault2() {
        System.out.println("默认方法2");
        methodCommon();
    }

    private void methodCommon() {
        System.out.println("AAA");
        System.out.println("BBB");
        System.out.println("CCC");
    }

}

```

### 10_接口的私有方法使用

```java
普通私有方法见09
main方法
package cn.itcast.day10.demo01;

public class Demo04Interface {

    public static void main(String[] args) {
        MyInterfacePrivateB.methodStatic1();
        MyInterfacePrivateB.methodStatic2();
        // 错误写法！
//        MyInterfacePrivateB.methodStaticCommon();
    }

}


接口
package cn.itcast.day10.demo01;

public interface MyInterfacePrivateB {

    public static void methodStatic1() {
        System.out.println("静态方法1");
        methodStaticCommon();
    }

    public static void methodStatic2() {
        System.out.println("静态方法2");
        methodStaticCommon();
    }

    private static void methodStaticCommon() {
        System.out.println("AAA");
        System.out.println("BBB");
        System.out.println("CCC");
    }

}

```

### 11_接口的常量定义和使用

```java
main方法
package cn.itcast.day10.demo01;

public class Demo05Interface {

    public static void main(String[] args) {
        // 访问接口当中的常量
        System.out.println(MyInterfaceConst.NUM_OF_MY_CLASS);
    }

}

接口
package cn.itcast.day10.demo01;

/*
接口当中也可以定义“成员变量”，但是必须使用public static final三个关键字进行修饰。
从效果上看，这其实就是接口的【常量】。
格式：
public static final 数据类型 常量名称 = 数据值;
备注：
一旦使用final关键字进行修饰，说明不可改变。

注意事项：
1. 接口当中的常量，可以省略public static final，注意：不写也照样是这样。
2. 接口当中的常量，必须进行赋值；不能不赋值。
3. 接口中常量的名称，使用完全大写的字母，用下划线进行分隔。（推荐命名规则）
 */
public interface MyInterfaceConst {

    // 这其实就是一个常量，一旦赋值，不可以修改
    public static final int NUM_OF_MY_CLASS = 12;
}
```

### 12_接口的内容小结

![接口的内容小结](C:/Users/Murphy/Pictures/接口的内容小结.png)

### 13_继承父类并实现多个接口

```java

/*
使用接口的时候，需要注意：

1. 接口是没有静态代码块或者构造方法的。
2. 一个类的直接父类是唯一的，但是一个类可以同时实现多个接口。
格式：
public class MyInterfaceImpl implements MyInterfaceA, MyInterfaceB {
    // 覆盖重写所有抽象方法
}
3. 如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可。
4. 如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类。
5. 如果实现类所实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。
6. 一个类如果直接父类当中的方法，和接口当中的默认方法产生了冲突，优先用父类当中的方法。
 */
public class Demo01Interface {

    public static void main(String[] args) {
        Zi zi = new Zi();
        zi.method();
    }

}
接口
package cn.itcast.day10.demo02;

public interface MyInterface {

    public default void method() {
        System.out.println("接口的默认方法");
    }

}

接口A
package cn.itcast.day10.demo02;

public interface MyInterfaceA {

    // 错误写法！接口不能有静态代码块
//    static {
//
//    }

    // 错误写法！接口不能有构造方法
//    public MyInterfaceA() {
//
//    }

    public abstract void methodA();

    public abstract void methodAbs();

    public default void methodDefault() {
        System.out.println("默认方法AAA");
    }

}
接口B
package cn.itcast.day10.demo02;

public interface MyInterfaceB {

    // 错误写法！接口不能有静态代码块
//    static {
//
//    }

    // 错误写法！接口不能有构造方法
//    public MyInterfaceA() {
//
//    }

    public abstract void methodB();

    public abstract void methodAbs();

    public default void methodDefault() {
        System.out.println("默认方法BBB");
    }

}
继承多个接口
package cn.itcast.day10.demo02;

public abstract class MyInterfaceAbstract implements MyInterfaceA, MyInterfaceB {
    @Override
    public void methodA() {

    }

    @Override
    public void methodAbs() {

    }

    @Override
    public void methodDefault() {

    }


}

继承两个接口
package cn.itcast.day10.demo02;

public class MyInterfaceImpl /*extends Object*/ implements MyInterfaceA, MyInterfaceB {

    @Override
    public void methodA() {
        System.out.println("覆盖重写了A方法");
    }


    @Override
    public void methodB() {
        System.out.println("覆盖重写了B方法");
    }

    @Override
    public void methodAbs() {
        System.out.println("覆盖重写了AB接口都有的抽象方法");
    }

    @Override
    public void methodDefault() {
        System.out.println("对多个接口当中冲突的默认方法进行了覆盖重写");
    }
}

父类
package cn.itcast.day10.demo02;

public class Fu {

    public void method() {
        System.out.println("父类方法");
    }

}

子类
package cn.itcast.day10.demo02;

public class Zi extends Fu implements MyInterface {
}

```

### 14_接口之间的多继承

```java
Main方法

package cn.itcast.day10.demo03;

/*
1. 类与类之间是单继承的。直接父类只有一个。
2. 类与接口之间是多实现的。一个类可以实现多个接口。
3. 接口与接口之间是多继承的。

注意事项：
1. 多个父接口当中的抽象方法如果重复，没关系。
2. 多个父接口当中的默认方法如果重复，那么子接口必须进行默认方法的覆盖重写，【而且带着default关键字】。
 */
public class Demo01Relations {
}


接口A
package cn.itcast.day10.demo03;

public interface MyInterfaceA {

    public abstract void methodA();

    public abstract void methodCommon();

    public default void methodDefault() {
        System.out.println("AAA");
    }

}

接口B

package cn.itcast.day10.demo03;

public interface MyInterfaceB {

    public abstract void methodB();

    public abstract void methodCommon();

    public default void methodDefault() {
        System.out.println("BBB");
    }

}

接口继承AB
package cn.itcast.day10.demo03;

/*
这个子接口当中有几个方法？答：4个。
methodA 来源于接口A
methodB 来源于接口B
methodCommon 同时来源于接口A和B
method 来源于我自己
 */
public interface MyInterface extends MyInterfaceA, MyInterfaceB {

    public abstract void method();

    @Override
    public default void methodDefault() {

    }
}

实现多个接口
package cn.itcast.day10.demo03;

public class MyInterfaceImpl implements MyInterface {
    @Override
    public void method() {

    }

    @Override
    public void methodA() {

    }

    @Override
    public void methodB() {

    }

    @Override
    public void methodCommon() {

    }
}

```

### 15_多态的概述

![03-多态的概述](C:/Users/Murphy/Pictures/03-多态的概述.png)

### 16_多态的格式与使用

```java
main方法
package cn.itcast.day10.demo04;

/*
代码当中体现多态性，其实就是一句话：父类引用指向子类对象。

格式：
父类名称 对象名 = new 子类名称();
或者：
接口名称 对象名 = new 实现类名称();
 */
public class Demo01Multi {

    public static void main(String[] args) {
        // 使用多态的写法
        // 左侧父类的引用，指向了右侧子类的对象
        Fu obj = new Zi();

        obj.method();
        obj.methodFu();
    }
}

父类
package cn.itcast.day10.demo04;

public class Fu {

    public void method() {
        System.out.println("父类方法");
    }

    public void methodFu() {
        System.out.println("父类特有方法");
    }

}

子类
package cn.itcast.day10.demo04;

public class Zi extends Fu {

    @Override
    public void method() {
        System.out.println("子类方法");
    }
}

```

### 17_多态中成员变量的使用特点

```java
/*
访问成员变量的两种方式：

1. 直接通过对象名称访问成员变量：看等号左边是谁，优先用谁，没有则向上找。
2. 间接通过成员方法访问成员变量：看该方法属于谁，优先用谁，没有则向上找。
 */
public class Demo01MultiField {

    public static void main(String[] args) {
        // 使用多态的写法，父类引用指向子类对象
        Fu obj = new Zi();
        System.out.println(obj.num); // 父：10
//        System.out.println(obj.age); // 错误写法！
        System.out.println("=============");

        // 子类没有覆盖重写，就是父：10
        // 子类如果覆盖重写，就是子：20
        obj.showNum();
    }

}
父类
子类见18

```

### 18_多态中成员方法的使用特点

```java
Main 方法
package cn.itcast.day10.demo05;

/*
在多态的代码当中，成员方法的访问规则是：
    看new的是谁，就优先用谁，没有则向上找。

口诀：编译看左边，运行看右边。

对比一下：
成员变量：编译看左边，运行还看左边。
成员方法：编译看左边，运行看右边。
 */
public class Demo02MultiMethod {

    public static void main(String[] args) {
        Fu obj = new Zi(); // 多态

        obj.method(); // 父子都有，优先用子
        obj.methodFu(); // 子类没有，父类有，向上找到父类

        // 编译看左边，左边是Fu，Fu当中没有methodZi方法，所以编译报错。
//        obj.methodZi(); // 错误写法！
    }

}

父类
package cn.itcast.day10.demo05;

public class Fu /*extends Object*/ {

    int num = 10;

    public void showNum() {
        System.out.println(num);
    }

    public void method() {
        System.out.println("父类方法");
    }

    public void methodFu() {
        System.out.println("父类特有方法");
    }

}

子类
package cn.itcast.day10.demo05;

public class Zi extends Fu {

    int num = 20;

    int age = 16;

    @Override
    public void showNum() {
        System.out.println(num);
    }

    @Override
    public void method() {
        System.out.println("子类方法");
    }

    public void methodZi() {
        System.out.println("子类特有方法");
    }
}

```

### 19_使用多态的好处

![04-使用多态的好处](C:/Users/Murphy/Pictures/04-使用多态的好处.png)

### 20_对象的向上转型

![对象的向上转型](C:/Users/Murphy/Pictures/对象的向上转型.png)

```java
Main
packagecn.itcast.day10.Demo06;

publicclassDemo01Main{
publicstaticvoidmain(String[]args){
Animalanimal=newCat();
animal.eat();
}
}

父类
packagecn.itcast.day10.Demo06;

publicabstractclassAnimal{
publicabstractvoideat();
}

子类
    
packagecn.itcast.day10.Demo06;

publicclassCatextendsAnimal{
@Override
publicvoideat(){
System.out.println("猫吃鱼");
}
}

```

### 21_对象的向下转型

![05-对象的上下转型](C:/Users/Murphy/Pictures/05-对象的上下转型.png)

```java
Main

package cn.itcast.day10.demo06;

/*
向上转型一定是安全的，没有问题的，正确的。但是也有一个弊端：
对象一旦向上转型为父类，那么就无法调用子类原本特有的内容。

解决方案：用对象的向下转型【还原】。
 */
public class Demo01Main {

    public static void main(String[] args) {
        // 对象的向上转型，就是：父类引用指向之类对象。
        Animal animal = new Cat(); // 本来创建的时候是一只猫
        animal.eat(); // 猫吃鱼

//        animal.catchMouse(); // 错误写法！

        // 向下转型，进行“还原”动作
        Cat cat = (Cat) animal;
        cat.catchMouse(); // 猫抓老鼠

        // 下面是错误的向下转型
        // 本来new的时候是一只猫，现在非要当做狗
        // 错误写法！编译不会报错，但是运行会出现异常：
        // java.lang.ClassCastException，类转换异常
        Dog dog = (Dog) animal;
    }

}

父类动物
package cn.itcast.day10.demo06;

public abstract class Animal {

    public abstract void eat();

}
子类猫
package cn.itcast.day10.demo06;

public class Cat extends Animal {
    @Override
    public void eat() {
        System.out.println("猫吃鱼");
    }

    // 子类特有方法
    public void catchMouse() {
        System.out.println("猫抓老鼠");
    }
}

子类狗
package cn.itcast.day10.demo06;

public class Dog extends Animal {
    @Override
    public void eat() {
        System.out.println("狗吃SHIT");
    }

    public void watchHouse() {
        System.out.println("狗看家");
    }
}

```

### 22_用instanceof关键字进行类型判断

```java
父类子类承接21对象的向下转型
package cn.itcast.day10.demo06;

/*
如何才能知道一个父类引用的对象，本来是什么子类？
格式：
对象 instanceof 类名称
这将会得到一个boolean值结果，也就是判断前面的对象能不能当做后面类型的实例。
 */
public class Demo02Instanceof {

    public static void main(String[] args) {
        Animal animal = new Dog(); // 本来是一只狗
        animal.eat(); // 狗吃SHIT

        // 如果希望掉用子类特有方法，需要向下转型
        // 判断一下父类引用animal本来是不是Dog
        if (animal instanceof Dog) {
            Dog dog = (Dog) animal;
            dog.watchHouse();
        }
        // 判断一下animal本来是不是Cat
        if (animal instanceof Cat) {
            Cat cat = (Cat) animal;
            cat.catchMouse();
        }

        giveMeAPet(new Dog());
    }

    public static void giveMeAPet(Animal animal) {
        if (animal instanceof Dog) {
            Dog dog = (Dog) animal;
            dog.watchHouse();
        }
        if (animal instanceof Cat) {
            Cat cat = (Cat) animal;
            cat.catchMouse();
        }
    }

}

```

### 23_笔记本USB接口案例

![06-笔记本电脑案例分析](C:/Users/Murphy/Pictures/06-笔记本电脑案例分析.png)

```java
Main方法
package cn.itcast.day10.demo07;

public class DemoMain {

    public static void main(String[] args) {
        // 首先创建一个笔记本电脑
        Computer computer = new Computer();
        computer.powerOn();

        // 准备一个鼠标，供电脑使用
//        Mouse mouse = new Mouse();
        // 首先进行向上转型
        USB usbMouse = new Mouse(); // 多态写法
        // 参数是USB类型，我正好传递进去的就是USB鼠标
        computer.useDevice(usbMouse);

        // 创建一个USB键盘
        Keyboard keyboard = new Keyboard(); // 没有使用多态写法
        // 方法参数是USB类型，传递进去的是实现类对象
        computer.useDevice(keyboard); // 正确写法！也发生了向上转型
        // 使用子类对象，匿名对象，也可以
//        computer.useDevice(new Keyboard()); // 也是正确写法

        computer.powerOff();
        System.out.println("==================");

        method(10.0); // 正确写法，double --> double
        method(20); // 正确写法，int --> double
        int a = 30;
        method(a); // 正确写法，int --> double
    }

    public static void method(double num) {
        System.out.println(num);
    }

}
电脑类
package cn.itcast.day10.demo07;

public class Computer {

    public void powerOn() {
        System.out.println("笔记本电脑开机");
    }

    public void powerOff() {
        System.out.println("笔记本电脑关机");
    }

    // 使用USB设备的方法，使用接口作为方法的参数
    public void useDevice(USB usb) {
        usb.open(); // 打开设备
        if (usb instanceof Mouse) { // 一定要先判断
            Mouse mouse = (Mouse) usb; // 向下转型
            mouse.click();
        } else if (usb instanceof Keyboard) { // 先判断
            Keyboard keyboard = (Keyboard) usb; // 向下转型
            keyboard.type();
        }
        usb.close(); // 关闭设备
    }

}
接口 usb
package cn.itcast.day10.demo07;

public interface USB {

    public abstract void open(); // 打开设备

    public abstract void close(); // 关闭设备

}
实现类 键盘
package cn.itcast.day10.demo07;

// 键盘就是一个USB设备
public class Keyboard implements USB {
    @Override
    public void open() {
        System.out.println("打开键盘");
    }

    @Override
    public void close() {
        System.out.println("关闭键盘");
    }

    public void type() {
        System.out.println("键盘输入");
    }
}

实现类 鼠标
package cn.itcast.day10.demo07;

// 鼠标就是一个USB设备
public class Mouse implements USB {
    @Override
    public void open() {
        System.out.println("打开鼠标");
    }

    @Override
    public void close() {
        System.out.println("关闭鼠标");
    }

    public void click() {
        System.out.println("鼠标点击");
    }
}

```

## 11_final、权限、内部类

### 01_final关键字概念与四种用法

```
1.可以用来修饰一个类
2.可以用来修饰一个方法
3.还可以用来修饰一个局部变量
4.还可以修饰一个成员变量
```

### 02_final关键字用于修饰类

```java

/*
当final关键字用来修饰一个类的时候，格式：
public final class 类名称 {
    // ...
}

含义：当前这个类不能有任何的子类。（太监类）
注意：一个类如果是final的，那么其中所有的成员方法都无法进行覆盖重写（因为没儿子。）
 */
public final class MyClass /*extends Object*/ {

    public void method() {
        System.out.println("方法执行！");
    }

}
```

### 03_final关键字用于修饰成员方法

```java
package cn.itcast.day11.demo01;

/*
当final关键字用来修饰一个方法的时候，这个方法就是最终方法，也就是不能被覆盖重写。
格式：
修饰符 final 返回值类型 方法名称(参数列表) {
    // 方法体
}

注意事项：
对于类、方法来说，abstract关键字和final关键字不能同时使用，因为矛盾。
 */
public abstract class Fu {

    public final void method() {
        System.out.println("父类方法执行！");
    }

    public abstract /*final*/ void methodAbs() ;

}

```

### 04_final关键字用于修饰局部变量

```java
Main

package cn.itcast.day11.demo01;

/*
final关键字代表最终、不可改变的。

常见四种用法：
1. 可以用来修饰一个类
2. 可以用来修饰一个方法
3. 还可以用来修饰一个局部变量
4. 还可以用来修饰一个成员变量
 */
public class Demo01Final {

    public static void main(String[] args) {
        int num1 = 10;
        System.out.println(num1); // 10
        num1 = 20;
        System.out.println(num1); // 20

        // 一旦使用final用来修饰局部变量，那么这个变量就不能进行更改。
        // “一次赋值，终生不变”
        final int num2 = 200;
        System.out.println(num2); // 200

//        num2 = 250; // 错误写法！不能改变！
//        num2 = 200; // 错误写法！

        // 正确写法！只要保证有唯一一次赋值即可
        final int num3;
        num3 = 30;

        // 对于基本类型来说，不可变说的是变量当中的数据不可改变
        // 对于引用类型来说，不可变说的是变量当中的地址值不可改变
        Student stu1 = new Student("赵丽颖");
        System.out.println(stu1);
        System.out.println(stu1.getName()); // 赵丽颖
        stu1 = new Student("霍建华");
        System.out.println(stu1);
        System.out.println(stu1.getName()); // 霍建华
        System.out.println("===============");

        final Student stu2 = new Student("高圆圆");
        // 错误写法！final的引用类型变量，其中的地址不可改变
//        stu2 = new Student("赵又廷");
        System.out.println(stu2.getName()); // 高圆圆
        stu2.setName("高圆圆圆圆圆圆");
        System.out.println(stu2.getName()); // 高圆圆圆圆圆圆
    }

}

学生类
package cn.itcast.day11.demo01;

public class Student {

    private String name;

    public Student() {
    }

    public Student(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

```

### 05_final关键字用于修饰成员变量

```java
/*
对于成员变量来说，如果使用final关键字修饰，那么这个变量也照样是不可变。

1. 由于成员变量具有默认值，所以用了final之后必须手动赋值，不会再给默认值了。
2. 对于final的成员变量，要么使用直接赋值，要么通过构造方法赋值。二者选其一。
3. 必须保证类当中所有重载的构造方法，都最终会对final的成员变量进行赋值。
 */
public class Person {

    private final String name/* = "鹿晗"*/;

    public Person() {
        name = "关晓彤";
    }

    public Person(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

//    public void setName(String name) {
//        this.name = name;
//    }
}

```

### 06_四种权限修饰符

```
/*
Java中有四种权限修饰符：
                    public  >   protected   >   (default)   >   private
同一个类（我自己）        YES         YES             YES             YES
同一个包（我邻居）        YES         YES             YES             NO
不同包子类（我儿子）      YES         YES              NO              NO
不同包非子类（陌生人）     YES         NO              NO               NO

注意事项：(default)并不是关键字“default”，而是根本不写。
 */
public class Demo01Main {
}

```

### 07_内部类的概念与分类

```
如果一个事物的内部包含另一个食物，那么这就是一个类内部包含另一个类。
分类：
1.成员内部类
2.局部内部类(包含匿名内部类)
```

### 08_成员内部类的定义

```java
/*
如果一个事物的内部包含另一个事物，那么这就是一个类内部包含另一个类。
例如：身体和心脏的关系。又如：汽车和发动机的关系。

分类：
1. 成员内部类
2. 局部内部类（包含匿名内部类）

成员内部类的定义格式：
修饰符 class 外部类名称 {
    修饰符 class 内部类名称 {
        // ...
    }
    // ...
}

注意：内用外，随意访问；外用内，需要内部类对象。

==========================
public class Demo01InnerClass {

    public static void main(String[] args) {
        Body body = new Body(); // 外部类的对象
        // 通过外部类的对象，调用外部类的方法，里面间接在使用内部类Heart
        body.methodBody();
        System.out.println("=====================");

         }

}


package cn.itcast.day11.demo03;

public class Body { // 外部类

    public class Heart { // 成员内部类

        // 内部类的方法
        public void beat() {
            System.out.println("心脏跳动：蹦蹦蹦！");
            System.out.println("我叫：" + name); // 正确写法！
        }

    }

    // 外部类的成员变量
    private String name;

    // 外部类的方法
    public void methodBody() {
        System.out.println("外部类的方法");
        new Heart().beat();
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

```

### 09_成员内部类的使用

```java
/*
如果一个事物的内部包含另一个事物，那么这就是一个类内部包含另一个类。
例如：身体和心脏的关系。又如：汽车和发动机的关系。

分类：
1. 成员内部类
2. 局部内部类（包含匿名内部类）

成员内部类的定义格式：
修饰符 class 外部类名称 {
    修饰符 class 内部类名称 {
        // ...
    }
    // ...
}

注意：内用外，随意访问；外用内，需要内部类对象。

==========================
如何使用成员内部类？有两种方式：
1. 间接方式：在外部类的方法当中，使用内部类；然后main只是调用外部类的方法。
2. 直接方式，公式：
类名称 对象名 = new 类名称();
【外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();】
 */
public class Demo01InnerClass {

    public static void main(String[] args) {
        Body body = new Body(); // 外部类的对象
        // 通过外部类的对象，调用外部类的方法，里面间接在使用内部类Heart
        body.methodBody();
        System.out.println("=====================");

        // 按照公式写：
        Body.Heart heart = new Body().new Heart();
        heart.beat();
    }

}

package cn.itcast.day11.demo03;

public class Body { // 外部类

    public class Heart { // 成员内部类

        // 内部类的方法
        public void beat() {
            System.out.println("心脏跳动：蹦蹦蹦！");
            System.out.println("我叫：" + name); // 正确写法！
        }

    }

    // 外部类的成员变量
    private String name;

    // 外部类的方法
    public void methodBody() {
        System.out.println("外部类的方法");
        new Heart().beat();
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

```

### 10_内部类的同名变量访问

```java
public class Demo02InnerClass {

    public static void main(String[] args) {
        // 外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();
        Outer.Inner obj = new Outer().new Inner();
        obj.methodInner();
    }

}

package cn.itcast.day11.demo03;

// 如果出现了重名现象，那么格式是：外部类名称.this.外部类成员变量名
public class Outer {

    int num = 10; // 外部类的成员变量

    public class Inner /*extends Object*/ {

        int num = 20; // 内部类的成员变量

        public void methodInner() {
            int num = 30; // 内部类方法的局部变量
            System.out.println(num); // 局部变量，就近原则
            System.out.println(this.num); // 内部类的成员变量
            System.out.println(Outer.this.num); // 外部类的成员变量
        }

    }

}

```

### 11_局部内部类定义

```java
public class DemoMain {

    public static void main(String[] args) {
        Outer obj = new Outer();
        obj.methodOuter();
    }

}

package cn.itcast.day11.demo04;

/*
如果一个类是定义在一个方法内部的，那么这就是一个局部内部类。
“局部”：只有当前所属的方法才能使用它，出了这个方法外面就不能用了。

定义格式：
修饰符 class 外部类名称 {
    修饰符 返回值类型 外部类方法名称(参数列表) {
        class 局部内部类名称 {
            // ...
        }
    }
}

小节一下类的权限修饰符：
public > protected > (default) > private
定义一个类的时候，权限修饰符规则：
1. 外部类：public / (default)
2. 成员内部类：public / protected / (default) / private
3. 局部内部类：什么都不能写
 */
class Outer {

    public void methodOuter() {
        class Inner { // 局部内部类
            int num = 10;
            public void methodInner() {
                System.out.println(num); // 10
            }
        }

        Inner inner = new Inner();
        inner.methodInner();
    }

}

```

### 12_局部内部类的final问题

```java
/*
局部内部类，如果希望访问所在方法的局部变量，那么这个局部变量必须是【有效final的】。

备注：从Java 8+开始，只要局部变量事实不变，那么final关键字可以省略。

原因：
1. new出来的对象在堆内存当中。
2. 局部变量是跟着方法走的，在栈内存当中。
3. 方法运行结束之后，立刻出栈，局部变量就会立刻消失。
4. 但是new出来的对象会在堆当中持续存在，直到垃圾回收消失。
 */
public class MyOuter {

    public void methodOuter() {
        int num = 10; // 所在方法的局部变量

        class MyInner {
            public void methodInner() {
                System.out.println(num);
            }
        }
    }

}

```

### 13_匿名内部类

```java
匿名内部类的定义格式：
接口名称 对象名 = new 接口名称() {
    // 覆盖重写所有抽象方法
};

对格式“new 接口名称() {...}”进行解析：
1. new代表创建对象的动作
2. 接口名称就是匿名内部类需要实现哪个接口
3. {...}这才是匿名内部类的内容
```

### 14_匿名内部类的注意事项

```java
/*
如果接口的实现类（或者是父类的子类）只需要使用唯一的一次，
那么这种情况下就可以省略掉该类的定义，而改为使用【匿名内部类】。

匿名内部类的定义格式：
接口名称 对象名 = new 接口名称() {
    // 覆盖重写所有抽象方法
};

对格式“new 接口名称() {...}”进行解析：
1. new代表创建对象的动作
2. 接口名称就是匿名内部类需要实现哪个接口
3. {...}这才是匿名内部类的内容

另外还要注意几点问题：
1. 匿名内部类，在【创建对象】的时候，只能使用唯一一次。
如果希望多次创建对象，而且类的内容一样的话，那么就需要使用单独定义的实现类了。
2. 匿名对象，在【调用方法】的时候，只能调用唯一一次。
如果希望同一个对象，调用多次方法，那么必须给对象起个名字。
3. 匿名内部类是省略了【实现类/子类名称】，但是匿名对象是省略了【对象名称】
强调：匿名内部类和匿名对象不是一回事！！！
 */
public class DemoMain {

    public static void main(String[] args) {
//        MyInterface obj = new MyInterfaceImpl();
//        obj.method();

//        MyInterface some = new MyInterface(); // 错误写法！

        // 使用匿名内部类，但不是匿名对象，对象名称就叫objA
        MyInterface objA = new MyInterface() {
            @Override
            public void method1() {
                System.out.println("匿名内部类实现了方法！111-A");
            }

            @Override
            public void method2() {
                System.out.println("匿名内部类实现了方法！222-A");
            }
        };
        objA.method1();
        objA.method2();
        System.out.println("=================");

        // 使用了匿名内部类，而且省略了对象名称，也是匿名对象
        new MyInterface() {
            @Override
            public void method1() {
                System.out.println("匿名内部类实现了方法！111-B");
            }

            @Override
            public void method2() {
                System.out.println("匿名内部类实现了方法！222-B");
            }
        }.method1();
        // 因为匿名对象无法调用第二次方法，所以需要再创建一个匿名内部类的匿名对象
        new MyInterface() {
            @Override
            public void method1() {
                System.out.println("匿名内部类实现了方法！111-B");
            }

            @Override
            public void method2() {
                System.out.println("匿名内部类实现了方法！222-B");
            }
        }.method2();
    }

}
```

### 15_类作为成员变量类型

```java
Main


package cn.itcast.day11.demo06;

public class DemoMain {

    public static void main(String[] args) {
        // 创建一个英雄角色
        Hero hero = new Hero();
        // 为英雄起一个名字，并且设置年龄
        hero.setName("盖伦");
        hero.setAge(20);

        // 创建一个武器对象
        Weapon weapon = new Weapon("AK-47");
        // 为英雄配备武器
        hero.setWeapon(weapon);

        // 年龄为20的盖伦用多兰剑攻击敌方。
        hero.attack();
    }

}

package cn.itcast.day11.demo06;

// 游戏当中的英雄角色类
public class Hero {

    private String name; // 英雄的名字
    private int age; // 英雄的年龄
    private Weapon weapon; // 英雄的武器

    public Hero() {
    }

    public Hero(String name, int age, Weapon weapon) {
        this.name = name;
        this.age = age;
        this.weapon = weapon;
    }

    public void attack() {
        System.out.println("年龄为" + age + "的" + name + "用" + weapon.getCode() + "攻击敌方。");
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public Weapon getWeapon() {
        return weapon;
    }

    public void setWeapon(Weapon weapon) {
        this.weapon = weapon;
    }
}


package cn.itcast.day11.demo06;

public class Weapon {

    private String code; // 武器的代号

    public Weapon() {
    }

    public Weapon(String code) {
        this.code = code;
    }

    public String getCode() {
        return code;
    }

    public void setCode(String code) {
        this.code = code;
    }
}

```

### 16_接口作为成员变量类型

```java
public class DemoGame {

    public static void main(String[] args) {
        Hero hero = new Hero();
        hero.setName("艾希"); // 设置英雄的名称

        // 设置英雄技能
//        hero.setSkill(new SkillImpl()); // 使用单独定义的实现类

        // 还可以改成使用匿名内部类
//        Skill skill = new Skill() {
//            @Override
//            public void use() {
//                System.out.println("Pia~pia~pia~");
//            }
//        };
//        hero.setSkill(skill);

        // 进一步简化，同时使用匿名内部类和匿名对象
        hero.setSkill(new Skill() {
            @Override
            public void use() {
                System.out.println("Biu~Pia~Biu~Pia~");
            }
        });

        hero.attack();
    }

}

类
package cn.itcast.day11.demo07;

public class Hero {

    private String name; // 英雄的名称
    private Skill skill; // 英雄的技能

    public Hero() {
    }

    public Hero(String name, Skill skill) {
        this.name = name;
        this.skill = skill;
    }

    public void attack() {
        System.out.println("我叫" + name + "，开始施放技能：");
        skill.use(); // 调用接口中的抽象方法
        System.out.println("施放技能完成。");
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Skill getSkill() {
        return skill;
    }

    public void setSkill(Skill skill) {
        this.skill = skill;
    }
}

接口
package cn.itcast.day11.demo07;

public interface Skill {

    void use(); // 释放技能的抽象方法

}

```

### 17_接口作为方法的参数和或返回值

```java
import java.util.ArrayList;
import java.util.List;

/*
java.util.List正是ArrayList所实现的接口。
 */
public class DemoInterface {

    public static void main(String[] args) {
        // 左边是接口名称，右边是实现类名称，这就是多态写法
        List<String> list = new ArrayList<>();

        List<String> result = addNames(list);
        for (int i = 0; i < result.size(); i++) {
            System.out.println(result.get(i));
        }
    }

    public static List<String> addNames(List<String> list) {
        list.add("迪丽热巴");
        list.add("古力娜扎");
        list.add("玛尔扎哈");
        list.add("沙扬娜拉");
        return list;
    
}
```

# java进阶

## 01_Object类、常用API

### 01_Object类的toString方法

```java
Main

package com.itheima.demo01.Object;

import java.util.ArrayList;
import java.util.Random;
import java.util.Scanner;

/*
    java.lang.Object
    类 Object 是类层次结构的根(父)类。
    每个类(Person,Student...)都使用 Object 作为超(父)类。
    所有对象（包括数组）都实现这个类的方法。
 */
public class Demo01ToString{
    public static void main(String[] args) {
        /*
            Person类默认继承了Object类,所以可以使用Object类中的toString方法
            String toString() 返回该对象的字符串表示。
         */
        Person p = new Person("张三",18);
        String s = p.toString();
        System.out.println(s);//com.itheima.demo01.Object.Person@75412c2f | abc | Person{name=张三 ,age=18}

        //直接打印对象的名字,其实就是调用对象的toString  p=p.toString();
        System.out.println(p);//com.itheima.demo01.Object.Person@5f150435 | abc | Person{name=张三 ,age=18}

        //看一个类是否重写了toString,直接打印这个类的对象即可,如果没有重写toString方法那么打印的是对象的地址值
        Random r = new Random();
        System.out.println(r);//java.util.Random@3f3afe78  没有重写toString方法

        Scanner sc = new Scanner(System.in);
        System.out.println(sc);//java.util.Scanner[delimiters=\p{javaWhitespace}+..  重写toString方法

        ArrayList<Integer> list = new ArrayList<>();
        list.add(1);
        list.add(2);
        list.add(3);
        System.out.println(list);//[1, 2, 3]  重写toString方法
    }
}

```

演示用的Person类

```java
packagecom.itheima.demo01.Object;

publicclassPerson{
privateStringname;
privateintage;

publicPerson(){
}

publicPerson(Stringname,intage){
this.name=name;
this.age=age;
}

/*直接打印对象的地址值没有意义，所以需要重写对象的toString方法
打印对象的属性（name,age）*/

/*@Override
publicStringtoString(){
return"peson{name="+name+",age=age+"+age+"}";
}*/

@Override
publicStringtoString(){
return"Person{"+
"name='"+name+'\''+
",age="+age+
'}';
}

publicStringgetName(){
returnname;
}

publicvoidsetName(Stringname){
this.name=name;
}

publicintgetAge(){
returnage;
}

publicvoidsetAge(intage){
this.age=age;
}
}

```

### 02_Object类的equals方法

```java
Main
package com.itheima.demo01.Object;
import java.util.ArrayList;
public class Demo02Equals {
    public static void main(String[] args) {
        /*
            Person类默认继承了Object类,所以可以使用Object类的equals方法
            boolean equals(Object obj) 指示其他某个对象是否与此对象“相等”。
            equals方法源码:
                public boolean equals(Object obj) {
                    return (this == obj);
                }
                参数:
                    Object obj:可以传递任意的对象
                    == 比较运算符,返回的是一个布尔值 true false
                    基本数据类型:比较的是值
                    引用数据类型:比价的是两个对象的地址值
               this是谁?那个对象调用的方法,方法中的this就是那个对象;p1调用的equals方法所以this就是p1
               obj是谁?传递过来的参数p2
               this==obj -->p1==p2
         */
        Person p1 = new Person("迪丽热巴",18);
       Person p2 = new Person("古力娜扎",19);
            System.out.println("p1:"+p1);//p1:com.itheima.demo01.Object.Person@58ceff1
        System.out.println("p2:"+p2);//p2:com.itheima.demo01.Object.Person@7c30a502
        boolean b = p1.equals(p1);
        System.out.println(b);
    }
}

```

演示用的Person类

```java
packagecom.itheima.demo01.Object;
publicclassPerson{
privateStringname;
privateintage;
publicPerson(){
}
publicPerson(Stringname,intage){
this.name=name;
this.age=age;
}
/*直接打印对象的地址值没有意义，所以需要重写对象的toString方法
打印对象的属性（name,age）*/
/*@Override
publicStringtoString(){
return"peson{name="+name+",age=age+"+age+"}";
}*/

/*@Override
publicStringtoString(){
return"Person{"+
"name='"+name+'\''+
",age="+age+
'}';
}*/
publicStringgetName(){
returnname;
}
publicvoidsetName(Stringname){
this.name=name;
}
publicintgetAge(){
returnage;
}
publicvoidsetAge(intage){
this.age=age;
}
}

```

### 03_重写Object类的equals方法

```java
package com.itheima.demo01.Object;
import java.util.ArrayList;
public class Demo02Equals {
    public static void main(String[] args) {
        /*
            Person类默认继承了Object类,所以可以使用Object类的equals方法
            boolean equals(Object obj) 指示其他某个对象是否与此对象“相等”。
            equals方法源码:
                public boolean equals(Object obj) {
                    return (this == obj);
                }
                参数:
                    Object obj:可以传递任意的对象
                    == 比较运算符,返回的是一个布尔值 true false
                    基本数据类型:比较的是值
                    引用数据类型:比价的是两个对象的地址值
               this是谁?那个对象调用的方法,方法中的this就是那个对象;p1调用的equals方法所以this就是p1
               obj是谁?传递过来的参数p2
               this==obj -->p1==p2
         */
        Person p1 = new Person("迪丽热巴",18);
        //Person p2 = new Person("古力娜扎",19);
        Person p2 = new Person("迪丽热巴",18);
        System.out.println("p1:"+p1);//p1:com.itheima.demo01.Object.Person@58ceff1
        System.out.println("p2:"+p2);//p2:com.itheima.demo01.Object.Person@7c30a502
        //p1=p2;//把p2的地址值赋值给p1
        ArrayList<String> list = new ArrayList<>();
        boolean b = p1.equals(p1);
        System.out.println(b);
    }
}

```

演示用的Person类

```java
package com.itheima.demo01.Object;
import java.util.Objects;
public class Person {
    private String name;
    private int age;
    public Person() {
    }
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    /*
        直接打印对象的地址值没有意义,需要重写Object类中的toString方法
        打印对象的属性(name,age)
     */
    /*@Override
    public String toString() {
       //return "abc";
       return "Person{name="+name+" ,age="+age+"}";
    }*/
    /*@Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }*/
    /*
        Object类的equals方法,默认比较的是两个对象的地址值,没有意义
        所以我们要重写equals方法,比较两个对象的属性(name,age)
        问题:
            隐含着一个多态
            多态的弊端:无法使用子类特有的内容(属性和方法)
            Object obj = p2 = new Person("古力娜扎",19);
            解决:可以使用向下转型(强转)把obj类型转换为Person
     */
    /*@Override
    public boolean equals(Object obj) {
        //增加一个判断,传递的参数obj如果是this本身,直接返回true,提高程序的效率
        if(obj==this){
            return true;
        }
        //增加一个判断,传递的参数obj如果是null,直接返回false,提高程序的效率
        if(obj==null){
            return false;
        }
        //增加一个判断,防止类型转换一次ClassCastException
        if(obj instanceof Person){
            //使用向下转型,把obj转换为Person类型
            Person p = (Person)obj;
            //比较两个对象的属性,一个对象是this(p1),一个对象是p(obj->p2)
            boolean b = this.name.equals(p.name) && this.age==p.age;
            return b;
        }
        //不是Person类型直接返回false
        return false;
    }*/
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        //getClass() != o.getClass() 使用反射技术,判断o是否是Person类型  等效于 obj instanceof Person
        if (o == null || getClass() != o.getClass()) return false;
        Person person = (Person) o;
        return age == person.age &&
                Objects.equals(name, person.name);
    }
    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }
}

```

### 04_Objects类的equals方法

```java
public class Demo03Objects {
    public static void main(String[] args) {
        String s1 = "abc";
        //String s1 = null;
        String s2 = "abc";
        //boolean b = s1.equals(s2); // NullPointerException null是不能调用方法的,会抛出空指针异常
        //System.out.println(b);
        /*
            Objects类的equals方法:对两个对象进行比较,防止空指针异常
            public static boolean equals(Object a, Object b) {
                return (a == b) || (a != null && a.equals(b));
            }
         */
        boolean b2 = Objects.equals(s1, s2);
        System.out.println(b2);
    }
}

```

### 05_1_Object类&Objects类总结



![image-20211212224752847](C:/Users/Murphy/Pictures/image-20211212224752847.png)

![image-20211212224809913](C:/Users/Murphy/Pictures/image-20211212224809913.png)

![image-20211212224830186](C:/Users/Murphy/Pictures/image-20211212224830186.png)

![image-20211212224854026](C:/Users/Murphy/Pictures/image-20211212224854026.png)

### 06_毫秒值的概念和作用

```java
package com.itheima.demo02.Date;
/*
    java.util.Date:表示日期和时间的类
    类 Date 表示特定的瞬间，精确到毫秒。
    毫秒:千分之一秒 1000毫秒=1秒
    特定的瞬间:一个时间点,一刹那时间
    2088-08-08 09:55:33:333 瞬间
    2088-08-08 09:55:33:334 瞬间
    2088-08-08 09:55:33:334 瞬间
    ...
    毫秒值的作用:可以对时间和日期进行计算
    2099-01-03 到 2088-01-01 中间一共有多少天
    可以日期转换为毫秒进行计算,计算完毕,在把毫秒转换为日期

    把日期转换为毫秒:
        当前的日期:2088-01-01
        时间原点(0毫秒):1970 年 1 月 1 日 00:00:00(英国格林威治)
        就是计算当前日期到时间原点之间一共经历了多少毫秒 (3742767540068L)
    注意:
        中国属于东八区,会把时间增加8个小时
        1970 年 1 月 1 日 08:00:00

    把毫秒转换为日期:
        1 天 = 24 × 60 × 60 = 86400 秒  = 86400 x 1000 = 86400000毫秒
 */
public class Demo01Date {
    public static void main(String[] args) {
        System.out.println(System.currentTimeMillis());//获取当前系统时间到1970 年 1 月 1 日 00:00:00经历了多少毫秒
    }
}

```

### 07_Date类的构造方法和成员方法

```java
import java.util.Date;
public class Demo02Date {
    public static void main(String[] args) {
        demo03();
    }
    /*
        long getTime() 把日期转换为毫秒值(相当于System.currentTimeMillis()方法)
          返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。
     */
    private static void demo03() {
        Date date = new Date();
        long time = date.getTime();
        System.out.println(time);//3742777636267
    }
    /*
        Date类的带参数构造方法
        Date(long date) :传递毫秒值,把毫秒值转换为Date日期
     */
    private static void demo02() {
        Date date = new Date(0L);
        System.out.println(date);// Thu Jan 01 08:00:00 CST 1970
        date = new Date(3742767540068L);
        System.out.println(date);// Sun Aug 08 09:39:00 CST 2088
    }
    /*
        Date类的空参数构造方法
        Date() 获取当前系统的日期和时间
     */
    private static void demo01() {
        Date date = new Date();
        System.out.println(date);//Sun Aug 08 12:23:03 CST 2088
    }
}

```

### 08_DateFormat类&SimpleDateFormat类介绍

```
java.text.DateFormat:是日期/时间格式化子类的抽象类
    作用:
        格式化（也就是日期 -> 文本）、解析（文本-> 日期）
    成员方法:
        String format(Date date)  按照指定的模式,把Date日期,格式化为符合模式的字符串
        Date parse(String source)  把符合模式的字符串,解析为Date日期
    DateFormat类是一个抽象类,无法直接创建对象使用,可以使用DateFormat类的子类

    java.text.SimpleDateFormat extends DateFormat

    构造方法:
        SimpleDateFormat(String pattern)
          用给定的模式和默认语言环境的日期格式符号构造 SimpleDateFormat。
        参数:
             String pattern:传递指定的模式
        模式:区分大小写的
            y   年
            M   月
            d   日
            H   时
            m   分
            s   秒
        写对应的模式,会把模式替换为对应的日期和时间
            "yyyy-MM-dd HH:mm:ss"
        注意:
            模式中的字母不能更改,连接模式的符号可以改变
             "yyyy年MM月dd日 HH时mm分ss秒"

```

### 09_DateFormat类的format方法和parse方法

```java
packagecom.itheima.demo03.DateFormat;

importjava.text.ParseException;
importjava.text.SimpleDateFormat;
importjava.util.Date;

publicclassDemo01DateFormat{
publicstaticvoidmain(String[]args)throwsParseException{
demo02();
}

/*
使用DateFormat类中的方法parse,把文本解析为日期
使用步骤:
1.创建SimpleDateFormat对象,构造方法中传递指定的模式
2.调用SimpleDateFormat对象中的方法parse,把符合构造方法中模式的字符串,解析为Date日期
注意:
publicDateparse(Stringsource)throwsParseException
parse方法声明了一个异常叫ParseException
如果字符串和构造方法的模式不一样,那么程序就会抛出此异常
调用一个抛出了异常的方法,就必须的处理这个异常,要么throws继续抛出这个异常,要么trycatch自己处理
*/
privatestaticvoiddemo02()throwsParseException{
//1.创建SimpleDateFormat对象,构造方法中传递指定的模式
SimpleDateFormatsdf=newSimpleDateFormat("yyyy年MM月dd日HH时mm分ss秒");
//2.调用SimpleDateFormat对象中的方法parse,把符合构造方法中模式的字符串,解析为Date日期
//Dateparse(Stringsource)把符合模式的字符串,解析为Date日期
Datedate=sdf.parse("2088年08月08日15时51分54秒");
System.out.println(date);
}

/*
使用DateFormat类中的方法format,把日期格式化为文本
使用步骤:
1.创建SimpleDateFormat对象,构造方法中传递指定的模式
2.调用SimpleDateFormat对象中的方法format,按照构造方法中指定的模式,把Date日期格式化为符合模式的字符串(文本)
*/
privatestaticvoiddemo01(){
//1.创建SimpleDateFormat对象,构造方法中传递指定的模式
SimpleDateFormatsdf=newSimpleDateFormat("yyyy年MM月dd日HH时mm分ss秒");
//2.调用SimpleDateFormat对象中的方法format,按照构造方法中指定的模式,把Date日期格式化为符合模式的字符串(文本)
//Stringformat(Datedate)按照指定的模式,把Date日期,格式化为符合模式的字符串
Datedate=newDate();
Stringd=sdf.format(date);
System.out.println(date);//SunAug0815:51:54CST2088
System.out.println(d);//2088年08月08日15时51分54秒
}
}

```

### 10_练习_计算一个人已经出生了多少天

```java
importjava.text.ParseException;
importjava.text.SimpleDateFormat;
importjava.util.Date;
importjava.util.Scanner;

/*
练习:
请使用日期时间相关的API，计算出一个人已经出生了多少天。
分析:
1.使用Scanner类中的方法next,获取出生日期
2.使用DateFormat类中的方法parse,把字符串的出生日期,解析为Date格式的出生日期
3.把Date格式的出生日期转换为毫秒值
4.获取当前的日期,转换为毫秒值
5.使用当前日期的毫秒值-出生日期的毫秒值
6.把毫秒差值转换为天(s/1000/60/60/24)
*/
publicclassDemo02Test{
publicstaticvoidmain(String[]args)throwsParseException{
//1.使用Scanner类中的方法next,获取出生日期
Scannersc=newScanner(System.in);
System.out.println("请输入您的出生日期,格式:yyyy-MM-dd");
StringbirthdayDateString=sc.next();
//2.使用DateFormat类中的方法parse,把字符串的出生日期,解析为Date格式的出生日期
SimpleDateFormatsdf=newSimpleDateFormat("yyyy-MM-dd");
DatebirthdayDate=sdf.parse(birthdayDateString);
//3.把Date格式的出生日期转换为毫秒值
longbirthdayDateTime=birthdayDate.getTime();
//4.获取当前的日期,转换为毫秒值
longtodayTime=newDate().getTime();
//5.使用当前日期的毫秒值-出生日期的毫秒值
longtime=todayTime-birthdayDateTime;
//6.把毫秒差值转换为天(s/1000/60/60/24)
System.out.println(time/1000/60/60/24);
}
}

```

### 11_Calendar类介绍_获取对象的方式

```java
importjava.util.Calendar;

/*
java.util.Calendar类:日历类
Calendar类是一个抽象类,里边提供了很多操作日历字段的方法(YEAR、MONTH、DAY_OF_MONTH、HOUR)
Calendar类无法直接创建对象使用,里边有一个静态方法叫getInstance(),该方法返回了Calendar类的子类对象
staticCalendargetInstance()使用默认时区和语言环境获得一个日历。
*/
publicclassDemo01Calendar{
publicstaticvoidmain(String[]args){
Calendarc=Calendar.getInstance();//多态
System.out.println(c);
}

}

```

### 12_Calendar类的常用成员方法

```java
importjava.util.Calendar;
importjava.util.Date;

/*
Calendar类的常用成员方法:
publicintget(intfield)：返回给定日历字段的值。
publicvoidset(intfield,intvalue)：将给定的日历字段设置为给定值。
publicabstractvoidadd(intfield,intamount)：根据日历的规则，为给定的日历字段添加或减去指定的时间量。
publicDategetTime()：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。
成员方法的参数:
intfield:日历类的字段,可以使用Calendar类的静态成员变量获取
publicstaticfinalintYEAR=1;年
publicstaticfinalintMONTH=2;月
publicstaticfinalintDATE=5;月中的某一天
publicstaticfinalintDAY_OF_MONTH=5;月中的某一天
publicstaticfinalintHOUR=10;时
publicstaticfinalintMINUTE=12;分
publicstaticfinalintSECOND=13;秒
*/
publicclassDemo02Calendar{
publicstaticvoidmain(String[]args){
demo04();
}

/*
publicDategetTime()：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。
把日历对象,转换为日期对象
*/
privatestaticvoiddemo04(){
//使用getInstance方法获取Calendar对象
Calendarc=Calendar.getInstance();

Datedate=c.getTime();
System.out.println(date);
}

/*
publicabstractvoidadd(intfield,intamount)：根据日历的规则，为给定的日历字段添加或减去指定的时间量。
把指定的字段增加/减少指定的值
参数:
intfield:传递指定的日历字段(YEAR,MONTH...)
intamount:增加/减少指定的值
正数:增加
负数:减少
*/
privatestaticvoiddemo03(){
//使用getInstance方法获取Calendar对象
Calendarc=Calendar.getInstance();

//把年增加2年
c.add(Calendar.YEAR,2);
//把月份减少3个月
c.add(Calendar.MONTH,-3);


intyear=c.get(Calendar.YEAR);
System.out.println(year);

intmonth=c.get(Calendar.MONTH);
System.out.println(month);//西方的月份0-11东方:1-12

//intdate=c.get(Calendar.DAY_OF_MONTH);
intdate=c.get(Calendar.DATE);
System.out.println(date);
}

/*
publicvoidset(intfield,intvalue)：将给定的日历字段设置为给定值。
参数:
intfield:传递指定的日历字段(YEAR,MONTH...)
intvalue:给指定字段设置的值
*/
privatestaticvoiddemo02(){
//使用getInstance方法获取Calendar对象
Calendarc=Calendar.getInstance();

//设置年为9999
c.set(Calendar.YEAR,9999);
//设置月为9月
c.set(Calendar.MONTH,9);
//设置日9日
c.set(Calendar.DATE,9);

//同时设置年月日,可以使用set的重载方法
c.set(8888,8,8);

intyear=c.get(Calendar.YEAR);
System.out.println(year);

intmonth=c.get(Calendar.MONTH);
System.out.println(month);//西方的月份0-11东方:1-12

intdate=c.get(Calendar.DATE);
System.out.println(date);
}

/*
publicintget(intfield)：返回给定日历字段的值。
参数:传递指定的日历字段(YEAR,MONTH...)
返回值:日历字段代表的具体的值
*/
privatestaticvoiddemo01(){
//使用getInstance方法获取Calendar对象
Calendarc=Calendar.getInstance();
intyear=c.get(Calendar.YEAR);
System.out.println(year);

intmonth=c.get(Calendar.MONTH);
System.out.println(month);//西方的月份0-11东方:1-12

//intdate=c.get(Calendar.DAY_OF_MONTH);
intdate=c.get(Calendar.DATE);
System.out.println(date);
}
}

```

### 13_1_时间日期相关类总结

![image-20211213134710755](C:/Users/Murphy/Pictures/image-20211213134710755.png)

```java
importjava.text.ParseException;
importjava.text.SimpleDateFormat;
importjava.util.Date;

publicclassTest01{
publicstaticvoidmain(String[]args)throwsParseException{
//空参构造方法
Dated=newDate(3000L);
System.out.println(d.toLocaleString());//1970年1月1日上午8:00:03

//创建日期格式化对象
SimpleDateFormatsdf=newSimpleDateFormat("yyyy年MM月dd日HH:mm:ss");
Stringformat=sdf.format(d);
System.out.println(format);//1970年01月01日08:00:03

Stringstr="2088年08月08日08:08:08";//将字符串格式日期按照格式解析
Dateparse=sdf.parse(str);
System.out.println(parse);

}
}


packagecom.itheima02;

importjava.time.Year;
importjava.util.Calendar;

publicclassTset02{
publicstaticvoidmain(String[]args){
//获取日历类对象
Calendarc=Calendar.getInstance();

//get方法
intyear=c.get(Calendar.YEAR);
System.out.println(year);

intmonth=c.get(Calendar.MONTH);
System.out.println(month+1);

//set方法

c.set(Calendar.YEAR,2088);
year=c.get(Calendar.YEAR);
System.out.println(year);

//add方法
c.add(Calendar.YEAR,2);
year=c.get(Calendar.YEAR);
System.out.println(year);

c.add(Calendar.YEAR,-2);
year=c.get(Calendar.YEAR);
System.out.println(year);
}

```

### 14_System类的常用方法

```java
importjava.util.Arrays;

/*`java.lang.System`类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作，在System类的API文档中，常用的方法有：

-`publicstaticlongcurrentTimeMillis()`：返回以毫秒为单位的当前时间。
-`publicstaticvoidarraycopy(Objectsrc,intsrcPos,Objectdest,intdestPos,intlength)`：将数组中指定的数据拷贝到另一个数组中。*/
publicclassDemo01System{
//publicstaticlongcurrentTimeMillis()`：返回以毫秒为单位的当前时间。
publicstaticvoiddemo01(){
longs=System.currentTimeMillis();
for(inti=0;i<1000;i++){
System.out.println(i);
if(i==999){
System.out.println(i);
}
}
longe=System.currentTimeMillis();
System.out.println("程序共耗时"+(e-s)+"秒！");
}

/*publicstaticvoidarraycopy(Objectsrc,intsrcPos,Objectdest,intdestPos,intlength)`：
将数组中指定的数据拷贝到另一个数组中。
src源数组
srcPos源数组索引起始位置
dest目标数组
destPos目标数组索引起始位置
length复制元素个数
*/

publicstaticvoiddemo02(){
//定义原数组
int[]src={1,2,3,4,5};
//定义目标数组
int[]dest={6,7,8,9,10};
System.out.println("复制前："+Arrays.toString(dest));
//使用arraycopy
System.arraycopy(src,0,dest,0,3);
System.out.println("复制后："+Arrays.toString(dest));
}

publicstaticvoidmain(String[]args){
demo01();
demo02();
}
}
```

### 15_StringBuilder的原理

**![01_StringBuilder的原理](C:/Users/Murphy/Pictures/01_StringBuilder的原理.bmp)

### 16_StringBuilder的构造方法和append方法

```java
/*
java.lang.StringBuilder类:字符串缓冲区,可以提高字符串的效率
构造方法:
StringBuilder()构造一个不带任何字符的字符串生成器，其初始容量为16个字符。
StringBuilder(Stringstr)构造一个字符串生成器，并初始化为指定的字符串内容。
*/
publicclassDemo01StringBuilder{
publicstaticvoidmain(String[]args){
//空参数构造方法
StringBuilderbu1=newStringBuilder();
System.out.println("bu1:"+bu1);//bu1:""

//带字符串的构造方法
StringBuilderbu2=newStringBuilder("abc");
System.out.println("bu2:"+bu2);//bu2:abc
}
}



packagecom.itheima.demo06StringBuilder;
/*
StringBuilder的常用方法:
publicStringBuilderappend(...)：添加任意类型数据的字符串形式，并返回当前对象自身。
*/
publicclassDemo02StringBuilder{
publicstaticvoidmain(String[]args){
//创建StringBuilder对象
StringBuilderbu=newStringBuilder();
//使用append方法往StringBuilder中添加数据
//append方法返回的是this,调用方法的对象bu,this==bu
//StringBuilderbu2=bu.append("abc");//把bu的地址赋值给了bu2
//System.out.println(bu);//"abc"
//System.out.println(bu2);//"abc"
//System.out.println(bu==bu2);//比较的是地址true

//使用append方法无需接收返回值
//bu.append("abc");
//bu.append(1);
//bu.append(true);
//bu.append(8.8);
//bu.append('中');
//System.out.println(bu);//abc1true8.8中

/*
链式编程:方法返回值是一个对象,可以继续调用方法
*/
System.out.println("abc".toUpperCase().toLowerCase().toUpperCase().toLowerCase());
bu.append("abc").append(1).append(true).append(8.8).append('中');
System.out.println(bu);//abc1true8.8中

}
}

```

### 17_1System类&StringBuilder类

![image-20211213135005784](C:/Users/Murphy/Pictures/image-20211213135005784.png)

### 18_StringBuilder的toString方法

```java
/*
StringBuilder和String可以相互转换:
String->StringBuilder:可以使用StringBuilder的构造方法
StringBuilder(Stringstr)构造一个字符串生成器，并初始化为指定的字符串内容。
StringBuilder->String:可以使用StringBuilder中的toString方法
publicStringtoString()：将当前StringBuilder对象转换为String对象。
*/
publicclassDemo03StringBuilder{
publicstaticvoidmain(String[]args){
//String->StringBuilder
Stringstr="hello";
System.out.println("str:"+str);
StringBuilderbu=newStringBuilder(str);
//往StringBuilder中添加数据
bu.append("world");
System.out.println("bu:"+bu);

//StringBuilder->String
Strings=bu.toString();
System.out.println("s:"+s);
}

```

### 19_包装类的概念

| **基本类型** | **对应的包装类（位于java.lang包中）** |
| ------------ | ------------------------------------- |
| byte         | Byte                                  |
| short        | Short                                 |
| int          | **Integer**                           |
| long         | Long                                  |
| float        | Float                                 |
| double       | Double                                |
| char         | **Character**                         |
| boolean      | Boolean                               |

```
包装类：
	基本数据类型的数据，使用起来非常的方便，但是没有对应的方法来操作这些数据,所以我们可以使用一个类，把基本类型的数据包装起来，这个类叫包装类.
	在包装类中可以定义一些方法，用来操作基本类型的数据
```

### 20_包装类_装箱与拆箱

```java
/*
装箱:把基本类型的数据,包装到包装类中(基本类型的数据->包装类)
构造方法:
Integer(intvalue)构造一个新分配的Integer对象，它表示指定的int值。
Integer(Strings)构造一个新分配的Integer对象，它表示String参数所指示的int值。
传递的字符串,必须是基本类型的字符串,否则会抛出异常"100"正确"a"抛异常
静态方法:
staticIntegervalueOf(inti)返回一个表示指定的int值的Integer实例。
staticIntegervalueOf(Strings)返回保存指定的String的值的Integer对象。
拆箱:在包装类中取出基本类型的数据(包装类->基本类型的数据)
成员方法:
intintValue()以int类型返回该Integer的值。
*/
publicclassDemo01Integer{
publicstaticvoidmain(String[]args){
//装箱:把基本类型的数据,包装到包装类中(基本类型的数据->包装类)
//构造方法
Integerin1=newInteger(1);//方法上有横线,说明方法过时了
System.out.println(in1);//1重写了toString方法

Integerin2=newInteger("1");
System.out.println(in2);//1

//静态方法
Integerin3=Integer.valueOf(1);
System.out.println(in3);

//Integerin4=Integer.valueOf("a");//NumberFormatException数字格式化异常
Integerin4=Integer.valueOf("1");
System.out.println(in4);

//拆箱:在包装类中取出基本类型的数据(包装类->基本类型的数据)
inti=in1.intValue();
System.out.println(i);
}
}

```

### 21_包装类_自动装箱与自动拆箱

```java
importjava.util.ArrayList;

/*
自动装箱与自动拆箱:基本类型的数据和包装类之间可以自动的相互转换
JDK1.5之后出现的新特性
*/
publicclassDemo02Ineger{
publicstaticvoidmain(String[]args){
/*
自动装箱:直接把int类型的整数赋值包装类
Integerin=1;就相当于Integerin=newInteger(1);
*/
Integerin=1;

/*
自动拆箱:in是包装类,无法直接参与运算,可以自动转换为基本数据类型,在进行计算
in+2;就相当于in.intVale()+2=3
in=in.intVale()+2=3又是一个自动装箱
*/
in=in+2;

ArrayList<Integer>list=newArrayList<>();
/*
ArrayList集合无法直接存储整数,可以存储Integer包装类
*/
list.add(1);//-->自动装箱list.add(newInteger(1));

inta=list.get(0);//-->自动拆箱list.get(0).intValue();
}

```

### 22_包装类_基本类型与字符串类型之间的相互转换

```java
/*
基本类型与字符串类型之间的相互转换
基本类型->字符串(String)
1.基本类型的值+""最简单的方法(工作中常用)
2.包装类的静态方法toString(参数),不是Object类的toString()重载
staticStringtoString(inti)返回一个表示指定整数的String对象。
3.String类的静态方法valueOf(参数)
staticStringvalueOf(inti)返回int参数的字符串表示形式。
字符串(String)->基本类型
使用包装类的静态方法parseXXX("字符串");
Integer类:staticintparseInt(Strings)
Double类:staticdoubleparseDouble(Strings)
*/
publicclassDemo03Integer{
publicstaticvoidmain(String[]args){
//基本类型->字符串(String)
inti1=100;
Strings1=i1+"";
System.out.println(s1+200);//100200

Strings2=Integer.toString(100);
System.out.println(s2+200);//100200

Strings3=String.valueOf(100);
System.out.println(s3+200);//100200

//字符串(String)->基本类型
inti=Integer.parseInt(s1);
System.out.println(i-10);

inta=Integer.parseInt("a");//NumberFormatException
System.out.println(a);
}
}

```

### 23_包装类总结

![image-20211213135404279](C:/Users/Murphy/Pictures/image-20211213135404279.png)

## 02_Collection、泛型

### 01_Collection集合概述

```
* **集合**：集合是java中提供的一种容器，可以用来存储多个数据。

集合和数组既然都是容器，它们有啥区别呢？

* 数组的长度是固定的。集合的长度是可变的。
* 数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。

```

### 02_集合框架介绍

![01_集合框架介绍](C:/Users/Murphy/Pictures/01_集合框架介绍.bmp)

### 03_Collection集合

![单列集合的体系结构](C:/Users/Murphy/Pictures/单列集合的体系结构.png)

![Collection集合常用方法](C:/Users/Murphy/Pictures/Collection集合常用方法.png)

```java
importjava.util.ArrayList;
importjava.util.Collection;

publicclassTest01{
publicstaticvoidmain(String[]args){
//创建集合对象
Collection<String>collection=newArrayList<>();
//booleanadd(Ee)向集合中添加元素
collection.add("Hello");
collection.add("World");
collection.add("new");
collection.add("java");
System.out.println(collection);

//booleanremove(Ee)删除集合中的某个元素
//booleanresult=collection.remove("Hello");//true
//booleanresult=collection.remove("Hello2");//false
//System.out.println(result);
//System.out.println(collection);

//voidclear()清空集合所以的元素
//collection.clear();
//System.out.println(collection);//[]

//booleancontains(Ee)判断集合中是否包含某个元素
//booleanresult=collection.contains("java");
//booleanresult=collection.contains("java2");//false
//System.out.println(result);//true

//booleanisEmpty();判断集合是否为空
//System.out.println(collection.isEmpty());//false
//collection.clear();
//System.out.println(collection.isEmpty());//true

//intsize();获取集合的长度
System.out.println(collection.size());//4

//Object[]toArray();将集合转成一个数组
Object[]array=collection.toArray();

//遍历数组
for(inti=0;i<array.length;i++){
System.out.println(array[i]);

}
}
}

```

### 04_Iterator接口介绍

```
**迭代**：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。

java.util.Iterator接口:迭代器（对集合进行遍历）
有两个常用的方法
booleanhasNext()如果仍有元素可以迭代，则返回true。
判断集合中还有没有下一个元素，有就返回true，没有就返回false
Enext()返回迭代的下一个元素。
取出集合中的下一个元素
Iterator迭代器是一个接口，我们无法直接使用，需要使用Iterator接口的实现类对象，获取实现类的方法比较特殊
Collection接口中有一个方法叫做Iterator，这个方法返回的就是迭代器的实现类对象
iterator()返回在此collection的元素上进行迭代的迭代器。
迭代器的使用步骤：
1.先使用集合中的方法iterator（）获取迭代器的实现类对象，使用Iterator接口来接受（多态）
2.使用Iterator接口中的方法hasNext判断还有没有下一个元素
3.使用Iterator接口中的方法next取出集合中的下一个元素

```

### 05_迭代器的代码实现

```java
importjava.util.ArrayList;
importjava.util.Iterator;

/*
java.util.Iterator接口:迭代器（对集合进行遍历）
有两个常用的方法
booleanhasNext()如果仍有元素可以迭代，则返回true。
判断集合中还有没有下一个元素，有就返回true，没有就返回false
Enext()返回迭代的下一个元素。
取出集合中的下一个元素
Iterator迭代器是一个接口，我们无法直接使用，需要使用Iterator接口的实现类对象，获取实现类的方法比较特殊
Collection接口中有一个方法叫做Iterator，这个方法返回的就是迭代器的实现类对象
iterator()返回在此collection的元素上进行迭代的迭代器。
迭代器的使用步骤：
1.先使用集合中的方法iterator（）获取迭代器的实现类对象，使用Iterator接口来接受（多态）
2.使用Iterator接口中的方法hasNext判断还有没有下一个元素
3.使用Iterator接口中的方法next取出集合中的下一个元素
*/
publicclassDemo01Iterator{
publicstaticvoidmain(String[]args){
//创建一个集合对象
ArrayList<String>colletion=newArrayList<>();
//往集合中添加元素
colletion.add("姚明");
colletion.add("科比");
colletion.add("麦迪");
colletion.add("詹姆斯");
colletion.add("艾弗森");

/*
1.先使用集合中的方法iterator（）获取迭代器的实现类对象，使用Iterator接口来接受（多态）
注意：
Iterator<e>接口也是有泛型的。迭代器的泛型跟着集合走，集合是什么泛型，迭代器就是什么泛型
*/
//多态接口实现类对象
Iterator<String>it=colletion.iterator();
/*发现使用迭代器取出集合中元素的代码，是一个重返的过程
所以我们可以使用循环优化，
不知道集合中有多少元素，使用while循环
循环结束的有条件，hasNext方法返回false*/
while(it.hasNext()==true){
Stringe=it.next();
System.out.println(e);
}

System.out.println("*************");

for(Iteratorit2=colletion.iterator();it2.hasNext();){
System.out.println(it2.next());
}

/*//2.使用Iterator接口中的方法hasNext判断还有没有下一个元素
booleanb=it.hasNext();
System.out.println(b);//true
//3.使用Iterator接口中的方法next取出集合中的下一个元素
Strings=it.next();
System.out.println(s);//姚明



b=it.hasNext();//没有元素，返回false
s=it.next();//没有元素，再取出元素会抛出NoSuchelementException没有元素异常
System.out.println(s);*/


}

}
```

### 06_迭代器的实现原理

![02_迭代器的实现原理](C:/Users/Murphy/Pictures/02_迭代器的实现原理.bmp)

### 07_增强for循环

```java
importjava.util.ArrayList;

/*
增强for循环：底层使用的也是迭代器，使用for痪的格式，简化了迭代器的书写
是JDK1.5之后出现的新特性
publicinterfaceCollection<E>：所有的单列集合都可以使用增强for
publicinterfaceIterable<T>实现这个接口允许对象成为"foreach"语句的目标。

增强for循环：遍历集合和数组
格式：
for（集合/数组的数据类型 变量名:集合名/数组名）{
sout（变量名）；
}
*/
publicclassDemo02foreach{
publicstaticvoidmain(String[]args){
demo01();
demo02();
}

//使用增强for循环遍历数组
privatestaticvoiddemo01(){
int[]arr={1,2,3,4,5,};
for(inti
:arr){
System.out.println(i);
}
}

//使用增强for循环遍历集合
privatestaticvoiddemo02(){
ArrayList<String>list=newArrayList<>();
list.add("aaa");
list.add("bbb");
list.add("ccc");
list.add("ddd");

for(Strings
:list){
System.out.println(s);

}
}
}

```

### 08_迭代器&增强for总结

```
二、集合的两种遍历方式1.迭代器
	A：通过集合对象获取迭代器对象
	B：使用循环遍历迭代器
	C：判断迭代器对象中是否还有元素
	D：有元素则获取
2.增强for
	for（数据类型变是名：容器对象）{
	//循环体语句;
	}
```

### 09_泛型的概念

![03_泛型的概念](C:/Users/Murphy/Pictures/03_泛型的概念.bmp)

### 10_使用泛型的好处

```java
importjava.util.ArrayList;
importjava.util.Iterator;

publicclassDemo01Generic{
publicstaticvoidmain(String[]args){
//show01();
show02();
}
/*创建集合对象，使用泛型
*好处：
*1.避免了类型转换的麻烦，存储的是什么类型，取出的是什么类型
*2.把运行期异常（代码运行之后会抛出的异常），提升到了编译期（写代码的时候会报错）
*弊端：
*泛型是什么类型，只能存储什么类型的数据
**/
privatestaticvoidshow02(){
ArrayList<String>list=newArrayList<>();
list.add("abc");
//list.add(1);//提示不能输入int
//使用迭代器遍历list集合
Iterator<String>iterator=list.iterator();
while(iterator.hasNext()==true){
Strings=iterator.next();
System.out.println(s+"->"+s.length());//abc->3
}

}
/*
创建集合对象，不使用泛型
好处：
集合不使用泛型，默认的类型就是object类型，可以存储任意类型的数据
弊端：
不安全，会引发异常
*/
/*privatestaticvoidshow01(){
ArrayListlist=newArrayList();
list.add("abc");
list.add(1);

//使用迭代器遍历list
//获取迭代器
Iteratoriterator=list.iterator();
//使用迭代器中的方法叫hasNext和next遍历集合
while(iterator.hasNext()==true){
//取出元素也是Object类型
Objectobj=iterator.next();
System.out.println(obj);

//想要使用String类特有的方法，length获取字符串的长度；不能使用多态Obejectobj="abc";
//需要向下转型
//会抛出ClassCastException类型转换异常；不能把Integer转换为String类型
Strings=(String)obj;
System.out.println(s.length());
}
}*/
}

```

### 11_定义和使用含有泛型的类

```java
/*
定义一个含有泛型的类，模拟Arraylist集合
泛型是一个未知的数据类型，当我们不确定什么数据类型的时候，可以使用泛型
泛型可以接受任意的数据类型，可以是Integer，String，Student
创建对象的时候确定泛型的数据类型
*/
publicclassGenericClass<E>{
privateEname;

publicEgetName(){
returnname;
}

publicvoidsetName(Ename){
this.name=name;
}
}


packagecom.itheima05;

publicclassDemo02GenericClass{
publicstaticvoidmain(String[]args){
//不写泛型默认为Object类型
GenericClassgc=newGenericClass();
gc.setName("只能是字符串");
Objectobject=gc.getName();

//创建GenericClass对象，泛型使用Integer对象
GenericClass<Integer>gc2=newGenericClass<>();
gc2.setName(1);

Integername=gc2.getName();
System.out.println(name);

//创建GenericClass对象，泛型使用String对象
GenericClass<String>gc3=newGenericClass<>();
gc3.setName("小米");
Stringname1=gc3.getName();
System.out.println(name1);
}
}

```

### 12_定义和使用含有泛型的方法

```java
/*
定义含义泛型的方法:泛型定义在方法的修饰符和返回值类型之间
格式：
修饰符<泛型>返回值类型方法名(参数列表（使用泛型）){
方法体；
}
含义泛型的方法，在调用方法的时候确定泛型的数据类型
传递什么类型的参数，泛型就是什么类型
*/
publicclassGenericMethod{
//定义一个含义泛型的方法
public<M>voidmethod01(Mm){
System.out.println(m);
}

//定义一个含有泛型的静态方法
publicstatic<S>voidmethod02(Ss){
System.out.println(s);
}
}

packagecom.itheima05;

publicclassDemo03GenericMethod{
/*
测试含义泛型的方法
*/
publicstaticvoidmain(String[]args){
//创建GenericMethod对象
GenericMethodgm=newGenericMethod();
/*
调用含有泛型的方法method
传递什么类型，泛型就是什么类型
*/
gm.method01(10);
gm.method01("abc");
gm.method01(true);
gm.method01(8.8);

gm.method02("静态方法不建议创建对象使用");

//静态方法，通过类名，方法名（参数）可以直接使用
GenericMethod.method02("静态方法");
GenericMethod.method02(1);
}
}


```

### 13_定义和使用含有泛型的接口

```java
/*
定义含有泛型的接口
*/
publicinterfaceGenericInterface<I>{
publicabstractvoidmethod(Ii);
}


packagecom.itheima05;
/*
含有泛型的接口，第一种使用方式：定义接口的实现类，实现接口，指定接口的泛型
publicinterfaceIterator{
Enext();
}
Scanner实现类Iterator接口并制定接口的泛型为String，所以重写的next方法泛型默认就是String
publicfinalclassscannerimplementsIterator<String>{
publicStringnext(){}
}
*/
publicclassGenericInterfaceImpl1implementsGenericInterface<String>{
@Override
publicvoidmethod(Strings){
System.out.println(s);
}
}


packagecom.itheima05;

importjava.util.ArrayList;

/*
含有泛型的接口，第二种使用方式：接口使用什么泛型，实现类就使用什么泛型，类跟着接口走
就相当于定义了一个含有泛型的类，创建对象的时候确定泛型的类型
publicinterfaceList<E>{
bolleanadd(Ee);
Eget(intindex);
}
publicclassArrayList<E>implementslist<E>{
publicbooleanadd(Ee){}
publicEget(intindex){}
*/
publicclassGenericInterfaceImpl2<I>implementsGenericInterface<I>{

@Override
publicvoidmethod(Ii){
System.out.println(i);
}
}


packagecom.itheima05;
/*
测试含有泛型的接口
*/
publicclassDemo04GenericInterface{
publicstaticvoidmain(String[]args){
//创建GenericInterfaceImpl1对象
GenericInterfaceImpl1gi1=newGenericInterfaceImpl1();
gi1.method("字符串");

//创建GenericInterface2对象
GenericInterfaceImpl2<Integer>gi2=newGenericInterfaceImpl2<>();
gi2.method(10);

GenericInterfaceImpl2<Object>gi3=newGenericInterfaceImpl2<>();
gi3.method(8.8);
}
}

```

### 14_泛型通配符

```java
泛型的通配符:不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。
此时只能接受数据,不能往该集合中存储数据。
packagecom.itheima05;

importjava.util.ArrayList;
importjava.util.Iterator;

/*
泛型的通配符:
?代表任意的数据类型
使用方式：
不能创建对象使用，只能作为方法的参数使用
*/
publicclassDemo05Generic{
publicstaticvoidmain(String[]args){
ArrayList<Integer>list01=newArrayList<>();
list01.add(1);
list01.add(2);

ArrayList<String>list02=newArrayList<>();
list02.add("a");
list02.add("b");

printArray(list01);
printArray(list02);

//ArrayList<?>list03=newArrayList<?>();
}

/*
定义一个方法，能遍历所有类型的ArrayList集合
这时候我们不知道ArrayList集合使用什么数据类型，可以使用泛型的通配符？来接收数据
*/
publicstaticvoidprintArray(ArrayList<?>list){
for(Objecti:
list){
System.out.println(i);
}
/*Iterator<?>it=list.iterator();
while(it.hasNext()){
//it.next()取出的元素是Object类型，可以接收任意数据类型
Objecto=it.next();
System.out.println(o);
}*/
}
}

通配符高级使用----受限泛型

packagecom.itheima05;

importjava.util.ArrayList;
importjava.util.Collection;

/*
泛型的上限限定：？extendsE代表使用的泛型只能是E类型的子类/本身
泛型的下限限定：？superE代表使用的泛型只能是E类型的父类/本身
*/
publicclassDemo06Generic{
publicstaticvoidmain(String[]args){
Collection<Integer>list1=newArrayList<Integer>();
Collection<String>list2=newArrayList<String>();
Collection<Number>list3=newArrayList<Number>();
Collection<Object>list4=newArrayList<Object>();

getElement1(list1);
getElement1(list2);//报错
getElement1(list3);
getElement1(list4);//报错

getElement2(list1);//报错
getElement2(list2);//报错
getElement2(list3);
getElement2(list4);

/*
类与类之间的继承关系
IntegerextendsNumberextendsObject
StringextnedsObject
*/
}
//泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类
publicstaticvoidgetElement1(Collection<?extendsNumber>coll){}
//泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类
publicstaticvoidgetElement2(Collection<?superNumber>coll){}
}

```

### 15_泛型的使用总结

```
1.泛型类和泛型方法
	类名<泛型>
	方法名（泛型）
2.泛型接口和泛型方法
	接口名<泛型>
	方法名（泛型）
3.泛型通配符
```

### 16_斗地主案例的需求分析

![04_斗地主案例的需求分析](C:/Users/Murphy/Pictures/04_斗地主案例的需求分析.bmp)

### 17_斗地主案例的代码实现

```java
importjava.util.ArrayList;
importjava.util.Collection;
importjava.util.Collections;

/*
斗地主综合案例
1.准备牌
2.洗牌
3.发牌
4.看牌
*/
publicclassDouDiZhu{
publicstaticvoidmain(String[]args){
//准备牌
//定义一个存储54张牌的ArrayList集合，泛型使用String
ArrayList<String>poker=newArrayList<>();

//定义两个数组，一个数组存储牌的花色，一个数组存储牌的序号
String[]colors={"♠","♥","♣","♦"};
String[]numbers={"2","A","K","Q","J","10","9","8","7","6","5","4","3"};

//先把大王和小王存储到poker集合中
poker.add("大王");
poker.add("小王");

//循环嵌套遍历两个数组，组装52张牌
for(Stringnumber:
numbers){
for(Stringcolor:colors){
//System.out.println(color+number);
//把组装好的牌存储到poker中
poker.add(color+number);
}
}
//System.out.println(poker);
/*
2.洗牌
使用集合的工具类Collections中的方法
*/
Collections.shuffle(poker);
//System.out.println(poker);
/*
3.发牌
*/
//定义4个集合，存储玩家的牌和底牌
ArrayList<String>player01=newArrayList<>();
ArrayList<String>player02=newArrayList<>();
ArrayList<String>player03=newArrayList<>();
ArrayList<String>dipai=newArrayList<>();

/*遍历poker集合获取每一张牌
使用poker集合的索引给三个玩家轮流发牌
剩余3张牌给底牌
注意：
先判断底牌（i>=51），否则牌就发没了
*/
for(inti=0;i<poker.size();i++){
//获取每一张牌
Stringp=poker.get(i);
//轮流发牌
if(i>=51){
dipai.add(p);
}elseif(i%3==0){
player01.add(p);
}elseif(i%3==1){
player02.add(p);
}elseif(i%3==2){
player03.add(p);
}
}

//4.看牌
System.out.println("刘德华"+player01);
System.out.println("周润发"+player02);
System.out.println("周星驰"+player03);
System.out.println("刘德华"+dipai);
}
}

```



















## 03_List、Set、数据结构、Collections

### 01_数据结构_栈

### 02_数据结构_队列

![01_数据结构_栈&队列](C:/Users/Murphy/Pictures/01_数据结构_栈&队列-16392341954232.bmp)



### 03_数据结构_数组

![02_数据结构_数组](C:/Users/Murphy/Pictures/02_数据结构_数组-16392342098593.bmp)

### 04_数据结构_链表

![03_数据结构_链表](C:/Users/Murphy/Pictures/03_数据结构_链表-16392342199274.bmp)

### 05_数据结构_红黑树

![04_数据结构_红黑树](C:/Users/Murphy/Pictures/04_数据结构_红黑树-16392342293455.bmp)

### 06_List集合_介绍&常用方法

```java
package com.itheima06.demo01.List;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

/*
    java.util.list接口extends Collection接口
    list接口的特点:
        1.有序的集合，存储元素和取出元素的顺序是一致的（存取123取出123）
        2.有索引，包含了一些带索引的方法
        3.允许存储重复的元素
    list接口中带有索引的放发（特有）
        - `public void add(int index, E element)`: 将指定的元素，添加到该集合中的指定位置上。
        - `public E get(int index)`:返回集合中指定位置的元素。
        - `public E remove(int index)`: 移除列表中指定位置的元素, 返回的是被移除的元素。
        - `public E set(int index, E element)`:用指定元素替换集合中指定位置的元素,返回值的更新前的元素。
        注意：操作索引的时候，一定要防止索引越界异常
        IndexOutOfBoundsException:索引越界异常，集合会报
        ArrayIndexOutOfBoundsException:数组索引越界异常
        StringIndexOutOfBoundsException:字符串索引越界异常
*/
public class Demo01List {
    public static void main(String[] args) {
        //床建一个list集合对象，多态
        List<String> list = new ArrayList<>();

        //使用add方法往集合中添加元素
        list.add("a");
        list.add("b");
        list.add("c");
        list.add("d");
        list.add("a");

        //打印集合
        System.out.println(list);//[a, b, c, d, a]不是地址重写了toString

        //public void add(int index, E element)`: 将指定的元素，添加到该集合中的指定位置上。
        //在c和d之间添加123
        list.add(3,"123");
        System.out.println(list);

        //public E remove(int index)`: 移除列表中指定位置的元素, 返回的是被移除的元素。
        //移除c元素
        String removeE = list.remove(2);
        System.out.println("被移除的元素" + removeE);
        System.out.println(list);//[a, b, 123, d, a]

        //public E set(int index, E element)`:用指定元素替换集合中指定位置的元素,返回值的更新前的元素。
        //把最后一个a替换为A
        String setE = list.set(4, "A");
        System.out.println("被替换的元素" + setE);
        System.out.println(list);//[a, b, 123, d, A]

        //public E get(int index)`:返回集合中指定位置的元素。
        //list遍历有三种方式
        //使用普通的for循环
        for (int i = 0; i < list.size(); i++) {
            System.out.println(list.get(i));
        }

        System.out.println("***************");
        //使用迭代器
        Iterator<String> it = list.iterator();
        while (it.hasNext()){
            String s = it.next();
            System.out.println(s);
        }
        System.out.println("***************");
        //使用foreach
        for (String s : list) {
            System.out.println(s);
        }

        String s = list.get(5);
        System.out.println(s);
    }
}

```

### 07_Arraylist集合

list集合的第一个实现类

底层是数组结构，特点：查询快，增删慢

适合查询少，增删多的

### 08_LinkedList集合

list集合的第二个实现类

`List` 接口的链接列表实现。特点：查询慢，增删快

```java
package com.itheima06.demo01.List;

import java.util.LinkedList;

/*
    java.util.LinkedList集合 implements List接口
    LinkedList集合的特点“
        1.底层是一个链表结构：查询慢，增删快
        2.里边包含了大量操作首尾元素的方法
        注意：使用LinkedList集合特有的方法，不能使用多态

        * `public void addFirst(E e)`:将指定元素插入此列表的开头。
       * `public void addLast(E e)`:将指定元素添加到此列表的结尾。
       * `public void push(E e)`:将元素推入此列表所表示的堆栈。

       * `public E getFirst()`:返回此列表的第一个元素。
        * `public E getLast()`:返回此列表的最后一个元素。

        * `public E removeFirst()`:移除并返回此列表的第一个元素。
        * `public E removeLast()`:移除并返回此列表的最后一个元素。
        * `public E pop()`:从此列表所表示的堆栈处弹出一个元素。

      * `public boolean isEmpty()`：如果列表不包含元素，则返回true。
*/
public class Demo02LinkedList {
    public static void main(String[] args) {
        //show01();
        // show02();
        show03();
    }

    /*
     * `public E removeFirst()`:移除并返回此列表的第一个元素。
     * `public E removeLast()`:移除并返回此列表的最后一个元素。
     * `public E pop()`:从此列表所表示的堆栈处弹出一个元素。相当于remoFirst
     */
    private static void show03() {
        //创建linkedlist集合对象
        LinkedList<String> linkedList = new LinkedList<>();
        //使用add方法往集合中添加元素
        linkedList.add("a");
        linkedList.add("b");
        linkedList.add("c");
        System.out.println(linkedList);//[a, b, c]

        //String removeFirst = linkedList.removeFirst();
        String pop = linkedList.pop();
        System.out.println("被移除的第一个元素" + pop);

        String removeLast = linkedList.removeLast();
        System.out.println("被移除的最后一个元素" + removeLast);

        System.out.println(linkedList);//[b]
    }

    /*        * `public E getFirst()`:返回此列表的第一个元素。
     * `public E getLast()`:返回此列表的最后一个元素。
     */
    private static void show02() {
        //创建linkedlist集合对象
        LinkedList<String> linkedList = new LinkedList<>();
        //使用add方法往集合中添加元素
        linkedList.add("a");
        linkedList.add("b");
        linkedList.add("c");
        System.out.println(linkedList);

        //linkedList.clear();//清空集合中的元素，再获取集合中的元素会抛出NoSuchElementException

        if (linkedList.isEmpty()){
            String first = linkedList.getFirst();
            System.out.println(first);//a

            String last = linkedList.getLast();
            System.out.println(last);//c
        }
    }

    /*    * `public void addFirst(E e)`:将指定元素插入此列表的开头。
    * `public void addLast(E e)`:将指定元素添加到此列表的结尾。
    * `public void push(E e)`:将元素推入此列表所表示的堆栈。此方法等效于 addFirst(E)。
 */
    private static void show01() {
        //创建linkedlist集合对象
        LinkedList<String> linkedList = new LinkedList<>();
        //使用add方法往集合中添加元素
        linkedList.add("a");
        linkedList.add("b");
        linkedList.add("c");
        System.out.println(linkedList);

        //linkedList.addFirst("www");
        linkedList.push("www");
        System.out.println(linkedList);//[www, a, b, c]

        //public void addLast(E e)`:将指定元素添加到此列表的结尾。此方法等效于add()
        //linkedList.addLast("com");
        System.out.println(linkedList);//[www, a, b, c, com]
    }
}
```

### 09_Vector集合

`Vector` 类可以实现可增长的对象数组。

与新 collection 实现不同，`Vector` 是同步的。

1.0版本最早的集合，单线程

set接口

### 10_HashSet集合介绍

```java
package com.itheima06.demo02.Set;

import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

/*
    java.util.Set接口 extends Colletions接口
    Set接口的特点：
        1.不允许存储重复的元素
        2.没有索引，没有带索引的方法，也不能使用普通的for循环遍历
    java.util.HashSet集合 implements Set接口
    HashSet特点：
        1.不允许存储重复的元素
        2.没有索引，没有带索引的方法，也不能使用普通的for循环遍历
        3.是一个无序的集合，存储元素和取出元素的顺序有可能不一致
        4.底层是一个哈希表结构（查询的速度非常的快）
*/
public class Demo01Set {
    public static void main(String[] args){
        Set<Integer> set = new HashSet<>();
        //使用add方法往集合中添加元素
        set.add(1);
        set.add(2);
        set.add(3);
        //set.add(1);//不允许存储重复的元素

        //使用迭代器遍历set集合
        Iterator<Integer> iterator = set.iterator();
        while (iterator.hasNext()){
            System.out.println(iterator.next());
        }

        System.out.println("**********");
        //使用增强for
        for (Integer integer : set) {
            System.out.println(integer);
        }
    }
}
```

### 11_哈希值

```java
package com.itheima06.demo03.hashCode;
/*
    哈希值：是一个十进制的整数，由系统随机给出（就是对象的地址值，是一个逻辑地址，是模拟出来得到地址，不是数据实际存储的物理地址）
    在Object类有一个方法，可以获取对象的哈希值
    hashCode()
        返回该对象的哈希码值。
    hashCode方法的源码：
        public native int hashCode();
        native：代表该方法调用的是本地操作系统的方法
*/
public class Demo01HashCode {
    public static void main(String[] args) {
        //Person类继承了Object类，所以可以使用Object类的hashCode方法
        Person p1 = new Person();
        int h1 = p1.hashCode();
        System.out.println(h1);

        Person p2 = new Person();
        int h2 = p2.hashCode();
        System.out.println(h2);

/*
        toString方法的源码
             return getClass().getName() + "@" + Integer.toHexString(hashCode());
*/
        System.out.println(p1);
        System.out.println(p2);
        System.out.println(p1==p2);//false

/*
        String类的哈希值
            String类重写Object类的hashCode方法
*/
        String s1 = new String("abc");
        String s2 = new String("abc");
        System.out.println(s1.hashCode());//96354
        System.out.println(s2.hashCode());//96354

        System.out.println("重地".hashCode());
        System.out.println("通话".hashCode());
    }
}

```

```java
package com.itheima06.demo03.hashCode;

public class Person extends Object{
    //重写hashCode方法

    @Override
    public int hashCode() {
        return 1;
    }
}

```

### 12_HashSet集合存储数据的结构（哈希表）

![05_HashSet集合存储数据的结构（哈希表）](C:/Users/Murphy/Pictures/05_HashSet集合存储数据的结构（哈希表）.bmp)

### 13_Set集合存储元素不重复的原理

![06_Set集合存储元素不重复的原理](C:/Users/Murphy/Pictures/06_Set集合存储元素不重复的原理.bmp)

### 14_HashSet存储自定义类型元素

重写hashcode和equals

```java
package com.itheima06.demo03.hashCode;

import java.util.Objects;

public class Person {
    private String name;
    private int age;

    public Person() {
    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Person person = (Person) o;
        return age == person.age &&
                Objects.equals(name, person.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}

```

```java
package com.itheima06.demo03.hashCode;

import java.util.HashSet;

/*
    HashSet存储自定义类型元素

    set集合保证元素唯一：
        存储的元素（String，Integer，...），必须重写hashcode方法和equals方法

    要求：
        同名同年龄的人只能存储一次
*/
public class Demo03HashSetSaveperson {
    public static void main(String[] args){
        //创建一个HashSet集合存储Person
        HashSet<Person> set = new HashSet<>();
        Person p1 = new Person("小美女",18);
        Person p2 = new Person("小美女",18);
        Person p3 = new Person("小美女",19);
        System.out.println(p1.hashCode());
        System.out.println(p2.hashCode());

        System.out.println(p1==p2);
        System.out.println(p1.equals(p2));
        set.add(p1);
        set.add(p2);
        set.add(p3);
        System.out.println(set);//[Person{name='小美女', age=19}, Person{name='小美女', age=18}, Person{name='小美女', age=18}]

    }
}

```

### 15_LinkedHashSet集合

具有可预知迭代顺序的 `Set` 接口的哈希表和链接列表实现。此实现与 `HashSet`  的不同之外在于，后者维护着一个运行于所有条目的双重链接列表。

```java
package com.itheima06.demo03.hashCode;

import java.util.HashSet;
import java.util.LinkedHashSet;

/*
    java.util.LinkedHashSet 集合 entends HashSet集合
    LinkedHashSet 集合特点：
        底层是一个Hash表（数组+链表/红黑树）+链表：多了一条链表（用来记录元素的存储顺序），保证元素有序
 */
public class Demo04LinkedHashSet {
    public static void main(String[] args) {
        HashSet<String> set = new HashSet<>();
        set.add("www");
        set.add("abc");
        set.add("abc");
        set.add("com");
        System.out.println(set);//[com, abc, www]无序，不允许重复

        LinkedHashSet<String> linked = new LinkedHashSet<>();
        linked.add("www");
        linked.add("abc");
        linked.add("abc");
        linked.add("com");
        System.out.println(linked);//[www, abc, com]有序，不允许重复


    }
}

```

### 16_可变参数

```java
package com.itheima06.demo04.VarArgs;
/*
    可变参数是jdk1.5之后出现的新特性
    使用前提：
        当方法的参数列表数据类型已经确定，但是参数的个数不确定，就可以使用可变参数。
    使用格式：定义方法时使用
        修饰符 返回值类型 方法名(数据类型...变量名){}
    可变参数的原理：
        可变参数底层就是一个数组，根据传递参数个数不同，会创建不同长度的数组，来存储这些参数
        传递的参数个数，可以是0个（不传递），1个2个...多个
*/
public class Demo01VarArgs {
    public static void main(String[] args){
        //int i = add(10);
        //int i = add(10,20,30,40,50,60,70,80,100);
        int i = add(10,20);
        System.out.println(i);

        method("abc",5.5,10,1,2,3,4);
    }

/*
    可变参数的注意事项
        1.一个方法的参数列表，只能有一个可变参数
        2.如果方法的参数有多个，那么可变参数必须写在参数列表的末尾
*/
    //public static void method(int...a,String...b){}    //1不行

    //public static void method(String b,double c,int d,int...a){}    //2行


    //可变参数的特殊写法（终极）写法
    public static void method(Object...objects){}


    /*定义计算(0-n)个整数和的方法
    已知：计算整数的和，数据类型已经确定int
    但是参数的个数不确定，不知道要计算几个整数的和，就可以使用可变参数
    add();就会创建一个长度为0的数组，new int[]{10}
    */
    public static int add(int...arr){
        //System.out.println(arr);// [I@50cbc42f 底层是一个数组
        //System.out.println(arr.length);//1
        //定义一个初始化的变量，记录累加求和
        int sum = 0;
        //遍历数组，获取数组中的每一个元素
        for (int i : arr) {
            //累加求和
            sum +=i;
        }
        //把求和结果返回
        return sum;
    }
}

```

### 17_Collections集合工具类的方法_addAll&shuffle

```java
package com.itheima06.demo05.Collections;

import java.util.ArrayList;
import java.util.Collections;

/*
    * `java.utils.Collections`是集合工具类，用来对集合进行操作。部分方法如下：
         - `public static <T> boolean addAll(Collection<T> c, T... elements):往集合中添加一些元素。
         - `public static void shuffle(List<?> list) 打乱顺序`:打乱集合顺序。
*/
public class Demo01Collections {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        /*list.add("a");
        list.add("b");
        list.add("c");
        list.add("d");
        list.add("e");*/

//      addAll(Collection<T> c, T... elements):往集合中添加一些元素。
        Collections.addAll(list,"a","b","c","d","e");
        System.out.println(list);//[a, b, c, d, e]1

//        shuffle(List<?> list) 打乱顺序`:打乱集合顺序
        Collections.shuffle(list);
        System.out.println(list);//[d, a, c, e, b],[b, e, a, d, c]
    }
}
```

### 18_Collections集合工具类的方法_sort(List)

```java
package com.itheima06.demo05.Collections;

public class Person implements Comparable<Person>{
    private String name;
    private int age;

    public Person() {
    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
    //重写排序的规则
    @Override
    public int compareTo(Person o) {
        //return 0;//认为元素都是相同的
        //自定义比较的规则，比较两个人的年龄（this，参数Person）
        return this.getAge()-o.getAge();//年龄升序排序
    }
}

```

```java
package com.itheima06.demo05.Collections;

import java.util.ArrayList;
import java.util.Collections;

/*
    - `public static <T> void sort(List<T> list)`:将集合中元素按照默认规则排序。
    - `public static <T> void sort(List<T> list，Comparator<? super T> )`:将集合中元素按照指定规则排序。
    注意：
        sort(List<T> list)使用前提
        被排序的集合里面存储的元素，必须实现Comparable，重写接口中的方法compareTo定义排序的规则
    Comparable接口的排序规则：
        自己（this）-参数：升序

*/
public class Demo02Sort {
    public static void main(String[] args) {
        ArrayList<Integer> list01 = new ArrayList<>();
        list01.add(1);
        list01.add(3);
        list01.add(2);

        System.out.println(list01);//[1, 3, 2]

        //sort(List<T> list)`:将集合中元素按照默认规则排序。
        Collections.sort(list01);//默认是升序

        System.out.println(list01);//[1, 2, 3]

        ArrayList<String> list02 = new ArrayList<>();
        list02.add("a");
        list02.add("c");
        list02.add("b");

        System.out.println(list02);//[a, c, b]

        Collections.sort(list02);

        System.out.println(list02);//[a, b, c]

        ArrayList<Person> list03 = new ArrayList<>();
        list03.add(new Person("张三",18));
        list03.add(new Person("李四",20));
        list03.add(new Person("王五",15));

        System.out.println(list03);

        Collections.sort(list03);
        System.out.println(list03);//[Person{name='王五', age=15}, Person{name='张三', age=18}, Person{name='李四', age=20}]

    }
}

```

### 19_Collections集合工具类的方法_sort(List,Comparator)

```java
package com.itheima06.demo05.Collections;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

/*
    `public static <T> void sort(List<T> list，Comparator<? super T> )`:将集合中元素按照指定规则排序。
    Comparator和Comparable的区别
        Comparable：自己（this）和别人（参数）比较，自己需要实现Comparable接口，重写比较的规则compare方法
        Comparator：相当于找一个第三方的裁判，比较两个

        Comparator的排序规则：
        o1-o2 升序
        o2-o1 降序
*/
public class Demo03Sort {
    public static void main(String[] args) {
        ArrayList<Integer> list01 = new ArrayList<>();
        list01.add(1);
        list01.add(3);
        list01.add(2);
        System.out.println(list01);//[1, 3, 2]

        Collections.sort(list01, new Comparator<Integer>() {
            //重写比较的规则
            @Override
            public int compare(Integer o1, Integer o2) {
                //return o1-o2;//升序[1, 2, 3]
                return o2-o1;//降序[3, 2, 1]
            }
        });
        System.out.println(list01);

        ArrayList<Student> list02 = new ArrayList<>();
        list02.add(new Student("a迪丽热巴",18));
        list02.add(new Student("古力娜扎",20));
        list02.add(new Student("杨幂",17));
        list02.add(new Student("b杨幂",18));
        /*Collections.sort(list02, new Comparator<Student>() {
            @Override
            public int compare(Student o1, Student o2) {
                //按照年龄升序排序
                return o1.getAge()-o2.getAge();
            }
        });*/
        //扩展：了解
        Collections.sort(list02, new Comparator<Student>() {
            @Override
            public int compare(Student o1, Student o2) {
                //按照年龄升序排序
                int result= o1.getAge()-o2.getAge();
                //如果两个人年龄相同，再使用姓名的第一个字比较
                if (result==0){
                    result = o1.getName().charAt(0)-o2.getName().charAt(0);
                }//[Student{name='杨幂', age=17}, Student{name='a迪丽热巴', age=18}, Student{name='b杨幂', age=18}, Student{name='古力娜扎', age=20}]
                return result;
            }
        });

        System.out.println(list02);//[Student{name='杨幂', age=17}, Student{name='迪丽热巴', age=18}, Student{name='古力娜扎', age=20}]
    }
}

```

## 04_Map，斗地主案例

### 01_Map集合概述

**java.util  接口 Map<K,V>**

- 

- **类型参数：**

  `K` - 此映射所维护的键的类型

  `V` - 映射值的类型

  将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。 ![Collection与Map](C:/Users/Murphy/Pictures/Collection与Map.bmp)

### 02_Map常用子类

03_Map接口中的常用方法

```java
package com.itheima07.demo01.Map;

import java.util.HashMap;
import java.util.Map;

/*
    java.util.Map<k,v>集合
    Map的特点：
        1.Map集合是一个双列集合，一个元素包含两个值（一个key，一个value）
        2.Map集合中的元素，key和value的数据类型可以相同，也可以不同
        3.Map集合中的元素，key是不允许重复的，value是可以重复的
        4.Map集合中的元素，key和value是一一对应
    java.util.HashMap<k,v>集合implements Map<k,v>接口
    HashMap集合的特点
        1.HashMap集合底层是哈希表：查询速度特别快
            jdk1.8之前：数组+单向链表
            jdk1.8之后：数组+单向链表/红黑树（链表的长度超过8）：提高查询的速度
        2.HashMap集合是一个无需的集合，存储元素和取出元素的顺序有可能不一致
    java.util.linkedHashMap<k,v> 集合extends HashMap<k,v>集合
    linkedHashMap的特点：
        1.linkedHashMap集合底层是哈希表+链表（保证迭代的顺序）
        2.linkedHashMap集合是一个有序的集合，存储元素和取出元素的顺序是一致的
 */
public class Demo01Map {
    public static void main(String[] args){
        //show01();
        //show02();
        //show03();
        show04();
    }
    /*
        `boolean containsKey(Object key)  ` 判断集合中是否包含指定的键。
         包含返回true，不包含返回false
     */
    private static void show04() {
        HashMap<String, Integer> map = new HashMap<>();
        map.put("赵丽颖",168);
        map.put("杨颖",165);
        map.put("林志玲",178);

        boolean b1 = map.containsKey("赵丽颖");
        System.out.println("b1:" + b1);//b1:true

        boolean b2 = map.containsKey("赵颖");
        System.out.println("b2:" + b2);//b2:false
    }

    /*
        `public V get(Object key)` 根据指定的键，在Map集合中获取对应的值。
        返回值v
                key存在，v返回对应的value值
                key不存在，v返回null
     */
    private static void show03() {
        //创建Map集合
        HashMap<String, Integer> map = new HashMap<>();
        map.put("赵丽颖",168);
        map.put("杨颖",165);
        map.put("林志玲",178);

        Integer v1 = map.get("杨颖");
        System.out.println("v1:" + v1);//v1:165 返回对应的value值

        Integer v2 = map.get("迪丽热巴");
        System.out.println("v2:" + v2);//v2:null 返回null
    }

    /*
        `public V remove(Object key)`: 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。
            返回值v
                key存在，v返回被删除的值
                key不存在，v返回null
     */
    private static void show02() {
        //创建Map集合
        HashMap<String, Integer> map = new HashMap<>();
        map.put("赵丽颖",168);
        map.put("杨颖",165);
        map.put("林志玲",178);
        System.out.println(map);

        Integer v1 = map.remove("林志玲");
        System.out.println("v1:" + v1);//v1:178 返回被删除的值
        System.out.println(map);//{赵丽颖=168, 杨颖=165}

        Integer v2 = map.remove("林志颖");
        System.out.println("v2:" + v2);//v2:null 返回null
    }

    /*
        `public V put(K key, V value)`:  把指定的键与指定的值添加到Map集合中。
        返回值：v
            存储键值对的时候，key不重复，返回值v是null
            存储键值对的时候，key重复，会使用新的value替换map中重复的value，返回被替换的value
    
    */
    private static void show01() {
        //创建Map集合对象，多态
        Map<String, String> map = new HashMap<>();

        Object v1 = map.put("李晨", "范冰冰1");
        System.out.println("v1:" + v1);

        Object v2 = map.put("李晨", "范冰冰2");
        System.out.println("v2:" + v2);//范冰冰1  返回被替换的value
        System.out.println(map);//{李晨=范冰冰2}

        map.put("冷锋","龙小云");
        map.put("杨过","小龙女");
        map.put("尹志平","小龙女");
        System.out.println(map);//{杨过=小龙女, 尹志平=小龙女, 李晨=范冰冰2, 冷锋=龙小云}
    }
}

```

### 04_Map集合遍历键找值方式

![01_Map集合遍历键找值方式](C:/Users/Murphy/Pictures/01_Map集合遍历键找值方式.bmp)

`public Set<K> keySet()`: 获取Map集合中所有的键，存储到Set集合中。

```java
package com.itheima07.demo01.Map;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Set;

/*
    Map集合的第一种遍历方式：通过键找值的方式
    Map集合中的方法：
        Set<k>keySet()返回映射中包含键的Set视图。
    实现步骤：
        1.使用Map集合中的方法keySet(),把Map集合中所有的key取出来，存储到一个集合中
        2.遍历set集合，获取Map集合中的每一个key
        3.通过Map集合中的方法get（key），通过key找到value
 */
public class Demo02KeySet {
    public static void main(String[] args) {


        HashMap<String, Integer> map = new HashMap<>();
        map.put("赵丽颖",168);
        map.put("杨颖",165);
        map.put("林志玲",178);

        //1.使用Map集合中的方法keySet(),把Map集合中所有的key取出来，存储到一个集合中
        Set<String> set = map.keySet();

        //2.遍历set集合，获取Map集合中的每一个key
        //使用迭代器遍历Set集合
        Iterator<String> it = set.iterator();
        while (it.hasNext()){
            String key = it.next();
            //3.通过Map集合中的方法get（key），通过key找到value
            Integer value = map.get(key);
            System.out.println(key+"="+value);
        }

        System.out.println("+++++++++++++++++++++++++++++++++ ");
        for (String s : set) {
            //3.通过Map集合中的方法get（key），通过key找到value
            Integer value = map.get(s);
            System.out.println(s+"="+value);
        }
        System.out.println("+++++++++++++++++++++++++++++++++ ");
        for (String s : map.keySet()) {
            //简化版
            System.out.println(s+"="+map.get(s));
        }
    }
}

```

### 05_Entry键值对对象

![02_Map集合遍历键值对方式](C:/Users/Murphy/Pictures/02_Map集合遍历键值对方式.bmp)

`public Set<Map.Entry<K,V>> entrySet()`: 获取到Map集合中所有的键值对对象的集合(Set集合)。

### 06_Map集合遍历键值对方式

```java
package com.itheima07.demo01.Map;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

/*
    Map集合遍历的第二种方式：使用Entry对象遍历

    Map集合中的方法
        `public Set<Map.Entry<K,V>> entrySet()`: 方返回此映射中包含的映射关系的set视图。
        实现步骤：
            1.使用Map集合中的方法entrySet（），把Map集合中多个Entry对象取出来，存储到一个集合中
            2.遍历Set集合，获取每一个entry对象
            3.使用entry对象中的方法getKey（）和getValue获取键与值
 */
public class Demo03EntrySet {
    public static void main(String[] args) {
        HashMap<String, Integer> map = new HashMap<>();
        map.put("赵丽颖",168);
        map.put("杨颖",165);
        map.put("林志玲",178);

        //1.使用Map集合中的方法entrySet（），把Map集合中多个Entry对象取出来，存储到一个集合中
        Set<Map.Entry<String, Integer>> set = map.entrySet();

        //2.遍历Set集合，获取每一个entry对象
        //使用迭代器遍历Set集合
        Iterator<Map.Entry<String, Integer>> it = set.iterator();
        while (it.hasNext()){
            Map.Entry<String, Integer> entry = it.next();
            //3.使用entry对象中的方法getKey（）和getValue获取键与值
            String key = entry.getKey();
            Integer value = entry.getValue();
            System.out.println(key+"="+value);
        }
        System.out.println("++++++++++++++++++++++++++++++");
        for (Map.Entry<String, Integer> entry : set) {
            String key = entry.getKey();
            Integer value = entry.getValue();
            System.out.println(key+"="+value);

        }
    }
}

```

### 07_HashMap存储自定义类型键值

```java
package com.itheima07.demo02.Map;

import java.util.Objects;

public class Person {
    private String name;
    private int age;

    public Person() {
    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Person person = (Person) o;
        return age == person.age &&
                Objects.equals(name, person.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}

```

```java
package com.itheima07.demo02.Map;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;

/*
    HashMap存储定义类型键值
    Map集合保证key是唯一的：
        作为key的元素，必须重写hashCode方法和equals方法以保证key唯一
 */
public class Demo01HashMapSavePerson {
    public static void main(String[] args){
        //show01();
        show02();
    }

    /*
        HashMap存储自定义类型键值
        key：Person类型
            Person类就必须重写hashCode和equals方法，保证key唯一
        value:String类型
            可以重复
     */
    private static void show02() {
        //创建HashMap集合
        HashMap<Person, String> map = new HashMap<>();
        //往集合中添加元素
        map.put(new Person("女王",18),"英国");
        map.put(new Person("秦始皇",18),"秦国");
        map.put(new Person("普京",18),"俄国");
        map.put(new Person("女王",18),"毛里求斯");
        //使用entrySet和增强for遍历map集合
        Set<Map.Entry<Person, String>> set = map.entrySet();
        for (Map.Entry<Person, String> entry : set) {
            Person key = entry.getKey();
            String value = entry.getValue();
            System.out.println(key+"="+value);//重写hashCode和equas方法后，女王只有一个
        }
    }

    /*
        HashMap存储自定义类型键值
        key：String类型
            String类重写hashCode方法和equals方法以保证key唯一
        value:Person类型
            value可以重复（同名同年龄的人视为同一个）
     */
    private static void show01() {
        //创建HashMap集合
        HashMap<String, Person> map = new HashMap<>();
        //往集合中添加元素
        map.put("北京",new Person("张三",18));
        map.put("上海",new Person("李四",19));
        map.put("广州",new Person("王五",20));
        map.put("北京",new Person("赵六",18));
        //使用keySet加增强for遍历map集合
        for (String key : map.keySet()) {
            System.out.println(key+"="+map.get(key));
        }
    }
}

```

### 08_LinkedHashMap集合

```java
package com.itheima07.demo03.Map;

import java.util.HashMap;
import java.util.LinkedHashMap;

/*
    public class LinkedHashMap<K,V>extends HashMap<K,V>
    Map 接口的哈希表和链接列表实现，具有可预知的迭代顺序。
    底层原理：
        哈希表+链表（记录元素的顺序）
 */
public class Demo01LinkedHashMap {
    public static void main(String[] args) {
        HashMap<String, String> map = new HashMap<>();
        map.put("a","a");
        map.put("c","c");
        map.put("b","b");
        map.put("a","b");
        System.out.println(map);//key不允许重复，无序{a=b, b=b, c=c}

        LinkedHashMap<String, String> linked = new LinkedHashMap<>();
        linked.put("a","a");
        linked.put("c","c");
        linked.put("b","b");
        linked.put("a","d");
        System.out.println(linked);//key不允许重复，有序{a=d, c=c, b=b}
    }
}

```

### 09_Hashtable集合

```java
package com.itheima07.demo03.Map;

import java.util.HashMap;
import java.util.Hashtable;

/*
    java.util Hashtable<K,V>集合 implements Map<K,V>接口

    Hashtable：底层也是一个哈希表，是一个线程安全的集合，是单线程集合，速度慢
    HashMap：底层是一个哈希表，是一个线程不安全的集合，是多线程的集合吗，速度快
：
    HashMap集合（之前学的所有的集合）：可以存储null值，null键
    Hashtable集合，不能存储null值，null键

    Hashtable和vector集合一样，在1.2版本之后被更先进的集合（HashMap，Arraylist）取代了
    Hashtable的子类properties依然活跃在历史舞台
    properties集合是一个唯一和IO流相结合的集合
 */
public class Demo02HashTable {
    public static void main(String[] args) {
        HashMap<String, String> map = new HashMap<>();
        map.put(null,"a");
        map.put("b",null);
        map.put(null,null);
        System.out.println(map);//{null=null, b=null}

        Hashtable<String, String> table = new Hashtable<>();
        table.put(null,"a");
        table.put("b",null);
        table.put(null,null);
        System.out.println(table);//NullPointerException
    }
}
```

### 10_练习_计算一个字符串中每个字符出现次数

![03_练习_计算一个字符串中每个字符出现次数](C:/Users/Murphy/Pictures/03_练习_计算一个字符串中每个字符出现次数.bmp)

```java
package com.itheima07.demo03.Map;

import java.util.HashMap;
import java.util.Scanner;

/*
    练习：
    计算一个字符串中每个字符出现次数分析：
    1.使用Scanner获取用户输入的字符串
    2.创建Map集合，key是字符串中的字符， value是字符的个数
    3.遍历字符串，获取每一个字符
    4.使用获取到的字符，去Map集合判断key是否存在
    key存在：
        通过字符（key），获取 value（字符个数）
        value++
        put（key, value）把新的 value存储到Map集合中
     key不存在：
        put（key, 1）
    5.遍历Map集合输出结果
 */
public class Demo03MapTest {
    public static void main(String[] args) {
        //使用Scanner获取用户输入的字符串
        Scanner scanner = new Scanner(System.in);
        System.out.println("请输入内容：");
        String str = scanner.next();
        //创建Map集合，key是字符串中的字符， value是字符的个数
        HashMap<Character, Integer> map = new HashMap<>();
        //遍历字符串，获取每一个字符
        for (char c : str.toCharArray()) {
            //使用获取到的字符，去Map集合判断key是否存在
            if (map.containsKey(c)){
                //key存在
                Integer value = map.get(c);
                value++;
                map.put(c,value);
            }else {
                //key不存在
                map.put(c,1);
            }
        }
        //遍历Map集合输出结果
        for (Character key : map.keySet()) {
            Integer value = map.get(key);
            System.out.println(key+"="+value);
        }
    }
}
```

### 11_JDK9对集合添加的优化_of方法

```java
package com.itheima07.demo04.JDK9;

import java.util.List;
import java.util.Map;
import java.util.Set;

/*
    JDK9的新特性：
        list接口，Set接口，Map接口：里边增加了一个静态方法of，可以给集合一次性添加多个元素
        static <E> List<E> of(E... elements)
        使用前提：
            当集合中存储的元素的个数已经确定了，不再改变时使用
        住院：
        1.of方法只适用于  List接口，Set接口，Map接口，不适用于接口的实现类
        2.of方法的返回值是一个不能改变的集合，集合不能再使用add，put方法添加元素，会抛出异常
        3.Set接口和Map接口再调用of方法的时候，不能有重复的元素，否则会抛出异常
 */
public class Demo01JDK9 {
    public static void main(String[] args) {
        List<String> list = List.of("a","b","c","d");
        System.out.println(list);
        //list.add("e");//UnsupportedOperationException：不支持操作异常

        //Set<String> set = Set.of("a", "b", "v","a");//IllegalArgumentException：非法参数异常，有重复的元素

        Set<String> set = Set.of("a", "b", "v");
        System.out.println(set);
        //set.add("t");//UnsupportedOperationException：不支持操作异常

        Map<String, Integer> map = Map.of("张三", 18, "李四", 19, "王五", 20);
        //Map<String, Integer> map = Map.of("张三", 18, "李四", 19, "王五", 20, "张三", 19);//IllegalArgumentException：非法参数异常，有重复的元素
        System.out.println(map);
        //map.put("赵思",22);//UnsupportedOperationException：不支持操作异常
    }
}
```

### 12_Debug追踪

```java
package com.itheima07.demo05.Debug;
/*
    Debug调式程序：
        可以让代码逐行，查看代码执行过程中，调式程序中出现的bug
    使用方式：
        在行号的右边，鼠标左键单击，添加断点（每个方法的第一行，哪里有bug添加到哪里）
        右键选择debug执行程序
        程序就会停留在添加的第一个断点处
    执行程序：
        F8逐行执行程序
        F7进入到方法中
        shift+F8：跳出方法
        F9跳到下一个断点，如果没有下一个断点，就结束程序
        Ctrl+F2：退出debug模式，停止程序
        Console：切换到控制台
 */
public class Demo01Debug {
    public static void main(String[] args) {
        /*int a = 10;
        int b = 20;
        int sum = a + b;
        System.out.println(sum);*/

       /* for (int i = 0; i < 3; i++) {
            System.out.println(i);
        }*/
       print();
    }

    private static void print() {
        System.out.println("Hello word");
        System.out.println("Hello word");
        System.out.println("Hello word");
        System.out.println("Hello word");
        System.out.println("Hello word");
    }
}
```

### 13_斗地主案例的需求分析

![04_斗地主案例需求分析](C:/Users/Murphy/Pictures/04_斗地主案例需求分析.bmp)

### 14_斗地主案例的代码实现

```java
package com.itheima07.demo06.Test;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;

/*
    斗地主综合案例：有序版本
    1.准备牌
    2.洗牌
    3.发牌
    4.排序
    5.看牌
 */
public class DouDiZhu {
    public static void main(String[] args) {
        //准备牌
        //创建一个Map集合，存储牌的索引和组装好的牌
        HashMap<Integer, String> poker = new HashMap<>();
        //创建一个list集合存储牌的索引
        ArrayList<Integer> pokerIndex = new ArrayList<>();
        //定义两个集合，存储花色和牌的序号
        List<String> colors = List.of("♠", "♥", "♣", "♦");
        List<String> numbers = List.of("2", "A", "K", "Q", "J", "10", "9", "8", "7", "6", "5", "4", "3");
        //把大王和小王存储到集合中
        //定义一个牌的索引
        int index = 0;
        poker.put(index,"大王");
        pokerIndex.add(index);
        index++;
        poker.put(index,"小王");
        pokerIndex.add(index);
        index++;
        //循环嵌套遍历两个集合，组装52张牌存储到集合中
        for (String number : numbers) {
            for (String color : colors) {
                poker.put(index,color+number);
                pokerIndex.add(index);
                index++;
            }
        }
        //System.out.println(poker);
        //System.out.println(pokerIndex);
        /*
            2.洗牌
            用Collections中的方法shuffle（List）
         */
        Collections.shuffle(pokerIndex);
        //System.out.println(pokerIndex);

/*
        3.发牌
        定义四个集合存储玩家牌的索引和底牌的索引
*/
        ArrayList<Integer> player01 = new ArrayList<>();
        ArrayList<Integer> player02 = new ArrayList<>();
        ArrayList<Integer> player03 = new ArrayList<>();
        ArrayList<Integer> diPai = new ArrayList<>();

        //遍历存储牌索引的List集合，获取每一个牌的索引
        for (int i = 0; i < pokerIndex.size(); i++) {
            Integer in = pokerIndex.get(i);
            //先判断底牌
            if (i>=51){
                //给底牌发牌
                diPai.add(in);
            }else if (i%3==0){
                player01.add(in);
            }else if (i%3==1){
                player02.add(in);
            }else if (i%3==2){
                player03.add(in);
            }
        }
        /*
        4.排序
            使用sort
            默认是升序排序
*/
        Collections.sort(player01);
        Collections.sort(player02);
        Collections.sort(player03);
        Collections.sort(diPai);
/*
        5.看牌
*/
        lookPoker("刘德华",poker,player01);
        lookPoker("周润发",poker,player02);
        lookPoker("周星驰",poker,player03);
        lookPoker("底牌",poker,diPai);
    }
    /*
        5.看牌
        定义一个看牌的方法，提高代码的复用性
        参数：
            String  name:玩家名称
            HashMap<Integer, String> poker：存储牌的poker集合
            ArrayList<Integer> list:存储玩家和底牌的List集合
            查表法：
                遍历玩家或底牌集合，获取牌的索引
                使用牌的索引，去Map集合中，找到对应的牌
*/
    public static void lookPoker(String name,HashMap<Integer, String> poker,ArrayList<Integer> list){
        //输出玩家的名称，不换行
        System.out.print(name+":");
        //遍历玩家或底牌集合，获取牌的索引
        for (Integer key : list) {
            //使用牌的索引，去Map集合中，找到对应的牌
            String value = poker.get(key);
            System.out.print(value+" ");
        }
        System.out.println();//打印完每一个玩家的牌换行
    }
}
```

## 05_异常，线程

### 01_异常概念&异常体系

* **异常** ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。

在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。



### 02_异常分类

`Throwable` 类是 Java 语言中所有错误或异常的超类。

异常的根类是`java.lang.Throwable`，其下有两个子类：`java.lang.Error`与`java.lang.Exception`，平常所说的异常指`java.lang.Exception`。

**Throwable体系：**

* **Error**:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。

* **Exception**:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。

* ```java
  package com.itheima08.demo01.Exception;
  
  import java.text.ParseException;
  import java.text.SimpleDateFormat;
  import java.util.Date;
  
  /*
      Throwable 类是 Java 语言中所有错误或异常的超类。
          Exception:编译期异常，进行编译（写代码）java程序出现的问题
              RuntimeException：运行期异常，java程序运行过程中出现的问题
              异常就相当于程序得了一个小毛病，把异常处理掉，程序可以继续执行
          Error：错误
              错误就相当于程序得了一个无法治愈的毛病，必须修改源代码，程序才能继续执行
   */
  public class Demo01Exception {
      public  static void main(String[] args) /*throws ParseException*/ {
          //Exception:编译期异常
          /*SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
          Date date = null;//把字符串格式日期，解析为Date格式的日期
          try {
              date = sdf.parse("1999-0909");
          } catch (ParseException e) {
              e.printStackTrace();
          }
          System.out.println(date);*/
  
          //运行期异常
  /*        int[] array = {1,2,3};
          //System.out.println(array[0]);
          try {
              //可能会出现异常的代码
              System.out.println(array[3]);
          }catch (Exception e){
              //异常的处理逻辑
              System.out.println(e);
          }*/
  
          //Error：错误
          int[]array = new int[1024*1024*1024];//OutOfMemoryError: Java heap space
          //内存溢出的错误，创建的数组太大了，超出了jvm分配的内存
          // 必须修改代码，创建的数组小一点
          System.out.println("后续代码");
      }
  }
  
  ```


### 03_异常的产生过程解析

![01_异常的产生过程解析](C:/Users/Murphy/Pictures/01_异常的产生过程解析-16392346359206.bmp)

### 04_throw关键字

Java异常处理的五个关键字：**try、catch、finally、throw、throws**

```java
package com.itheima08.demo01.Exception;
/*
    throw关键字
    作用：
        可以使用throw关键字在指定的方法中抛出指定的异常
    格式：
        throw new xxxException（"异常产生的原因"）;
    注意：
        1.throw关键字必须写在方法的内部
        2.throw关键字后边new的对象必须是Exception或者Exception的子对象
        3.throw关键字抛出指定的异常对象，我们必须处理这个异常对象
            throw关键字后边创建的是RuntimeException或者是RuntimeException的子对象，我们可以不处理，默认交给JVM处理（打印异常程序，中断程序）
            throw关键字后边创建的是编译异常（写代码的时候报错），我们就必须处理这个异常，要么throws，要么try...catch
 */
public class Demo03Throw {
    public static void main(String[] args) {
        //int [] arr = null;
        int[] arr = new int[3];
        int e = getElement(arr, 3);
        System.out.println(e);
    }
    /*
    定义一个方法，获取数组指定所引出的元素
    参数：
        int[] arr
        int index
    以后（工作中）我们首先必须对方法传递过来的参数进行合法性校验
    如果参数不合法，那么我们就必须使用抛出异常的方式，告诉方法的调用者，传递的参数有问题
    注意：
        NullPointerException是一个运行期异常，我们不用处理，默认交给JVM处理
        IndexOutOfBoundsException是一个运行期异常，我们不用处理，默认交给JVM处理
 */
    public static int getElement(int[] arr,int index){
        /*
            我们可以对传递过来的参数数组进行合法性校验
            如果数组的值是null
            那么我们就抛出空指针异常，告知方法的调用者：”传递的数组值是null“
         */
        if (arr == null){
            throw new NullPointerException("传递的数组的值是空");
        }
        /*
            我们可以对传递过来的参数index进行合法性校验
            如果index的范围不在数组的索引范围内
            那么我们就抛出数组索引越界异常，告知方法的调用者：“传递的索引超出了数组的适用范围”
         */
        if (index<0||index>arr.length-1){
            throw new IndexOutOfBoundsException("传递的索引超出了数组的适用范围");
        }
        int ele = arr[index];
        return ele;
    }
}

```

### 05_Objects非空判断_requireNonNull方法

```java
package com.itheima08.demo01.Exception;

import java.util.Objects;

/*
    Objects类中的静态方法
    `public static <T> T requireNonNull(T obj)`:查看指定引用对象不是null。
    源码
        public static <T> T requireNonNull(T obj) {
             if (obj == null)
               throw new NullPointerException();
            return obj;
        }
 */
public class Demo04Objects {
    public static void method(Object obj){
        //对传过来的对象进行合法性判断，判断是否为null
/*        if (obj == null){
            throw new NullPointerException("传递的对象的值是null");
        }*/

        //Objects.requireNonNull(obj);
        Objects.requireNonNull(obj,"传递的对象值的是null");
    }
    public static void main(String[] args) {
        method(null);
    }
}
```

### 06_throws关键字_异常处理的第一种方式,交给别人处理

```java
package com.itheima08.demo01.Exception;

import java.io.FileNotFoundException;
import java.io.IOException;

/*
    throws关键字：是异常处理的第一种方式，交给别人处理
    作用:
        当方法内部抛出异常对象的时候，那么我们就必须处理这个异常对象
        可以使用throws关键字处理异常对象，会把异常对象声明抛出给方法的调用者处理（自己不处理，给别人处理），最终交给JVM处理-->中断处理
        格式：在方法声明时使用
            修饰符 返回值类型 方法名(参数列表) throws AAAException,BBBException...{
                throw new AAAException("产生原因");
                throw new BBBException("产生原因");
                ...
            }
        注意：
            1.throws关键字必须写在方法声明处
            2.throws关键字后边声明的异常必须是Exception或者是Exception的子类
            3.方法内部如果抛出了多个异常对象，那么throws后边必须也声明多个异常
                如果抛出的多个异常对象有子父类关系，那么直接声明父类异常即可
            4.调用了一个声明抛出异常的方法，我们就必须的处理声明的异常
                要么继续使用throws，交给方法的调用者处理最终交给JVM
                要么try...catch
 */
public class Demo05Throws {
    /*
        FileNotFoundException extends IOException
        IOException extends Exception
        如果抛出的多个异常对象有子父类关系，那么直接声明父类异常即可
     */
    public static void main(String[] args) throws IOException {
        readFile("c:\\a.tx");
    }

    /*
        定义一个方法，对传递的路径进行合法性的判断
        如果路径不是“c:\\a.txt”,那么我们就抛出文件找不到异常对象，告知方法的调用者
        注意：
            FileNotFoundException是编译异常，抛出了编译异常，就必须处理这个异常
            可以使用throes继续声明抛出FileNotFoundException这个异常对象，让方法的调用者处理
     */
    public static void readFile(String filaName)throws IOException{
        if (!filaName.equals("c:\\a.txt")){
            throw new FileNotFoundException("传递的文件路径不是c:\\a.txt");
        }
        /*
            如果传递的路径，不是.txt结尾
            那么我们就抛出IO异常对象，告知方法的使用者，文件的后缀名不对
         */
        if (!filaName.endsWith(".txt")){
            throw new IOException("文件的后缀名不对");
        }
        System.out.println("路径没有问题，读取文件");
    }
}
```

### 07_try_catch_异常处理的第二种方式,自己处理异常

```java
package com.itheima08.demo02.Exception;

import java.io.IOException;

/*
    try...catch:异常处理的第二种方式，自己处理异常
    格式：
    try{
        可能产生异常的代码
    }catch（定义一个异常的变量，用来接收try种抛出的异常对象）{
        异常的处理逻辑，产生异常对象之后，怎么处理异常对象
        一般在工作中，会把异常的信息记录到一个日志中
    }
    ...
    catch（异常类名 变量名）{

    }
    注意事项：
    1.try中可能抛出多个异常对象，那么就可以使用多个catch来处理这些异常对象
    2.如果try种产生了异常，那么就会执行catch中的异常处理逻辑，执行完毕catch中的处理逻辑，继续执行try...catch之后的代码
        如果try中没有产生异常，那么就不会执行catch中异常的处理逻辑，执行完try中的代码，继续执行try...catch之后的代码
 */
public class Demo01TryCatch {
    public static void main(String[] args) {
        try{
            readFile("d:\\a.txt");}
        catch (IOException E){//try中抛出什么异常对象，catch就定义什么异常变量，用来接收这个异常对象
            System.out.println("catch - 传递的文件的后缀不是.txt");
        }
        System.out.println("后续代码");
    }


    public static void readFile(String filaName) throws IOException {
            /*
            如果传递的路径，不是.txt结尾
            那么我们就抛出IO异常对象，告知方法的使用者，文件的后缀名不对
         */
            if (!filaName.endsWith(".txt")) {
                throw new IOException("文件的后缀名不对");
            }
            System.out.println("路径没有问题，读取文件");

    }
}
```

### 08_Throwable类中3个异常处理的方法

```java
 /*
   Throwable类中定义了三个异常处理的方法
    String getMessage() 返回此 throwable 的简短描述。
    String toString()  返回此 throwable 的详细消息字符串。
    void printStackTrace() JVM打印异常对象，默认此方法，打印的异常信息是最全面的
*/
   System.out.println(e.getMessage());//文件的后缀名不对
   System.out.println(e.toString());//重写Object类的ObjecttoString方法 java.io.IOException: 文件的后缀名不对
   System.out.println(e);//java.io.IOException: 文件的后缀名不对
   e.printStackTrace();
   /*java.io.IOException: 文件的后缀名不对
    at com.itheima08.demo02.Exception.Demo01TryCatch.readFile(Demo01TryCatch.java:51)
    at com.itheima08.demo02.Exception.Demo01TryCatch.main(Demo01TryCatch.java:26)*/
```

### 09_finally代码块

**finally**：有一些特定的代码无论异常是否发生，都需要执行。

```java
package com.itheima08.demo02.Exception;

import java.io.IOException;

/*
    finally代码块
    try{
        可能产生异常的代码
    }catch（定义一个异常的变量，用来接收try种抛出的异常对象）{
        异常的处理逻辑，产生异常对象之后，怎么处理异常对象
        一般在工作中，会把异常的信息记录到一个日志中
    }
    ...
    catch（异常类名 变量名）{

    }finally{
        无论是否出现异常都会执行
    }
    注意事项：
    1.finally不能单独使用，必须和try一起使用
    2.finally一般用于资源释放（资源回收），无论程序是否出现异常，最后都要资源释放（IO）
 */
public class Demo02TryCatchFinally {
    public static void main(String[] args)  {
        try {
            //可能会产生异常的代码
            readFile("d:\\a.tx");
        } catch (IOException e) {
            //异常的处理逻辑
            e.printStackTrace();
        }finally {
            //无论是否出现异常都会执行
            System.out.println("资源释放");
        }
    }
    public static void readFile(String filaName) throws IOException {
            /*
            如果传递的路径，不是.txt结尾
            那么我们就抛出IO异常对象，告知方法的使用者，文件的后缀名不对
         */
        if (!filaName.endsWith(".txt")) {
            throw new IOException("文件的后缀名不对");
        }
        System.out.println("路径没有问题，读取文件");

    }
}
```

### 10_异常注意事项_多异常的捕获处理

```java
package com.itheima08.demo03.Exception.Exception;

import java.util.List;

/*
    异常的注意事项
 */
public class Demo01Exception {
    public static void main(String[] args) {
        /*
    多个异常使用捕获又该如何处理呢？
    1.多个异常分别处理
    2.多个异常一次捕获，多次处理
    3.多个异常一次捕获，一次处理
*/
        //1.多个异常分别处理
/*        try {
            int[] arr = {1, 2, 3};
            System.out.println(arr[3]);//ArrayIndexOutOfBoundsException
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.println(e);
        }

        try {
            List<Integer> list = List.of(1, 2, 3);//IndexOutOfBoundsException :Index 3 out-of-bounds for length 3
            System.out.println(list.get(3));
        } catch (IndexOutOfBoundsException e) {
            System.out.println(e);
        }*/
         //2.多个异常一次捕获，多次处理
/*        try {
            int[] arr = {1, 2, 3};
            //System.out.println(arr[3]);//ArrayIndexOutOfBoundsException
            List<Integer> list = List.of(1, 2, 3);//IndexOutOfBoundsException :Index 3 out-of-bounds for length 3
            System.out.println(list.get(3));
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.println(e);
        }catch (IndexOutOfBoundsException e){
            System.out.println(e);
        }*/
        /*
            一个try，多个catch注意事项：
            catch里边定义的异常变量，如果有子父类关系，那么子类的异常变量必须写在上班，否则就会报错
         */
        //3.多个异常一次捕获，一次处理
        //运行时异常被抛出可以不处理。即不捕获也不声明抛出。
        //默认给虚拟机处理，终止程序，什么时候不抛出运行时异常了，再来继续执行程序
        try {
            int[] arr = {1, 2, 3};
            //System.out.println(arr[3]);//ArrayIndexOutOfBoundsException
            List<Integer> list = List.of(1, 2, 3);//IndexOutOfBoundsException :Index 3 out-of-bounds for length 3
            System.out.println(list.get(3));
        } catch (Exception e) {
            System.out.println(e);
        }

        System.out.println("后续代码");
    }

}
```

### 11_异常注意事项_finally有return语句

```java
package com.itheima08.demo03.Exception.Exception;
/*
    如果finally有return语句,永远返回finally中的结果,避免该情况.
 */
public class Demo02Exception {
    public static void main(String[] args) {
        int a = getA();
        System.out.println(a);
    }

    //定义一个方法，返回变量a的值
    public static int getA(){
        int a = 10;
        try{
            return a;
        }catch (Exception e){
            System.out.println(e);
        }finally {
            //一定会执行的代码
            a = 100;
            return  a;
        }
    }
}
```

### 12_异常注意事项_子父类异常

```java
package com.itheima08.demo03.Exception.Exception;
/*
    如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。

    父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出
    注意：
        父类异常是什么样，子类异常就什么样
 */
public class Fu {
    public void show01()throws NullPointerException,ClassCastException{}
    public void show02()throws IndexOutOfBoundsException{}
    public void show03()throws IndexOutOfBoundsException{}
    public void show04() {}
}

class Zi extends Fu{
    //子类重写父类方法时,抛出和父类相同的异常
    public void show01()throws NullPointerException,ClassCastException{}
    //子类重写父类方法时，抛出父类异常的子类
    public void show02()throws IndexOutOfBoundsException{}
    //子类重写父类方法时
    public void show03(){}
    //父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。
    public void show04(){
        try {
            throw new Exception("编译期异常");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

### 13_自定义异常类

```java
package com.itheima08.demo04.Exception;
/*
    自定义异常类：
        java提供的异常类不够我们使用，需要自己定义一些异常类
    格式：
        public class xxxException extends Exception/RuntimeException{
            添加一个空参数的构造方法
            添加一个带异常信息的构造方法
        }
        注意：
            1.自定义异常类一般都是以Exception结尾，说明该类是一个异常类
            2.自定义异常类，必须的继承Exception或RuntimeException
            继承Exception：那么自定义的异常类就是一个编译期异常，如果方法内部抛出了编译期异常，就必须处理这个异常，要么throws，要么try... catch
            继承RuntimeException：那么自定义的异常类就是一个运行期异常，无需处理，交给虚拟机处理（中断处理）
 */
public class RegisterException extends Exception{
    //添加一个空参数的构造方法
    public RegisterException(){
        super();
    }

/*
    添加一个带异常信息的构造方法
    查看源码发现，所有的异常类都会有一个带异常信息的构造方法，方法内部会调用父类带异常信息的构造方法，让父类来处理这个异常信息
*/
    public RegisterException(String message){
        super(message);
    }
}
```

### 14_自定义异常类的练习

```java
package com.itheima08.demo04.Exception;

import java.util.Scanner;

/*
    要求：我们模拟注册操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。
    分析
    1.使用数组保存已经注册过的用户名（数据库）
    2.使用Scanner获取用户输入的注册的用户名（前端，页面）
    3.定义一个方法，对用户输入的注册的用户名进行判断
        遍历存储已经注册过用户名的数组，获取每一个用户名
        使用获取到的用户名和用户输入的用户名比较
        true：用户名已经存在，抛出异常RegisterException异常，告知用户"用户名已经被注册"；
        false：继续遍历比较
        如果循环结束了还没找到重复的用户名，提示用户“恭喜，注册成功”
 */
public class Demo01RegisterException extends Exception{
    //使用数组保存已经注册过的用户名（数据库）
    static String[] usernames ={"张三","李四","王五"};

    public static void main(String[] args) /*throws RegisterException*/ {
        //使用Scanner获取用户输入的注册的用户名
        Scanner scanner = new Scanner(System.in);
        System.out.println("请输入请要注册的用户名：");
        String uername = scanner.next();
        checkUsername(uername);
    }

    //定义一个方法，对用户输入的注册的用户名进行判断
    public static void checkUsername(String username) /*throws RegisterException*/ {
        //遍历存储已经注册过用户名的数组，获取每一个用户名
        for (String name : usernames) {
            //使用获取到的用户名和用户输入的用户名比较
            if (name.equals(username)){
                //true：用户名已经存在，抛出异常RegisterException异常，告知用户"用户名已经被注册"；
                try {
                    throw new RegisterException("该用户已经被注册");
                } catch (RegisterException e) {
                    e.printStackTrace();
                    return;//结束方法
                }
            }
        }
        //如果循环结束了还没找到重复的用户名，提示用户“恭喜，注册成功”
        System.out.println("恭喜，注册成功！");
    }
}
```

```java
抛出运行期异常无需处理
```

### 15_并发与并行

![02_并发与并行](C:/Users/Murphy/Pictures/02_并发与并行-16392346739598.bmp)

### 16_进程概念

* **进程**：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。

* **线程**：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 

  简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程

  ![03_进程概念](C:/Users/Murphy/Pictures/03_进程概念-16392346907859.bmp)

### 17_线程概念

![04_线程概念](C:/Users/Murphy/Pictures/04_线程概念-163923470253610.bmp)

### 18_线程调度

- 分时调度

  所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。

- 抢占式调度

  优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。

### 19_主线程

![05_主线程](C:/Users/Murphy/Pictures/05_主线程.bmp)

```java
package com.itheima08.Demo05.Thread;
/*
    主线程:执行主(main)方法的线程

    单线程程序:java程序中只有一个线程
    执行从main方法开始,从上到下依次执行

    JVM执行main方法,main方法会进入到栈内存
    JVM会找操作系统开辟一条main方法通向cpu的执行路径
    cpu就可以通过这个路径来执行main方法
    而这个路径有一个名字,叫main(主)线程
 */
public class Demo01MainThread {
    public static void main(String[] args) {
        Person p1 = new Person("小强");
        p1.run();

        Person p2 = new Person("旺财");
        p2.run();
    }
}
```

### 20_创建多线程程序的第一种方式_创建Thread类的子类

```java
package com.itheima08.demo06.Thread;
/*
    创建多线程程序的第一种方式：创建Thread类的子类
    java.lang.Thread类：是描述线程的类，我们想要实现多线程程序就必须继承Thread类

    实现步骤：
        1.创建一个Thread类的子类
        2.在Thread类的子类中重写Thread中的run方法，设置线程任务（开启线程要做什么？）
        3.创建Thread类的子类对象
        4.调用Thread类中的方法start方法，开启新的线程，执行run方法
            void start() 使该线程开始执行；Java 虚拟机调用该线程的 run 方法。
            结果是两个线程并发地运行；当前线程（main线程）和另一个线程（创建的新线程，执行其 run 方法）。
            多次启动一个线程是非法的。特别是当线程已经结束执行后，不能再重新启动。
    java程序属于抢占式调度，哪个程序的优先级高，哪个线程优先执行；同一个优先级

 */
public class Demo01Thread {
    public static void main(String[] args) {
        //3.创建Thread类的子类对象
        MyThread mt = new MyThread();
        //4.调用Thread类中的方法start方法，开启新的线程，执行run方法
        mt.start();

        for (int i = 0; i < 20; i++) {
            System.out.println("main" + i);
        }
    }
}
```

```java
package com.itheima08.demo06.Thread;
//1.创建一个Thread类的子类
public class MyThread extends Thread{
    //2.在Thread类的子类中重写Thread中的run方法，设置线程任务（开启线程要做什么？）
    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {
            System.out.println("run" + i);
        }
    }
}
```

## 06_线程、同步

###   01_多线程原理_随机性打印结果

![01_多线程随机性打印结果](C:/Users/Murphy/Pictures/01_多线程随机性打印结果.bmp)

### 02_多线程原理_多线程内存图解

![02_多线程内存图解](C:/Users/Murphy/Pictures/02_多线程内存图解.bmp)

### 03_Thread类的常用方法_获取线程名称的方法

```java
package com.itheima09.demo01.ThreadGetName;
/*
    获取线程的名称：
        1.使用Thread类中的方法getName()
        String getName() 返回该线程的名称。
        2.可以先获取到当前正在执行的线程，使用线程中的方法getName()获取线程的名称
        static Thread currentThread() 返回对当前正在执行的线程对象的引用。
 */
//定义一个Thread类的子类
public class MyThread extends Thread{
    //重写Thread类中的run方法，设置线程任务

    @Override
    public void run() {
        //获取线程的名称
        /*String name = getName();
        System.out.println(name);*/
/*        Thread t = Thread.currentThread();
        System.out.println(t);//Thread[Thread-0,5,main]

        System.out.println(t.getName());*/

        //链式编程
        System.out.println(Thread.currentThread().getName());
    }
}
```

```java
package com.itheima09.demo01.ThreadGetName;
/*
    线程的名称：
        主线程的名称：mian
        新线程：Thread-0，Thread-1，Thread-2
 */
public class Demo01GetThreadName {
    public static void main(String[] args) {
        //创建Thread类的子类对象
        MyThread mt = new MyThread();
        mt.start();

        new MyThread().start();

        new MyThread().start();
        System.out.println(Thread.currentThread().getName());//main
    }
}
```

### 04_Thread类的常用方法_设置线程名称的方法

```java
package com.itheima09.demo02.ThreadSetName;

public class Demo01SetThreadName {
    public static void main(String[] args) {
        //开启多线程
        MyThread mt = new MyThread();
        mt.setName("小强");
        mt.start();

        //开启多线程
        new MyThread("旺财").start();
    }
}
```

```java
package com.itheima09.demo02.ThreadSetName;
/*
    设置线程的名称：（了解）
        1.使用Thread类中的方法setName(名字)
            void setName(String name) 改变线程名称，使之与参数 name 相同。
        2.创建一个带参数的构造方法，参数传递线程的名称，调用父类的带参构造方法，把线程名称传递给父类，让父类（Thread）给子线程起一个名字
            Thread(String name) 分配新的 Thread 对象。
 */
public class MyThread extends Thread{

    public MyThread(){}

    public MyThread(String name){
        super(name);//把线程名称传递给父类，让父类（Thread）给子线程起一个名字
    }

    @Override
    public void run() {
        //获取线程的名称
        System.out.println(Thread.currentThread().getName());
    }
}
```

### 05_Thread类的常用方法_sleep

```java
package com.itheima09.demo03.sleep;
/*
    static void sleep(long millis) :使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）
    毫秒数结束之后，线程继续执行
 */
public class Demo01Sleep {
    public static void main(String[] args) {
        //模拟秒表
        for(int i = 1;i <=60;i++){
            System.out.println(i);
            //使用Thread类的sleep方法让程序睡眠一秒钟
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

### 06_创建多线程程序的第二种方式_实现Runnable接口

```java
package com.itheima09.demo04.Runnable;
/*
    创建多线程程序的第二种方式：实现Runnable接口
        Runnable接口应该由那些打算通过某一线程执行其实例来实现。类必须定义一个称为run的无参数方法
        java.lang.Thread类的构造方法
            Thread(Runnable target) 分配新的 Thread 对象。
            Thread(Runnable target, String name) 分配新的 Thread 对象。
    实现步骤：
        1.创建Runnable接口的实现类
        2.在实现类中重写Runnable接口的run方法，设置线程任务
        3.创建Runnable接口的实现类对象
        4.创建Thread类对象，构造方法中传递Runnable接口的实现类对象
        5.调用Thread类中的start方法，开启新的线程执行run方法
        
  	实现 Runnable接口创建多线程程序的好处：
	1.避免了单继承的局限性一个类只能继承一个类（一个人只能有一个亲爹），类继承了 Thread类就不能继承其他的类实现了 Runnable接口，还可以继承其他的类，实现其他的接口
	2.增强了程序的扩展性，降低了程序的耦合性（解耦）
实现 Runnable接口的方式，把设置线程任务和开启新线程进行了分离（解耦）
实现类中，重写了run方法：用来设置线程任务创建 Thread类对象，调用 start方法：用来开启新线程
 */
public class Demo01Runnable {
    public static void main(String[] args) {
        //3.创建Runnable接口的实现类对象
        RunnableImpl run = new RunnableImpl();
        //4.创建Thread类对象，构造方法中传递Runnable接口的实现类对象
        Thread t = new Thread (run);
        //5.调用Thread类中的start方法，开启新的线程执行run方法
        t.start();
        for (int i = 0;i < 20;i++){
            System.out.println(Thread.currentThread().getName()+"-->"+i);
        }
    }
}
```

```java
package com.itheima09.demo04.Runnable;
//1.创建Runnable接口的实现类
public class RunnableImpl implements Runnable{
    //2.在实现类中重写Runnable接口的run方法，设置线程任务
    @Override
    public void run() {
        for (int i = 0;i < 20;i++){
            System.out.println(Thread.currentThread().getName()+"-->"+i);
        }
    }
}
```

### 07_Thread和Runnable的区别

实现Runnable接口比继承Thread类所具有的优势：

1. 适合多个相同的程序代码的线程去共享同一个资源。
2. 可以避免java中的单继承的局限性。
3. 增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。
4. 线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。
   扩充：在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用
   java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM其实在就是在操作系统中启动了一个进
   程。

### 08_匿名内部类方式实现线程的创建

```java
package com.itheima09.demo05.InnerClassThread;
/*
    匿名内部类方式实现线程的创建

    匿名：没有名字
    内部类：写在其他类内部的类

    匿名内部类作用：简化代码
        把子类继承父类，重写父类的方法，创建子类对象合成一步完成
        把实现类实现类接口，重写接口中的方法，创建实现类对象合成一步完成
    匿名内部类的最终产物：子类/实现类对象，而这个类没有名字

    格式：
        new 父类/接口(){
            重写父类/接口中的方法
        }
 */
public class Demo01InnerClassThread {
    public static void main(String[] args) {
        //线程的父类是Thread
        //new MyThread(),start();
        new Thread(){
            //重写run方法，设置线程任务
            @Override
            public void run() {
                for (int i = 0; i < 20; i++) {
                    System.out.println(Thread.currentThread().getName()+"-->"+"白马");
                }
            }
        }.start();

        //线程的接口Runnable
        //Runnable r = new RunnableImpl();//多态
        Runnable r = new Runnable() {//接口等于实现类
            //重写run方法，设置线程任务
            @Override
            public void run() {
                for (int i = 0; i < 20; i++) {
                    System.out.println(Thread.currentThread().getName() + "-->" + "非马");
                }
            }
        };
        new Thread(r).start();

        //简化接口的方式
        new Thread(new Runnable() {
            //重写run方法，设置线程任务
            @Override
            public void run() {
                for (int i = 0; i < 20; i++) {
                    System.out.println(Thread.currentThread().getName() + "-->" + "题");
                }
            }
        }).start();
    }
}
```

### 09_线程安全问题的概述

![03_线程安全问题的概述](C:/Users/Murphy/Pictures/03_线程安全问题的概述.bmp)

### 10_线程安全问题的代码实现

```java
package com.itheima09.demo06.ThreadSafe;
/*
    模拟卖票案例
    创建三个线程，同时开启，对共享的票进行销售
 */

public class Demo01Ticket {
    public static void main(String[] args) {
        //创建Runnable接口的实现类对象
        RunnableImpl run = new RunnableImpl();
        //创建Thread类的对象，构造方法中传递Runnable接口的实现类对象
        Thread t0 = new Thread(run);
        Thread t1 = new Thread(run);
        Thread t2 = new Thread(run);
        //调用start方法开启多线程
        t0.start();
        t1.start();
        t2.start();
    }
}
```

```java
package com.itheima09.demo06.ThreadSafe;
/*
    实现卖票案例
 */
public class RunnableImpl implements Runnable{
    //定义一个多个线程共享的票源
    private int ticket = 100;

    //设置线程任务：卖票
    @Override
    public void run() {
        //使用死循环，让卖票操作重复执行
        while (true){
            //先判断票是否存在
            if (ticket >0){
                //提高安全问题出现的概率，让程序睡眠
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                //票存在，卖票ticet--
                System.out.println(Thread.currentThread().getName()+"-->正在卖第"+ticket+"张票");
                ticket--;
            }
        }
    }
}
```

### 11_线程安全问题产生的原理

![04_线程安全问题产生的原理](C:/Users/Murphy/Pictures/04_线程安全问题产生的原理.bmp)

### 12_解决线程安全问题_同步代码块

为了保证每个线程都能正常执行原子操作ava引入了线程同步机制。
有三种方式完成同步操作：
1.同步代码块。
2.同步方法。
3.锁机制。

```java
package com.itheima09.demo07.Synchronized.ThreadSafe;
/*
    卖票案例出现了线程安全问题：
    卖出了不存在的票和重复的票

    解决线程安全问题的第一种方案：使用同步代码块
    格式：
        Synchronized(锁对象){
            可能会出现线程安全问题的代码（访问了共享数据的代码）
        }

        注意：
        1.通过代码块中的锁对象，可以使用任意的对象
        2.但是必须保证多个线程，使用的锁对象是同一个
        3.锁对象作用：
            把同步代码块锁住，只让一个线程在同步代码块中执行
 */
public class RunnableImpl implements Runnable{
    //定义一个多个线程共享的票源
    private int ticket = 100;

    //创建一个锁对象
    Object obj = new Object();


    //设置线程任务：卖票
    @Override
    public void run() {
        //使用死循环，让卖票操作重复执行
        while (true){
            //同步代码块
            synchronized (obj){
                //先判断票是否存在
                if (ticket >0){
                    //提高安全问题出现的概率，让程序睡眠
                    try {
                        Thread.sleep(10);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    //票存在，卖票ticet--
                    System.out.println(Thread.currentThread().getName()+"-->正在卖第"+ticket+"张票");
                    ticket--;
                }
            }
        }
    }
}
```

### 13_同步技术的原理

![05_同步的原理](C:/Users/Murphy/Pictures/05_同步的原理.bmp)

### 14_解决线程安全问题_同步方法

```java
package com.itheima09.demo08.Synchronized;
/*
    模拟卖票案例
    创建三个线程，同时开启，对共享的票进行销售
 */

public class Demo01Ticket {
    public static void main(String[] args) {
        //创建Runnable接口的实现类对象
        RunnableImpl run = new RunnableImpl();
        //创建Thread类的对象，构造方法中传递Runnable接口的实现类对象
        System.out.println("run:" + run);
        Thread t0 = new Thread(run);
        Thread t1 = new Thread(run);
        Thread t2 = new Thread(run);
        //调用start方法开启多线程
        t0.start();
        t1.start();
        t2.start();
    }
}
```

```java
package com.itheima09.demo08.Synchronized;

/*
    实现卖票案例

    解决线程安全问题的第二种方案：使用同步方法
    使用步骤：
        1.把访问了共享数据的代码抽取出来，放到一个方法中
        2.在方法上添加synchronized修饰符

    格式：定义方法的修格式
    修饰符 synchronized 返回值类型 方法名(参数列表){
        可能会出现线程安全问题的代码（访问了共享数据的代码）
    }

 */
public class RunnableImpl implements Runnable {
    //定义一个多个线程共享的票源
    private int ticket = 100;

    //设置线程任务：卖票
    @Override
    public void run() {
        System.out.println("this:" + this);
        //使用死循环，让卖票操作重复执行
        while (true) {
            //先判断票是否存在
            payTicket();
        }
    }

    /*
        定义一个同步方法
        同步方法也会把方法内部的代码锁住
        只让一个线程执行
        同步方法的所对象是谁？
        就是实现类对象new RunnableImpl()
        也就是this
     */
    public /*synchronized*/ void payTicket() {
        synchronized (this) {
            if (ticket > 0) {
                //提高安全问题出现的概率，让程序睡眠
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                //票存在，卖票ticet--
                System.out.println(Thread.currentThread().getName() + "-->正在卖第" + ticket + "张票");
                ticket--;
            }
        }
    }
}
```

或

```java
package com.itheima09.demo08.Synchronized;
/*
    实现卖票案例

    解决线程安全问题的第二种方案：使用同步方法
    使用步骤：
        1.把访问了共享数据的代码抽取出来，放到一个方法中
        2.在方法上添加synchronized修饰符

    格式：定义方法的修格式
    修饰符 synchronized 返回值类型 方法名(参数列表){
        可能会出现线程安全问题的代码（访问了共享数据的代码）
    }

 */
public class RunnableImpl implements Runnable{
    //定义一个多个线程共享的票源
    private int ticket = 100;

    //设置线程任务：卖票
    @Override
    public void run() {
        System.out.println("this:"+this);
        //使用死循环，让卖票操作重复执行
        while (true){
            //先判断票是否存在
            payTicket();
        }
    }

    /*
        定义一个同步方法
        同步方法也会把方法内部的代码锁住
        只让一个线程执行
        同步方法的所对象是谁？
        就是实现类对象new RunnableImpl()
        也就是this
     */
    public synchronized void payTicket(){
        if (ticket >0){
            //提高安全问题出现的概率，让程序睡眠
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            //票存在，卖票ticet--
            System.out.println(Thread.currentThread().getName()+"-->正在卖第"+ticket+"张票");
            ticket--;
        }
    }
}
```

### 15_静态同步方法(了解)

```java
package com.itheima09.demo09.Synchronized.Synchronized;
/*
    实现卖票案例

    解决线程安全问题的第二种方案：使用同步方法
    使用步骤：
        1.把访问了共享数据的代码抽取出来，放到一个方法中
        2.在方法上添加synchronized修饰符

    格式：定义方法的修格式
    修饰符 synchronized 返回值类型 方法名(参数列表){
        可能会出现线程安全问题的代码（访问了共享数据的代码）
    }

 */
public class RunnableImpl implements Runnable {
    //定义一个多个线程共享的票源
    private static int ticket = 100;

    //设置线程任务：卖票
    @Override
    public void run() {
        System.out.println("this:" + this);
        //使用死循环，让卖票操作重复执行
        while (true) {
            //先判断票是否存在
            payTicketStatic();
        }
    }

    /*
        静态的同步方法
        锁对象是谁？
        不能是this
        this是创建对象之后产生的，静态方法优先于对象
        静态方法的锁对象是本类的class属性-->class文件对象（反射）
     */
    public static /*synchronized*/ void payTicketStatic() {
        synchronized (RunnableImpl.class) {
            if (ticket > 0) {
                //提高安全问题出现的概率，让程序睡眠
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                //票存在，卖票ticet--
                System.out.println(Thread.currentThread().getName() + "-->正在卖第" + ticket + "张票");
                ticket--;
            }
        }
    }
}
```

### 16_解决线程安全问题_Lock锁

```java
package com.itheima09.demo10.ThreadSafe.Lock;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/*
    解决线程问题的第三种解决方案：使用Lock锁
        java.util.concurrent.locks.lock接口
        Lock 实现提供了比使用 synchronized 方法和语句可获得的更广泛的锁定操作。
        lock接口中的方法
          void lock() 获取锁。
          void unlock() 释放锁。
        java.util.concurrent.locks.ReentrantLock implements Lock接口

         使用步骤：
            1.在成员位置创建ReentrantLock对象
            2.在可能会出现安全问题的代码前调用Lock接口中的方法lock获取锁
            3.在可能会出现安全问题的代码后调用Lock接口中的方法unlock释放锁
 */
public class RunnableImpl implements Runnable{
    //定义一个多个线程共享的票源
    private int ticket = 100;

    //1.在成员位置创建ReentrantLock对象
    Lock l = new ReentrantLock();

    //设置线程任务：卖票
    @Override
    public void run() {
        //使用死循环，让卖票操作重复执行
        while (true){
            //2.在可能会出现安全问题的代码前调用Lock接口中的方法lock获取锁
            l.lock();
            //先判断票是否存在
            if (ticket >0){
                //提高安全问题出现的概率，让程序睡眠
                try {
                    Thread.sleep(10);
                    //票存在，卖票ticet--
                    System.out.println(Thread.currentThread().getName()+"-->正在卖第"+ticket+"张票");
                    ticket--;
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }finally {
                    //3.在可能会出现安全问题的代码后调用Lock接口中的方法unlock释放锁
                    l.unlock();//无论程序是否异常，都会把锁释放
                }
            }
        }
    }
    /*//设置线程任务：卖票
    @Override
    public void run() {
        //使用死循环，让卖票操作重复执行
        while (true){
            //2.在可能会出现安全问题的代码前调用Lock接口中的方法lock获取锁
            l.lock();
            //先判断票是否存在
            if (ticket >0){
                //提高安全问题出现的概率，让程序睡眠
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                //票存在，卖票ticet--
                System.out.println(Thread.currentThread().getName()+"-->正在卖第"+ticket+"张票");
                ticket--;
            }
            l.unlock();
        }
    }*/
}
```

### 17_线程状态概述

![线程的状态图](C:/Users/Murphy/Pictures/线程的状态图.bmp)

### 18_等待唤醒案例分析

![06_等待唤醒案例分析](C:/Users/Murphy/Pictures/06_等待唤醒案例分析.bmp)

### 19_等待唤醒案例代码实现

```java
package com.itheima09.demo11.WaitAndNotify;
/*
    等待唤醒案例：线程之间的通信
        创建一个顾客线程（消费者）：告知老板要的包子的种类和数量，调用wait方法，放弃cpu的执行，进入到WAITING状态（无限等待）
        创建一个老板线程（生产者）：花了五秒做包子，做好包子之后，调用notify方法，唤醒顾客吃包子

        注意：
            顾客和老板线程，必须得使用同步代码块包裹起来，保证等待和唤醒只能有一个在执行
            同步使用的锁对象必须保证唯一
            只有锁对象才能调用wait和notify方法

         Object类中的方法
         void wait()
            在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待。
         void notify()
            唤醒在此对象监视器上等待的单个线程。
            会继续执行wait方法之后的代码
 */
public class Demo01WaitAndNotify {
    public static void main(String[] args) {
        //创建锁对象，保证唯一
        Object obj = new Object();
        //创建一个顾客线程(消费者)
        new Thread(){
            @Override
            public void run() {
                //一直等着买包子
                while (true){
                    //保证等待和唤醒的线程只能有一个执行
                    synchronized (obj){
                        System.out.println("告知老板要的包子的种类和数量");
                        //调用wait方法，放弃cpu的执行，进入到WAITING状态（无限等待）
                        try {
                            obj.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        //唤醒之后执行的代码
                        System.out.println("包子已经做好了，开吃");
                        System.out.println("*************************");
                    }
                }
            }
        }.start();

        //创建一个老板线程（生产者）
        new Thread(){
            @Override
            public void run() {
                //一直做包子
                while (true){
                    //花了五秒做包子
                    try {
                        Thread.sleep(5000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }

                    //保证等待和唤醒的线程只能有一个执行
                    synchronized (obj){
                        System.out.println("老板5秒钟之后做好包子，告知顾客可以吃包子了");
                        //做好包子之后，调用notify方法，唤醒顾客吃包子
                        obj.notify();
                    }
                }
            }
        }.start();
    }
}
```

```java
package com.itheima09.demo11.WaitAndNotify;
/*
    进入到TimeWaiting（计时等待）有两种方式
    1.使用sleep（long m）方法，在毫秒值结束之后，线程进入到Runnable/Block状态
    2.使用wait（long m）方法，wait方法如果在毫秒值结束以后，还没有被notify唤醒，就会自动醒来，线程进入到Runnable/Block状态

    唤醒的方法：
        void notify()唤醒在此对象监视器上等待的单个线程。
        void notifyAll()唤醒在此对象监视器上等待的所有线程。
 */
public class Demo02WaitAndNotify {
    public static void main(String[] args) {
        //创建锁对象，保证唯一
        Object obj = new Object();
        //创建一个顾客线程(消费者)
        new Thread(){
            @Override
            public void run() {
                //一直等着买包子
                while (true){
                    //保证等待和唤醒的线程只能有一个执行
                    synchronized (obj){
                        System.out.println("顾客1告知老板要的包子的种类和数量");
                        //调用wait方法，放弃cpu的执行，进入到WAITING状态（无限等待）
                        try {
                            obj.wait(5000);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        //唤醒之后执行的代码
                        System.out.println("包子已经做好了，顾客1开吃");
                        System.out.println("*************************");
                    }
                }
            }
        }.start();

        //创建一个顾客线程(消费者)
        new Thread(){
            @Override
            public void run() {
                //一直等着买包子
                while (true){
                    //保证等待和唤醒的线程只能有一个执行
                    synchronized (obj){
                        System.out.println("顾客2告知老板要的包子的种类和数量");
                        //调用wait方法，放弃cpu的执行，进入到WAITING状态（无限等待）
                        try {
                            obj.wait(5000);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        //唤醒之后执行的代码
                        System.out.println("包子已经做好了，顾客2开吃");
                        System.out.println("*************************");
                    }
                }
            }
        }.start();

        //创建一个老板线程（生产者）
        new Thread(){
            @Override
            public void run() {
                //一直做包子
                while (true){
                    //花了五秒做包子
                    try {
                        Thread.sleep(5000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }

                    //保证等待和唤醒的线程只能有一个执行
                    synchronized (obj){
                        System.out.println("老板5秒钟之后做好包子，告知顾客可以吃包子了");
                        //做好包子之后，调用notify方法，唤醒顾客吃包子
                        //obj.notify();//如果有多个等待线程，随机唤醒一个
                        obj.notifyAll();//唤醒所有等待的线程
                    }
                }
            }
        }.start();
    }
}
```

### 20_Object类中wait带参方法和notifyAll方法

```java
package com.itheima09.demo11.WaitAndNotify;
/*
    进入到TimeWaiting（计时等待）有两种方式
    1.使用sleep（long m）方法，在毫秒值结束之后，线程进入到Runnable/Block状态
    2.使用wait（long m）方法，wait方法如果在毫秒值结束以后，还没有被notify唤醒，就会自动醒来，线程进入到Runnable/Block状态

    唤醒的方法：
        void notify()唤醒在此对象监视器上等待的单个线程。
        void notifyAll()唤醒在此对象监视器上等待的所有线程。
 */
public class Demo02WaitAndNotify {
    public static void main(String[] args) {
        //创建锁对象，保证唯一
        Object obj = new Object();
        //创建一个顾客线程(消费者)
        new Thread(){
            @Override
            public void run() {
                //一直等着买包子
                while (true){
                    //保证等待和唤醒的线程只能有一个执行
                    synchronized (obj){
                        System.out.println("顾客1告知老板要的包子的种类和数量");
                        //调用wait方法，放弃cpu的执行，进入到WAITING状态（无限等待）
                        try {
                            obj.wait(5000);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        //唤醒之后执行的代码
                        System.out.println("包子已经做好了，顾客1开吃");
                        System.out.println("*************************");
                    }
                }
            }
        }.start();

        //创建一个顾客线程(消费者)
        new Thread(){
            @Override
            public void run() {
                //一直等着买包子
                while (true){
                    //保证等待和唤醒的线程只能有一个执行
                    synchronized (obj){
                        System.out.println("顾客2告知老板要的包子的种类和数量");
                        //调用wait方法，放弃cpu的执行，进入到WAITING状态（无限等待）
                        try {
                            obj.wait(5000);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        //唤醒之后执行的代码
                        System.out.println("包子已经做好了，顾客2开吃");
                        System.out.println("*************************");
                    }
                }
            }
        }.start();

        //创建一个老板线程（生产者）
        new Thread(){
            @Override
            public void run() {
                //一直做包子
                while (true){
                    //花了五秒做包子
                    try {
                        Thread.sleep(5000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }

                    //保证等待和唤醒的线程只能有一个执行
                    synchronized (obj){
                        System.out.println("老板5秒钟之后做好包子，告知顾客可以吃包子了");
                        //做好包子之后，调用notify方法，唤醒顾客吃包子
                        //obj.notify();//如果有多个等待线程，随机唤醒一个
                        obj.notifyAll();//唤醒所有等待的线程
                    }
                }
            }
        }.start();
    }
}
```

## 07_等待与唤醒案例、线程池、Lambda表达式

### 02_等待唤醒机制概述

**什么是等待唤醒机制**

这是多个线程间的一种**协作**机制。谈到线程我们经常想到的是线程间的**竞争（race）**，比如去争夺锁，但这并不是故事的全部，线程间也会有协作机制。就好比在公司里你和你的同事们，你们可能存在在晋升时的竞争，但更多时候你们更多是一起合作以完成某些任务。

就是在一个线程进行了规定操作后，就进入等待状态（**wait()**）， 等待其他线程执行完他们的指定代码过后 再将其唤醒（**notify()**）;在有多个线程进行等待时， 如果需要，可以使用 notifyAll()来唤醒所有的等待线程。

wait/notify 就是线程间的一种协作机制。

**等待唤醒中的方法**

等待唤醒机制就是用于解决线程间通信的问题的，使用到的3个方法的含义如下：

1. wait：线程不再活动，不再参与调度，进入 wait set 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态即是 WAITING。它还要等着别的线程执行一个**特别的动作**，也即是“**通知（notify）**”在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（ready queue）中
2. notify：则选取所通知对象的 wait set 中的一个线程释放；例如，餐馆有空位置后，等候就餐最久的顾客最先入座。
3. notifyAll：则释放所通知对象的 wait set 上的全部线程。

>注意：
>
>哪怕只通知了一个等待的线程，被通知线程也不能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不持有锁，所以她需要再次尝试去获取锁（很可能面临其它线程的竞争），成功后才能在当初调用 wait 方法之后的地方恢复执行。
>
>总结如下：
>
>- 如果能获取锁，线程就从 WAITING 状态变成 RUNNABLE 状态；
>- 否则，从 wait set 出来，又进入 entry set，线程就从 WAITING 状态又变成 BLOCKED 状态

**调用wait和notify方法需要注意的细节**

1. wait方法与notify方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。
2. wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。
3. wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法。

### 03_等待唤醒机制需求分析

![01_等待与唤醒案例分析(1)](C:/Users/Murphy/Pictures/01_等待与唤醒案例分析(1).bmp)

### 04_等待唤醒机制代码实现_包子类&包子铺类

```java
package com.ithiema10.demo01.WaitAndNotify;
/*
    包子类
    设置包子的属性
    皮
    陷
    包子的状态：有true，没有 false
 */
public class BaoZi {
    //皮
    String pi;
    //陷
    String xian;
    //包子的状态：有true，没有 false，设置初始值为false（没有包子）
    boolean flag = false;
}
```

```java
package com.ithiema10.demo01.WaitAndNotify;

/*
    生产者（包子铺）类：是一个线程类，可以继承Thread
    设置线程任务（run）：生产包子
    对包子的状态进行判断
    true：有包子
        包子铺调用wait方法进入等待状态
    false：没有包子
        包子铺生产包子
    增加一些趣味性：
    交替生产两种包子
        有两种状态（i%2==0）
    包子铺生产好了包子
    修改包子的状态为true
    有唤醒吃货线程，让吃货线程吃包子

    注意：
        包子铺线程和包子线程关系-->通信（互斥）
        必须使用同步技术，保证两个线程只能有一个在执行
        锁对象必须保证唯一，可以使用包子对象作为锁对象
        包子铺类和吃货的类就需要把包子对象作为参数传递进来
            1.需要在成员位置创建一个包子变量
            2.使用带参数构造方法，为证包子变量赋值
 */
public class BaoZiPu extends Thread {
    //1.需要在成员位置创建一个包子变量
    private BaoZi bz;

    //2.使用带参数构造方法，为证包子变量赋值
    public BaoZiPu(BaoZi bz) {
        this.bz = bz;
    }

    @Override
    public void run() {
        //定义一个变量
        int count = 0;
        //让包子铺一直生产包子
        while (true) {
            //必须使用同步技术，保证两个线程只能有一个在执行
            synchronized (bz) {
                if (bz.flag == true) {
                    try {
                        bz.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                //被唤醒之后执行，包子铺生产包子
                //增加一些趣味性：交替生产两种包子
                if (count % 2 == 0) {
                    //生产 薄皮包子三鲜包子
                    bz.pi = "薄皮";
                    bz.xian = "三鲜";
                } else {
                    //生产 冰皮糖包子
                    bz.pi = "冰皮";
                    bz.xian = "糖";
                }
                count++;
                System.out.println("包子铺正在生产" + bz.pi + bz.xian + "包子");
                //生产包子需要三秒钟
                try {
                    Thread.sleep(3000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                //包子铺生产好了包子
                //    修改包子的状态为true有
                bz.flag = true;
                //唤醒吃货线程，让吃货线程吃包子
                bz.notify();
                System.out.println("包子铺已经生产好了" + bz.pi + bz.xian + "包子，吃货可以开始吃了");
            }
        }
    }
}
```

### 05_等待唤醒机制代码实现_吃货类&测试类

```java
package com.ithiema10.demo01.WaitAndNotify;
/*
    消费者（吃货）类：是一个线程类，可以继承 Thread
    设置线程任务（run）：吃包子
    对包子的状态进行判断
    false：没有包子
        吃货调用wait方法进入等待状态
    true：有包子
        吃货吃包子
        吃货吃完包子修改包子的状态为 false没有
        吃货唤醒包子铺线程，生产包子
 */
public class ChiHuo extends Thread{
    //1.需要在成员位置创建一个包子变量
    private BaoZi bz;

    //2.使用带参数构造方法，为证包子变量赋值
    public ChiHuo(BaoZi bz) {
        this.bz = bz;
    }
    //设置线程任务（run）：吃包子
    @Override
    public void run() {
        //使用死循环，让吃货一直吃包子
        while (true){
            //必须使用同步技术，保证两个线程只能有一个在执行
            synchronized(bz){
                //对包子的状态进行判断
                if (bz.flag==false){
                    try {
                        bz.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }

                //被唤醒之后执行的代码，吃包子
                System.out.println("吃货正在吃："+bz.pi+bz.xian+"的包子");
                //吃货吃完包子修改包子的状态为 false没有
                bz.flag=false;
                bz.notify();
                System.out.println("吃货已经、把："+bz.pi+bz.xian+"的包子，吃完了，包子铺开始生产包子");
                System.out.println("**********************");
            }
        }
    }
}

```

```java
package com.ithiema10.demo01.WaitAndNotify;
/*
    测试类：
    包含main方法，程序执行的入口，启动程序
    创建包子对象
    创建包子铺线程，开启，生产包子
    创建吃货线程，开启，吃包子
 */
public class Demo {
    public static void main(String[] args) {
        //创建包子对象
        BaoZi bz = new BaoZi();
        //创建包子铺线程，开启，生产包子
        new BaoZiPu(bz).start();
        //创建吃货线程，开启，吃包子
        new ChiHuo(bz).start();
    }
}
```

### 06_线程池的概念和原理

![02_线程池](C:/Users/Murphy/Pictures/02_线程池.bmp)

### 07_线程池的代码实现

```java
package com.ithiema10.demo02.ThreadPool;
/*
    2.创建一个类，实现Runnable接口。重写run方法，设置线程任务
 */
public class RunnableImpl extends Thread{
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName()+"创建了一个新的线程");
    }
}
```

```java
package com.ithiema10.demo02.ThreadPool;


import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/*
    线程池：JDK1.5之后提供的
    java.util.concurrent.Executors；线程池的工厂类，用来生产线程池
    Exectors类中的静态方法：
        static ExecutorService newFixedThreadPool(int nThreads)
          创建一个可重用固定线程数的线程池 。
    参数：
        int nThreads：创建线程池中包含的线程数量
        返回值
            ExecutorService接口，返回的是ExecutorService接口的实现类对象，我们可以使用ExecutorService接口接收（面向接口编程）
        java.util.concurrent.ExecutorService:线程池接口
            用来从线程池获取线程，调用start方法，执行线程任务
                submit(Runnable task)提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。
            关闭/销毁线程池的方法
                shutdown() 启动一次顺序关闭，执行以前提交的任务，但不接受新任务。
    线程池的使用步骤：
        1.使用线程池的工厂类Executors里边提供的静态方法newFixedThreadPool生产一个指定线程数量的线程池
        2.创建一个类，实现Runnable接口。重写run方法，设置线程任务
        3.调用ExecutorService中的方法submit，传递线程任务（实现类），开启线程，执行run方法
        4.调用ExecutorService中的shutdown销毁线程池（不建议使用）
 */
public class Demo01ThreadPool {
    public static void main(String[] args) {
        //1.使用线程池的工厂类Executors里边提供的静态方法newFixedThreadPool生产一个指定线程数量的线程池
        ExecutorService es = Executors.newFixedThreadPool(2);
        //3.调用ExecutorService中的方法submit，传递线程任务（实现类），开启线程，执行run方法
        es.submit(new RunnableImpl());//pool-1-thread-2创建了一个新的线程
        //线程池会一直开启，使用完线程，会自动把线程归还给线程池，线程可以继续执行
        es.submit(new RunnableImpl());//pool-1-thread-1创建了一个新的线程
        es.submit(new RunnableImpl());//pool-1-thread-2创建了一个新的线程

        //4.调用ExecutorService中的shutdown销毁线程池（不建议使用）
        es.shutdown();
        es.submit(new RunnableImpl());//抛异常，线程池都没有了，就不能获取线程了
    }
}
```

### 08_函数式编程思想概述



### 09_冗余的Runnable代码

```java
package com.itheima10.demo03.Lambda;
/*
    使用实现Runnable接口的方式实现多线程程序
 */
public class Demo01Runnable {
    public static void main(String[] args) {
        //创建Runnable接口的实现类对象
        RunnableImpl run = new RunnableImpl();
        //创建Thread对象，构造方法中传递Runnable接口的实现类
        Thread t = new Thread(run);
        t.start();

        //简化，使用匿名内部类，实现多线程程序
        Runnable r = new Runnable() {
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName() + "新的线程创建了");
            }
        };
        new Thread(r).start();

        //简化代码
        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName() + "新的线程创建了");
            }
        }).start();

    }
}
```

### 10_编程思想转换&体验Lambda的更优写法

```
package com.itheima10.demo03.Lambda;

public class Demo02Lambda {
    public static void main(String[] args) {
        //使用匿名内部类的方式，实现多线程
        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName() + "新的线程创建了");
            }
        }).start();

        //使用Lambda表达式实现多线程
        new Thread(()-> {
                System.out.println(Thread.currentThread().getName() + "新的线程创建了");
        }).start();
    }
}
```

### 11_Lambda标准格式

```java
Lambda表达式的标准格式：
由三部分组成：
    a.一些参数
    b.一个箭头
    c.一堆代码
格式：
    （参数列表）->{一些重写方法的代码}:
解释说明格式：
    （）：接口中抽象方法的参数列表，没有参数，就空着；有参数就写出参数，多个参数使用逗号分隔
    ->：传递的意思，把参数传递给方法体{}
    {}：重写接口的抽象方法的方法体
```

### 12_Lambda表达式的无参数无返回值的练习

```java
package com.itheima10.demo04.Lambda;
/*
    给定一个厨子`Cook`接口，内含唯一的抽象方法`makeFood`，且无参数
 */
public interface Cook {
    public abstract void makeFood();
}
```

```java
package com.itheima10.demo04.Lambda;
/*
    需求：
    给定一个厨子`Cook`接口，内含唯一的抽象方法`makeFood`，且无参数、无返回值。
    使用Lambda的**标准格式**调用`invokeCook`方法，打印输出“吃饭啦！”字样
 */
public class Demo01Cook {
    public static void main(String[] args) {
        //调用invokeCook方法，参数是Cook接口，传递Cook接口的匿名内部类对象
        invokeCook(new Cook() {
            @Override
            public void makeFood() {
                System.out.println("吃饭了");
            }
        });

        //使用Lambda表达式，简化匿名内部类的书写
        invokeCook(()->{
            System.out.println("吃饭喽");
        });
    }

    //定义一个方法，参数传递Cook接口，方法内部调用Cook接口中的方法Makefood
    public static void invokeCook(Cook cook){
        cook.makeFood();
    }
}
```

### 13_Lambda表达式有参数有返回值的练习

```java
package com.itheima10.demo05.Lambda;

public class Person {
    private String name;
    private int age;

    public Person() {
    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
```

```java
package com.itheima10.demo05.Lambda;

import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Comparator;

/*
    需求:
    使用数组存储多个Person对象
    对数组中的Person对象使用Arrays的sort方法通过年龄进行升序排序
 */
public class Demo01Arrays {
    public static void main(String[] args) {
        //使用数组存储多个Person对象
        Person[] arr = {
                new Person("柳岩",38),
                new Person("迪丽热巴",28),
                new Person("古力娜扎",27),
        };

        //对数组中的Person对象使用Arrays的sort方法通过年龄进行升序（前边-后边）排序
/*        Arrays.sort(arr, new Comparator<Person>() {
            @Override
            public int compare(Person o1, Person o2) {
                return o1.getAge()- o2.getAge();
            }
        });*/

        //使用Lambda表达式，简化匿名内部类
        Arrays.sort(arr,(Person o1,Person o2)->{
            return o1.getAge() - o2.getAge();
        });
        
        //遍历数组
        for (Person person : arr) {
            System.out.println(person);
        }
    }
}
```

### 14_Lambda表达式有参数有返回值的练习(自定义接口)

```java
package com.itheima10.demo06.Lambda;
/*
    给定一个计算器`Calculator`接口，内含抽象方法`calc`可以将两个int数字相加得到和值：
 */
public interface Calcultor {
    //定义一个计算两个int整数和的方法并返回结果
    public abstract int calc(int a,int b);
}
```

```java
package com.itheima10.demo06.Lambda;
/*
     需求：
     给定一个计算器`Calculator`接口，内含抽象方法`calc`可以将两个int数字相加得到和值：
     使用Lambda的**标准格式**调用`invokeCalc`方法，完成120和130的相加计算
 */
public class Demo01Calculator {
    public static void main(String[] args) {
        //调用invokeCacl方法，方法的参数是一个接口，可以使用匿名内部类
        invokeCacl(10,20,new Calcultor(){
            @Override
            public int calc(int a, int b) {
                return a + b;
            }
        });

        //使用Lambda表达式简化匿名内部类的书写
        invokeCacl(120,130,(int a,int b)->{
            return a + b;
        });
    }

    /*
        定义一个方法
        传递两个int类型的整数
        参数传递Calculator接口
        方法内部调永
     */

    public static void invokeCacl(int a,int b,Calcultor c){
        int sum = c.calc(a,b);
        System.out.println(sum);
    }
}
```

### 15_Lambda省略格式&Lambda使用前提

```java
//优化省略
new Thread(()-> System.out.println(Thread.currentThread().getName() + "新的线程创建了")).start();
```

```java
//优化省略
invokeCook(()-> System.out.println("吃饭喽"));
```

```java
//优化省略
Arrays.sort(arr,( o1, o2)-> o1.getAge() - o2.getAge());
```

```java
//优化省略
invokeCacl(120,130,( a, b)-> a + b);
```

Lambda的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意：

1. 使用Lambda必须具有接口，且要求**接口中有且仅有一个抽象方法**。
   无论是JDK内置的`Runnable`、`Comparator`接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda。
2. 使用Lambda必须具有**上下文推断**。
   也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。

> 备注：有且仅有一个抽象方法的接口，称为“**函数式接口**”。

```java
package com.itheima10.demo07.Lambda.Demo01;

import java.util.ArrayList;
import java.util.Arrays;

/*
    Lambda表达式：可推导，可省略
    凡是根据上下文推导出来的内容，都可以省略书写
    可以省略的内容：
        1.(参数列表)：括号中参数列表的数据类型，可以省略不写
        2.(参数列表)：括号中的参数如果只有一个，那么类型和()都可以省略
        3.{一些代码}：如果{}中的代码只有一行，无论是否有返回值，都可以省略({},return,分号)
        注意：要省略{}  return  ;必须一起省略
 */
public class ArraysList {
    public static void main(String[] args) {
        //JDK1.7版本之前，创建集合对象，必须把前后的泛型都写上
        ArrayList<String> list01 = new ArrayList<String>();

        //JDK1.7版本之后，=后边的泛型可以省略，后边的泛型可以根据前边的泛型推导出来
        ArrayList<String> list02 = new ArrayList<>();
    }
}
```

## 08_File类、递归

### 01_File类的概述



### 02file类的静态成员变量

```java
package com.itheima11.demo01.File;

import java.io.File;

/*
    java.io.File类
    java把电脑中的文件和文件夹（目录）封装为File类，我们可以使用File类对文件和文件夹进行操作
    我们可以使用File类的方法
        创建一个文件/文件夹
        删除文件/文件夹
        获取文件/文件夹
        判断文件/文件夹
        对文件夹进行遍历
        获取文件的大小
    File是一个与系统无关的类，任何的操作系统都可以使用这个类中的方法

    重点：记住三个单词
        file：文件
        directory：文件夹/目录
        path：路径
 */
public class Demo01File {
    public static void main(String[] args) {
        /*
            static String pathSeparator
            与系统有关的路径分隔符，为了方便，它被表示为一个字符串。
            static char pathSeparatorChar
            与系统有关的路径分隔符。
            static String separator
            与系统有关的默认名称分隔符，为了方便，它被表示为一个字符串。
            static char separatorChar
            与系统有关的默认名称分隔符。

            操作路径不能写死了
            c:\develop\a\a.txt  windows
            c:/develop/a/a.txt  linux
            "c:"+"File.separator"+"delelop"+"File.separator"+a+"File.separator"+"a.txt"
         */
        String pathSeparator = File.pathSeparator;
        System.out.println(pathSeparator);//路径分隔符 windows：分号；linux：冒号:

        String separator = File.separator;
        System.out.println(separator);//文件名称分隔符 windows：\反斜杠 linux：斜杠/
    }
}
```

### 03绝对路径和相对路径



### 04file类的构造方法

```java
package com.itheima11.demo01.File;

import java.io.File;

/*
    路径：
        绝对路径：是一个完整的路径
            以盘符开始的路径
            c:\\a.txt
        相对路径：是一个简化的路径
            相对于当前项目的根目录（D:\\IdeaProjects\\sy\\a.txt）
            如果使用当前项目的根目录，路径可以简化书写
            D:\\IdeaProjects\\sy\\a.txt-->简化为：a.txt(可以省略项目的根目录)
        注意：
            1.路径是不区分大小写的
            2.路径中的文件名称分隔符windows使用\反斜杠，反斜杠是转义字符，两个反斜杠代表一个普通的反斜杠
 */
public class Demo02File {
    public static void main(String[] args) {
        /*
            File类的构造方法
         */
        /*show02("c:\\","a.txt");
        show02("d:\\","a.txt");*/
        show03();
    }

    /*
        File(File parent, String child)
          根据 parent 抽象路径名和 child 路径名字符串创建一个新 File 实例。
        参数：把路径分为了两部分
            String parent父路径
            String child子路径
        好处：
            1.父路径和子路径，可以单独书写，使用起来非常灵活；父路径和子路径都可以变化
            2.父路径是File类型，可以使用File的方法对路径进行一些操作，再使用路径创建对象
     */
    private static void show03() {
        File parent = new File("c:\\");
        File file = new File(parent,"Hello.java");
        System.out.println(file);
    }

    /*
        File(String parent, String child)
          根据 parent 路径名字符串和 child 路径名字符串创建一个新 File 实例。
        参数：把路径分为了两部分
            String parent父路径
            String child子路径
        好处：
            父路径和子路径，可以单独书写，使用起来非常灵活；父路径和子路径都可以变化
     */
    private static void show02(String parent, String child) {
        File file = new File(parent, child);
        System.out.println(file);//c:\a.txt
    }

    /*
        File(String pathname)
          通过将给定路径名字符串转换为抽象路径名来创建一个新 File 实例。
        参数：
            String pathname：字符串的路径名称
            路径可以是以文件结尾，也可以是以文件夹结尾
            路径可以是相对路径，也可以是绝对路径
            路径可以是存在，也可以是不存在
            创建File对象，只是把字符串的路径封装为File对象，不考虑路径的真假情况
     */
    private static void show01() {
        File f1 = new File("c:\\User\\a.txt");
        System.out.println(f1);//重写了Object类的toString方法 c:\User\a.txt

        File f2 = new File("c:\\User\\");
        System.out.println(f1);//重写了Object类的toString方法 c:\User\a.txt

        File f3 = new File("b.txt");
        System.out.println(f3);//b.txt
    }
}
```

### 05file类获取功能的方法

```java
package com.itheima11.demo01.File;

import java.io.File;

/*
    -public String getAbsolutePath() ：返回此File的绝对路径名字符串。
    -public String getPath() ：将此File转换为路径名字符串。
    -public String getName() ：返回由此File表示的文件或目录的名称。
    -public long length() ：返回由此File表示的文件的长度。
 */
public class Demo03File {
    public static void main(String[] args){
        show04();
    }

    /*
        public long length() ：返回由此File表示的文件的长度。
        获取的是构造方法指定的文件的大小，以字节为单位
        注意：
            文件夹是没有大小概念的，不能获取文件夹的大小
            如果构造方法中给出的路径不存在，那么length方法返回0
     */
    private static void show04() {
        File f1 = new File("D:\\SQL\\08_File类、递归\\08_File类、递归.md");
        System.out.println(f1.length());//5553

        File f2 = new File("D:\\SQL\\08_File类、递归\\1.md");
        System.out.println(f2.length());//0
        
        File f3 = new File("C:\\app");
        System.out.println(f3.length());//0
    }

    /*
        public String getName() ：返回由此File表示的文件或目录的名称。
        获取的就是构造方法传递路径的结尾部分（文件/文件夹）
     */
    private static void show03() {
        File f1 = new File("E:\\2019JAVA\\2019新版JAVA\\Java新版\\02_java语言进阶\\day08_File类、递归\\video");
        System.out.println(f1.getName());//video

        File f2 = new File("E:\\2019JAVA\\2019新版JAVA\\Java新版\\02_java语言进阶\\day08_File类、递归\\video\\a.txt");
        System.out.println(f2.getName());//a.txt
    }

    /*
        public String getPath() ：将此File转换为路径名字符串。
        toString方法调用的就是getPath方法
        源码：
            public String toString() {
                return getPath();
            }
     */
    private static void show02() {
        File f1 = new File("E:\\2019JAVA\\2019新版JAVA\\Java新版\\02_java语言进阶\\day08_File类、递归\\video");
        File f2 = new File("a.txt");
        System.out.println(f1.getPath());
        System.out.println(f2.getPath());

        System.out.println(f1.toString());//直接打印对象名 E:\2019JAVA\2019新版JAVA\Java新版\02_java语言进阶\day08_File类、递归\video
    }

    /*
        public String getAbsolutePath() ：返回此File的绝对路径名字符串。
        获取的是构造方法中传递的路径
        无论路径是绝对的还是相对的，getAbsolutePath方法返回的都是绝对路径
     */
    private static void show01() {
        File f1 = new File("E:\\2019JAVA\\2019新版JAVA\\Java新版\\02_java语言进阶\\day08_File类、递归\\video");
        System.out.println(f1.getAbsolutePath());

        File f2 = new File("a.txt");
        System.out.println(f2.getAbsolutePath());
    }
}
```

### 06file类判断功能的方法

```java
package com.itheima11.demo01.File;

import java.io.File;

/*
    - public boolean exists() ：此File表示的文件或目录是否实际存在。
    - public boolean isDirectory() ：此File表示的是否为目录。
    - public boolean isFile() ：此File表示的是否为文件。
 */
public class Demo04File {
    public static void main(String[] args) {
        show02();
    }

    /*
        public boolean isDirectory() ：此File表示的是否为目录。
            用于判断构造方法中给定的路径是否以文件夹结尾
            是：true
            不是：false
        public boolean isFile() ：此File表示的是否为文件。
            用于判断构造方法中给定的路径是否以文件结尾
            是：true
            不是：false
        注意事项：
            电脑的硬盘中只有文件/文件夹，两个方法是互斥
            这两个方法使用前提，路径必须是存在的，否则都返回false
     */
    private static void show02() {
        File f1 = new File("E:\\2019JAVA\\exists");

        //不存在，就没有必要获取
        if (f1.exists()){
            System.out.println(f1.isDirectory());
            System.out.println(f1.isFile());
        }

        File f2 = new File("E:\\2019JAVA");
        if (f2.exists()){
            System.out.println(f2.isDirectory());//true
            System.out.println(f2.isFile());//false
        }

        File f3 = new File("D:\\IdeaProjects\\sy\\sy.iml");
        if (f2.exists()){
            System.out.println(f3.isDirectory());//false
            System.out.println(f3.isFile());//true
        }
    }

    /*
        public boolean exists() ：此File表示的文件或目录是否实际存在。
        用于判断构造方法中的路径是否存在
            存在：true
            不存在：false
     */
    private static void show01() {
        //绝对路径测试
        File f1 = new File("E:\\2019JAVA");
        System.out.println(f1.exists());//true

        File f2 = new File("E:\\2019JAVA\\exists");
        System.out.println(f2.exists());//false

        //相对路径测试
        File f3 = new File("exists.txt");//随便写的文件
        System.out.println(f3.exists());//false

        File f4 = new File("sy.iml");//当前项目所在路径D:\IdeaProjects\sy  存在的文件
        System.out.println(f4.exists());//true
    }
}
```

### 07ile类创建删除功能的方法

```java
package com.itheima11.demo01.File;

import java.io.File;
import java.io.IOException;

/*
    public boolean createNewFile() ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。
    public boolean delete() ：删除由此File表示的文件或目录。
    public boolean mkdir() ：创建由此File表示的目录。
    public boolean mkdirs() ：创建由此File表示的目录，包括任何必需但不存在的父目录。
 */
public class Demo05File {
    public static void main(String[] args) throws IOException {
        show03();
    }

    /*
         public boolean delete() ：删除由此File表示的文件或目录。
         此方法，可以删除构造方法中给出的文件/文件夹
         返回值：布尔值
            true：文件/文件夹删除成功，返回true
            false：文件夹中有内容，不会删除，返回false；构造方法中路径不存在false
         注意：
            delete方法是直接在硬盘删除文件/文件夹，不走回收站，谨慎使用
     */
    private static void show03() {
        File f1 = new File("srd\\111.txt");
        System.out.println("b1:"+f1.delete());//b1:true

        File f2 = new File("srd");
        System.out.println("b2:"+f2.delete());//b2:true
    }

    /*
    public boolean mkdir() ：创建由此File表示的目录。
    只能创建单级文件夹
    public boolean mkdirs() ：创建由此File表示的目录，包括任何必需但不存在的父目录。
    既可以创建单级文件夹，也可以创建多级文件夹
    创建文件的路径和名称在构造方法中给出（构造方法的参数）
        返回值：布尔值
            true：文件夹不存在，创建文件夹，返回true
            false：文件夹存在，不会创建，返回false；构造方法中给出的路径不存在也返回false
    注意：
            1.此方法只能创建文件夹，不能创建文件
    注：以上创建的文件夹都是空的
     */
    private static void show02() {
        File f1 = new File("src\\a");
        System.out.println("b1:" + f1.mkdir());//b1:true

        File f2 = new File("src\\1\\2\\3");
        System.out.println("b2:"+f2.mkdirs());//b2:true

        File f3 = new File("src\\1\\2\\3\\123.txt");
        System.out.println("b3:"+f3.mkdirs());//创建的是文件夹

        File f4 = new File("srd\\111");
        System.out.println("b4:"+f4.mkdirs());//true路径不存在，创建路径和文件夹
    }

    /*
        public boolean createNewFile() ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。
        创建文件的路径和名称在构造方法中给出（构造方法的参数）
        返回值：布尔值
            true：文件不存在，创建文件，返回true
            false：文件存在，不会创建，返回false
        注意：
            1.此方法只能创建文件，不能创建文件夹
            2.创建文件的路径必须存在，否则会抛出异常
        public boolean createNewFile() throws IOException
        createNewFile声明抛出了IOException，我们调用这个方法，就必须处理这个异常，要么throws要么try catch
     */
    private static void show01() throws IOException {
        File f1 = new File("D:\\IdeaProjects\\sy\\src\\com\\itheima11\\1.txt");
        boolean b1 = f1.createNewFile();
        System.out.println("b1:"+b1);//true

        File f2 = new File("2.txt");//相对路径
        System.out.println("b2:"+f2.createNewFile());//true

        File f3 = new File("D:\\IdeaProjects\\sy\\src\\com\\itheima11\\1");//相对路径
        System.out.println("b3:"+f3.createNewFile());//不能创建文件夹

        File f4 = new File("srd\\1.txt");//写错路径
        System.out.println("b4:"+f4.createNewFile());//路径不存在，java.io.IOException
    }
}
```

### 08file类遍历（文件夹）目录功能

```java
package com.itheima11.demo01.File;

import java.io.File;

/*
     *  public String[] list() ：返回一个String数组，表示该File目录中的所有子文件或目录。
     *  public File[] listFiles() ：返回一个File数组，表示该File目录中的所有的子文件或目录。
     * 注意：
     *     list方法和List方法遍历的是构造方法中给出的目录
     *     如果构造方法中给出的目录的路径不存在，会抛出空指针异常
     *     如果构造方法中给出的路径不是一个目录，也会抛出空指针异常
     */
public class Demo06File {
        public static void main(String[] args) {
            show02();
        }

    /*
        public File[] listFiles() ：返回一个File数组，表示该File目录中的所有的子文件或目录。
        遍历构造方法中给出的目录，会获取目录中所有文件/文件夹,把文件/文件夹封装为对象，多个File对象，存储到File数组中
    */
    private static void show02() {
        File f1 = new File("D:\\IdeaProjects\\sy\\src\\com\\itheima11\\demo01\\File");
        File[] files = f1.listFiles();
        for (File file : files) {
            System.out.println(file);
            /*D:\IdeaProjects\sy\src\com\itheima11\demo01\File\Demo01File.java
            D:\IdeaProjects\sy\src\com\itheima11\demo01\File\Demo02File.java
            D:\IdeaProjects\sy\src\com\itheima11\demo01\File\Demo03File.java
            D:\IdeaProjects\sy\src\com\itheima11\demo01\File\Demo04File.java
            D:\IdeaProjects\sy\src\com\itheima11\demo01\File\Demo05File.java
            D:\IdeaProjects\sy\src\com\itheima11\demo01\File\Demo06File.java*/
        }
    }

    /*
        public String[] list() ：返回一个String数组，表示该File目录中的所有子文件或目录。
        遍历构造方法中给出的目录，会获取目录中所有文件/文件夹的名称，把获取到的多个名称存储到一个String类型的数组中。
     */
        private static void show01() {
            //File f1 = new File("D:\\IdeaProjects\\sy\\src\\com\\itheima11\\demo01\\File\\1.txt");//java.lang.NullPointerException
            //File f1 = new File("D:\\IdeaProjects\\src\\com\\itheima11\\demo01\\File");//java.lang.NullPointerException
            File f1 = new File("D:\\IdeaProjects\\sy\\src\\com\\itheima11\\demo01\\File");
            String[] arr = f1.list();
            for (String fileName : arr) {
                System.out.println(fileName);
                /*Demo01File.java
                Demo02File.java
                Demo03File.java
                Demo04File.java
                Demo05File.java
                Demo06File.java*/
            }
        }
    }
```

### 09递归概念&分类&注意事项

![01_递归导致栈内存溢出的原理](C:/Users/Murphy/Pictures/01_递归导致栈内存溢出的原理.bmp)

```java
package com.itheima11.demo02.Recursion;

/*
    * **递归**：指在当前方法内调用自己的这种现象。

    * **递归的分类:**
     - 递归分为两种，直接递归和间接递归。
     - 直接递归称为方法自身调用自己。
     - 间接递归可以A方法调用B方法，B方法调用C方法，C方法调用A方法。

    注意事项：
     - 递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。
     - 在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。
     - 构造方法,禁止递归
    递归的使用前提：
        当调用方法的时候，方法的主体不变，每次调用方法的参数不同，可以使用递归
 */
public class Demo01Recursion {
    public static void main(String[] args) {
//        a();
        b(1);
    }

    /*构造方法,禁止递归
        构造方法是创建对象使用的，一直递归会导致内存中有无数多个对象，直接编译报错
     */

    public Demo01Recursion() {
        //Demo01Recursion();
    }

    //在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。
    private static void b(int i) {
        System.out.println(i);
        if (i == 20000) {
            return;//结束方法
        }
        b(++i);
    }

    //递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。
    private static void a() {
        System.out.println("a方法！");
        a();
    }
}
```

### 10练习使用递归计算1-n之间的和

![02_递归求和的原理](C:/Users/Murphy/Pictures/02_递归求和的原理.bmp)

```java
package com.itheima11.demo02.Recursion;
/*
    练习：使用递归计算1-n之间的和
 */
public class Demo02Recursion {
    public static void main(String[] args) {
        int s = sum(3);
        System.out.println(s);
    }

    /*
        定义一个方法，使用递归计算1-n之间的和
        1+2+...+n
        n+(n-1)+(n-2)+...+1
        已知：
            最大值n
            最小值1
        使用递归必须明确：
            1.递归的结束条件
                获取到1的时候结束
            2.递归的目的
                获取到下一个被加的数字（n-1）
     */
    public static int sum(int n){
        //获取到1的时候结束
        if (n == 1) {
            return 1;
        }

        //获取下一个被加的数字(n-1)
        return n + sum(n-1);
    }
}
```

### 11练习使用递归计算阶乘

```java
package com.itheima11.demo02.Recursion;
/*
    练习：
        使用递归计算阶乘
        n的阶乘：n! = n * (n-1) *...* 3 * 2 * 1
 */
public class Demo03Recursion {
    public static void main(String[] args){
        int i = jc(5);
        System.out.println(i);
    }
    /*
        定义方法使用递归计算阶乘
        递归结束的条件
            获取到1的时候结束
        递归的目的：
            获取下一个被乘的数字（n-1）
        方法的参数发生变化
     */
    public static int jc(int n){
         //获取到1的时候结束
        if (n == 1) {
            return 1;
        }
        return n * jc(n-1);
    }
}
```

### 12练习递归打印多级目录

![03_递归遍历多级目录](C:/Users/Murphy/Pictures/03_递归遍历多级目录.bmp)

```java
package com.itheima11.demo02.Recursion;

import java.io.File;

/*
    练习：
    递归打印多级目录
 */
public class Demo04Recursion {
    public static void main(String[] args) {
        File file = new File("D:\\IdeaProjects");
        getAllFile(file);
    }

    /*
        定义一个方法，参数传递File类型的目录
        方法中对目录进行遍历
     */
    public static void getAllFile(File dir) {
        System.out.println(dir);//打印被遍历的目录名称
        File[] files = dir.listFiles();
        for (File f : files) {
            //对得到的File对象进行判断，判断是否是文件夹
            if (f.isDirectory()) {
                //f是一个文件夹，则遍历这个文件夹
                getAllFile(f);
            } else {
                System.out.println(f);
            }
        }
    }
}
```

### 13综合案例文件搜索

```java
package com.itheima11.demo02.Recursion;

import java.io.File;

public class Demo05Recursion {
    /*
        练习:
            递归打印多级目录
        需求:
            遍历c:\\abc文件夹,及abc文件夹的子文件夹
            只要.java结尾的文件
            c:\\abc
            c:\\abc\\abc.txt
            c:\\abc\\abc.java
            c:\\abc\\a
            c:\\abc\\a\\a.jpg
            c:\\abc\\a\\a.java
            c:\\abc\\b
            c:\\abc\\b\\b.java
            c:\\abc\\b\\b.txt
     */
    public static void main(String[] args) {
        File file = new File("E:\\2019JAVA\\2019新版JAVA\\Java新版\\02_java语言进阶\\day08_File类、递归\\code\\08_FileAndRecursion\\src\\com\\itheima\\demo02\\Recursion");
        getAllFile(file);
    }

    /*
        定义一个方法,参数传递File类型的目录
        方法中对目录进行遍历
     */
    public static void getAllFile(File dir) {
        //System.out.println(dir);//打印被遍历的目录名称
        File[] files = dir.listFiles();
        for (File f : files) {
            //对遍历得到的File对象f进行判断,判断是否是文件夹
            if (f.isDirectory()) {
                //f是一个文件夹,则继续遍历这个文件夹
                //我们发现getAllFile方法就是传递文件夹,遍历文件夹的方法
                //所以直接调用getAllFile方法即可:递归(自己调用自己)
                getAllFile(f);
            } else {
                //f是一个文件,直接打印即可
                /*
                    c:\\abc\\abc.java
                    只要.java结尾的文件
                    1.把File对象f,转为字符串对象
                 */
                //String name = f.getName();//abc.java
                //String path = f.getPath();//c:\\abc\\abc.java
                //String s = f.toString();//c:\\abc\\abc.java

                //把字符串,转换为小写
                //s = s.toLowerCase();

                //2.调用String类中的方法endsWith判断字符串是否是以.java结尾
                //boolean b = s.endsWith(".java");

                //3.如果是以.java结尾的文件,则输出
                /*if(b){
                    System.out.println(f);
                }*/

                if (f.getName().toLowerCase().endsWith(".java")) {
                    System.out.println(f);
                }
            }
        }
    }
}
```

### 14 FileFilter过滤器的原理和使用

![04_FileFilter过滤器的原理](C:/Users/Murphy/Pictures/04_FileFilter过滤器的原理.bmp)

```java
package com.itheima11.Demo03;

import java.io.File;

/*
    可以使用过滤器来实现
    在File类中有两个和ListFile重载的方法，方法的参数传递的就是过滤器
     File[] listFiles(FileFilter filter)
     java.io.FileFilter接口：用于抽象路径名（Filed对象）的过滤器
        用来过滤文件（File对象）
        抽象方法：用来过滤文件的方法
            boolean accept(File pathname)测试指定抽象路径名是否应该包含在某个路径名列表中。
            参数：
                File pathname：使用lidtFiles方法遍历目录，得到的每一个文件对象
     File[] listFiles(FilenameFilter filter)
     java.io.FilenameFilter接口：实现此接口的类实例可用于过滤器文件名。
        作用：用于过滤文件名称
        抽象方法：用来过滤文件的方法
            boolean accept(File dir, String name) 测试指定文件是否应该包含在某一文件列表中。
            参数：
                File dir:构造方法中传递的被遍历的目录
                String name：使用ListFiles方法遍历目录，获取的每一个文件/文件夹的名称
     注意：
        两个过滤器的接口是没有实现类的，需要我们自己写实现类，重写过滤的方法accept，在方法中定义过滤的规则
 */
public class Demo01Filter {
    public static void main(String[] args) {
        File file = new File("D:\\IdeaProjects");
        getAllFile(file);
    }

    /*
        定义一个方法，参数传递File类型的目录
        方法中对目录进行遍历
     */
    public static void getAllFile(File dir) {
        System.out.println(dir);//打印被遍历的目录名称
        File[] files = dir.listFiles(new FileFilterImpl());
        for (File f : files) {
            //对得到的File对象进行判断，判断是否是文件夹
            if (f.isDirectory()) {
                //f是一个文件夹，则遍历这个文件夹
                getAllFile(f);
            } else {
                System.out.println(f);
            }
        }
    }
}
```

```java
package com.itheima11.Demo03;

import java.io.File;
import java.io.FileFilter;

/*
    创建过滤器FileFilter的实现类，重写过滤方法accept，定义过滤规则
 */
public class FileFilterImpl implements FileFilter {
    @Override
    public boolean accept(File pathname) {
        /*
            过滤的规则：
            在 accept方法中，判断File对象是否是以.java结尾
            是就返回true
            不是就返回 false
         */
        //如果pathname是一个文件夹，返回true，继续遍历这个文件夹
        if (pathname.isDirectory()) {
            return true;
        }
        return pathname.getName().toLowerCase().endsWith(".java");
    }
}
```

### 15_FileNameFilter过滤器的使用和Lambda优化程序

```java
package com.itheima11.Demo03;

import java.io.File;
import java.io.FileFilter;
import java.io.FilenameFilter;

public class Demo02Filter {
    public static void main(String[] args) {
        File file = new File("D:\\IdeaProjects");
        getAllFile(file);
    }

    /*
        定义一个方法，参数传递File类型的目录
        方法中对目录进行遍历
     */
    public static void getAllFile(File dir) {
        //传递过滤器对象 使用匿名内部类
        /*File[] files = dir.listFiles(new FileFilter() {
            @Override
            public boolean accept(File pathname) {
                //过滤规则，是pathname或者是.java结尾的文件返回true
                return pathname.isDirectory()||pathname.getName().toLowerCase().endsWith(".java");
            }
        });*/

        /*File[] files = dir.listFiles(new FilenameFilter() {
            @Override
            public boolean accept(File dir, String name) {
                //过滤规则，是pathname或者是.java结尾的文件返回true
                return new File(dir,name).isDirectory()||name.toLowerCase().endsWith(".java");
            }
        });*/

        //使用Lambda表达式优化匿名内部类（接口中只有一个抽象方法）
        /*File[] files = dir.listFiles((File pathname) -> {
            return pathname.isDirectory() || pathname.getName().toLowerCase().endsWith(".java"));
        });*/

        File[] files = dir.listFiles(pathname -> pathname.isDirectory() || pathname.getName().toLowerCase().endsWith(".java"));

        //使用Lambda表达式优化匿名内部类（接口中只有一个抽象方法）
        /*File[] files = dir.listFiles((File d, String name)->{
            return new File(d,name).isDirectory()||name.toLowerCase().endsWith(".java");
        });*/

        //File[] files = dir.listFiles((d, name) -> new File(d, name).isDirectory() || name.toLowerCase().endsWith(".java"));

        for (File f : files) {
            //对得到的File对象进行判断，判断是否是文件夹
            if (f.isDirectory()) {
                //f是一个文件夹，则遍历这个文件夹
                getAllFile(f);
            } else {
                System.out.println(f);
            }
        }
    }
}
```

## 09_字节流、字符流

### 01概述（概念&分类）

### 02一切皆为字节

### 03字节输出流 OutputStream类&FileOutpu类介绍

### 04字节输出流写入数据到文件

```java
package com.itheima12.demo01.OutputStream;

import java.io.FileOutputStream;
import java.io.IOException;

/*
    java.io.OutputStream:字节输出流
        此抽象类是表示输出字节流的所有类的超类。

    定义的一些子类共性的成员方法：
        public void close() ：关闭此输出流并释放与此流相关联的任何系统资源。
        public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。
        public void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流。
        public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。
        public abstract void write(int b) ：将指定的字节输出流。

    java.io.FileOutputStream entends OutputStream
    FileOutputStream:文件字节输出流
    作用：把内存中的数据写入到硬盘的文件中

    构造方法：
        FileOutputStream(String name)创建一个向具有指定名称的文件中写入数据的输出文件流。
        FileOutputStream(File file)创建一个向指定 File 对象表示的文件中写入数据的文件输出流。
        参数：
            String name：目的地是一个文件的路径
            File file：目的地是一个文件
        构造方法的作用：
            1.创建一个FileOutputStream对象
            2.会根据构造方法中传递的文件/文件路径，创建一个空的文件
            3.会把FileOutputStream对象指向创建好的文件
     写入数据的原理：（内存--硬盘）
        java程序-->JVM（java虚拟机）-->OS（操作系统）-->OS调用写数据的方法-->把数据写到文件中

     字节输出流的使用步骤（重点）：
        1.创建一个FileOutputStream对象，构造方法中传递写入数据的目的地
        2.调用FileOutputStream对象中的方法write，把数据写入到文件中
        3.释放资源（流使用会占用一定内存，使用完毕要把内存清空，提高程序的效率）
 */
public class Demo01OutputStream {
    public static void main(String[] args) throws IOException {
        //1.创建一个FileOutputStream对象，构造方法中传递写入数据的目的地
        FileOutputStream fos = new FileOutputStream("D:\\IdeaProjects\\sy\\src\\com\\itheima12\\demo01\\OutputStream\\a.txt");
        // 2.调用FileOutputStream对象中的方法write，把数据写入到文件中
        //public abstract void write(int b) ：将指定的字节输出流。
        fos.write(97);
        //3.释放资源（流使用会占用一定内存，使用完毕要把内存清空，提高程序的效率）
        fos.close();
    }
}
```

### 05文件存储的原理和记事本打开文件的原理

![02_文件存储的原理和记事本打开文件的原理](C:/Users/Murphy/Pictures/02_文件存储的原理和记事本打开文件的原理.bmp)

### 06字节输出流写多个字节的方法

```java
package com.itheima12.demo01.OutputStream;

import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.util.Arrays;

/*
    public void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流。
    public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。
 */
public class Demo02OutputStream {
    public static void main(String[] args) throws IOException {
        //创建FileOutputStream对象，构造方法中绑定要写入数据的目的地
        OutputStream fos = new FileOutputStream("D:\\IdeaProjects\\sy\\src\\com\\itheima12\\demo01\\OutputStream\\b.txt");

        //调用FIleOutputStream对象中的方法write，把数据写入到文件中。
        //在文件中显示100.写  个字节
        fos.write(49);
        fos.write(48);
        fos.write(48);

        /*
            public void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流。
            一次写多个字节：
                如果写的第一个字节是正数，那么显示的时候会查询ASCII表
                如果写的第一个字节试试负数，那么第一个字节会和第二个字节，两个字节组成一个中文显示，查询系统默认编码表（GBK）
         */
        byte[] bytes = {65,66,67,68,69};//ABCDE
        //byte[] bytes = {-65,-66,-67,68,69};//100烤紻E
        fos.write(bytes);

        /*
            public void write(byte[] b, int off, int len) ：把字节数组的一部分写入到文件中
                int off：数组的开始索引
                int len：写几个字节
                从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。
         */
        fos.write(bytes,1,2);//100ABCDEBC

        /*
            写入字符串的方法，可以使用String类中的方法把字符串，转换为字节数组
                 byte[] getBytes() 把字符串转换为字节数组
         */
        byte[] bytes2 = "你好".getBytes();
        System.out.println(Arrays.toString(bytes2));//[-28, -67, -96, -27, -91, -67]
        fos.write(bytes2);//100ABCDEBC你好

        //释放资源
        fos.close();
    }
}
```

### 07字节输出流的续写和换行

```java
package com.itheima12.demo01.OutputStream;

import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;

/*
    追加写/续写：使用两个参数的构造方法
    FileOutputStream(String name, boolean append)创建一个向具有指定 name 的文件中写入数据的输出文件流。
    FileOutputStream(File file, boolean append)创建一个向指定 File 对象表示的文件中写入数据的文件输出流。
    参数：
        String name,File file：写入数据的目的地
        boolean append：追加写开关
            true：创建对象不会覆盖原文件，继续在问价的末尾追加写数据
            false：创建一个新文件，覆盖原文件
        写换行：写换行符号
        windows：\r\n
        linux:/n
        mac:/r
 */
public class Demo03OutputStream {
    public static void main(String[] args) throws IOException {
        FileOutputStream fos = new FileOutputStream("D:\\IdeaProjects\\sy\\src\\com\\itheima12\\demo01\\OutputStream\\c.txt", true);
        for (int i = 1; i <= 10; i++){
            fos.write("你好".getBytes());
            fos.write("\r\n".getBytes());
        }
        fos.close();
    }
}
```

### 08字节输 InputStream入流类&FileInputStre类介绍

### 09字节输入流读取字节数据

```java
package com.itheima12.demo02.InputStream.Demo01;

import java.io.FileInputStream;
import java.io.IOException;

/*
    java.io.InputStream：字节输入流
    此抽象类是表示字节输入流的所有类的超类。

    定义了所有子类共性的方法：
        int read()从输入流中读取数据的下一个字节。
        int read(byte[] b)从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。
        void close()关闭此输入流并释放与该流关联的所有系统资源。

    java.io.FileInoutStream extends InputStream
    FileInputStream：文件字节输入流
    作用：把硬盘文件中的数据，读取到内存中使用

    构造方法：
        FileInputStream(String name)
          通过打开一个到实际文件的连接来创建一个 FileInputStream，该文件通过文件系统中的路径名 name 指定。
        FileInputStream(File file)
          通过打开一个到实际文件的连接来创建一个 FileInputStream，该文件通过文件系统中的 File 对象 file 指定。
        参数：读取文件的数据源
            String name文件的路径
            File file：文件
        构造方法的作用：
            1.会创建一个FileInputStream对象
            2.会把FileInputStream对象指定构造方法中要读取的文件
    读取数据的原理（硬盘-->内存）
        java程序-->JVM-->OS-->OS读取数据的方法-->读取文件

    字节输入流的使用步骤（重点）：
        1.创建FileInputStream对象，构造方法中绑定要读取的数据源
        2.使用FileInputStream对象中的方法read，读取文件
        3.释放资源
 */
public class InputStream {
    public static void main(String[] args) throws IOException {
        //1.创建FileInputStream对象，构造方法中绑定要读取的数据源
        FileInputStream fis = new FileInputStream("D:\\IdeaProjects\\sy\\src\\com\\itheima12\\demo01\\OutputStream\\a.txt");
        //2.使用FileInputStream对象中的方法read，读取文件
        //int read()读取文件中的一个字节并返回，读取到文件的末尾返回-1
/*        int len = fis.read();
        System.out.println(len);//97

        len = fis.read();
        System.out.println(len);//98

        len = fis.read();
        System.out.println(len);//99

        len = fis.read();
        System.out.println(len);//-1*/

        /*
            以上读取文件是一个重复的过程，所以可以使用循环优化
            不知道文件中有多少字节，使用while循环
            while循环结束条件，读取到-1的时候结束

            布尔表达式(len = fis.read())!=-1
                1.fis.read():读取一个字节
                2.len = fis.read()：把读取到的字节复制给变量len
                3.(len = fis.read())!=-1：判断变量len是否不等于-1
         */

        int len = 0;//记录读取到的字节
        while ((len = fis.read())!=-1){
            System.out.print((char) len);//abc
        }
        //3.释放资源
        fis.close();
    }
}
```

### 10字节输入流一次读取一个字节的原理

![03_字节流读取文件的原理](C:/Users/Murphy/Pictures/03_字节流读取文件的原理.bmp)

### 11字节输入流一次读取多个字节

```java
package com.itheima12.demo02.InputStream.Demo01;

import java.io.FileInputStream;
import java.io.IOException;
import java.util.Arrays;

/*
    字节输入流一次读取多个字节的方法：
        int read(byte[] b)从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。
    明确两件事情：
        1.方法的参数byte[] 的作用
            起到缓冲作用，存储每次取到的多个字节
            数组的长度，一般定义为1024（1kb）或者1024的整数倍
        2.方法的返回值int是什么
        每次读取的有效字节个数

    String类的构造方法
        String(byte[] bytes) ：把字节数组转换为字符串
        String(byte[] bytes, int offset, int length) ：把字节数组的一部分转换为字符串 offset：数组的开始索引 length：转换的字节个数
 */
public class Demo02InputStream {
    public static void main(String[] args) throws IOException {
        //创建FileInputStream对象，构造方法中绑定要读取的数据源
        FileInputStream fis = new FileInputStream("D:\\IdeaProjects\\sy\\src\\com\\itheima12\\demo01\\OutputStream\\b.txt");
        //使用FileInputStream对象中的方法read读取文件
        //int read(byte[] b)从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。
        /*byte[] bytes = new byte[2];
        int len = fis.read(bytes);
        System.out.println(len);//2
        System.out.println(Arrays.toString(bytes));//[49, 48]
        System.out.println(new String(bytes));//AB

        len = fis.read(bytes);
        System.out.println(len);//2每次读取的字节的个数
        System.out.println(new String(bytes));//CD

        len = fis.read(bytes);
        System.out.println(len);//1
        System.out.println(new String(bytes));//ED

        len = fis.read(bytes);
        System.out.println(len);//-1
        System.out.println(new String(bytes));//ED
        */

        //发现以上读取是一个重复的过程，可以使用循环优化
        //不知道文件中有多少字节，所以使用while循环
        //while循环结束的条件，读取到-1结束

        byte[] bytes = new byte[1024];//存储读取到的多个字节
        int len = 0;//记录每次读取的有效字节个数
        while ((len = fis.read(bytes))!=-1){
            //String(byte[] bytes, int offset, int length) ：把字节数组的一部分转换为字符串 offset：数组的开始索引 length：转换的字节个数
            System.out.println(new String(bytes,0,len));
        }

        //释放资源
        fis.close();
    }
}
```

### 12练习文件复制

```java
package com.itheima12.demo03.CopyFile;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

/*
    文件复制练习：一读一写
    明确：
        数据源：c:\\1.jpg
        数据目的地：d:\\1.jpg
    文件复制的步骤：
        1.创建一个字节输入流对象，构造方法中绑定要读取的数据源
        2.创建一个字节输出流对象，构造方法中绑定要写入的目的地
        3.使用字节输入流的方法read读取文件
        4.使用字节输出流的方法write，把读取到的字节写入到目的地的文件中
        5.释放资源
 */
public class Demo01CopyFile {
    public static void main(String[] args) throws IOException {
        long s = System.currentTimeMillis();
        //1.创建一个字节输入流对象，构造方法中绑定要读取的数据源
        FileInputStream fis = new FileInputStream("c:\\1.jpg");
        // 2.创建一个字节输出流对象，构造方法中绑定要写入的目的地
        FileOutputStream fos = new FileOutputStream("d:\\1.jpg");
        //读取一个字节，写入一个字节的方式
        //3.使用字节输入流的方法read读取文件
       /* int len = 0;
        while ((len = fis.read())!=-1){
            //4.使用字节输出流的方法write，把读取到的字节写入到目的地的文件中
            fos.write(len);
        }*/
        //使用数组缓冲读取多个字节，写入多个字节
        byte[] bytes = new byte[2048];
        int len = 0;//每次读取的有效字节个数
        while ((len = fis.read(bytes))!=-1){
            //4.使用字节输出流的方法write，把读取到的字节写入到目的地的文件中
            fos.write(bytes,0,len);
        }

        //5.释放资源(先关闭写按钮，后关闭读按钮)
        fos.close();
        fis.close();
        long e = System.currentTimeMillis();
        System.out.println("复制文件共耗时"+(e-s)+"毫秒");
    }
}
```

### 13使用字节流读取中文的问题

### 14字符输入流 Reader类&FileReader类介绍

### 15字符输入流读取字符数据

```java
package com.itheima12.demo04.Reader;

import java.io.FileReader;
import java.io.IOException;

/*
    java.io.Reader：字符输入流，是字符输入流的最顶层的父类，定义了一些共性的成员方法，是一个抽象类

    共性的成员方法：
        int read() 读取单个字符并返回。
        int read(char[] cbuf) 一次读取多个字符，将字符读入数组。
        abstract  void close() 关闭该流并释放与之关联的所有资源。

    java.io.FileReader extends InputStreamReader entends Reader
    FileReader：文件字符输入流
    作用：把硬盘文件中的数据以字符的形式读取到内存中

    构造方法：
        FileReader(String fileName)
        FileReader(File file)
        参数：读取文件的数据源
            String fileName：文件的路径
            File file：一个文件
        FileReader构造方法的作用：
            1.创建一个FileReader对象
            2.会把FileReader对象指向我们要读取的文件
    字符输入流的使用步骤：
        1.创建FileReader对象，构造方法中绑定要读取的数据源
        2.使用FileReader对象中的方法read读取文件
        3.释放资源
 */
public class Demo02Reader {
    public static void main(String[] args) throws IOException {
        //1.创建FileReader对象，构造方法中绑定要读取的数据源
        FileReader fr = new FileReader("D:\\IdeaProjects\\sy\\src\\com\\itheima12\\demo01\\OutputStream\\c.txt");
        //2.使用FileReader对象中的方法read读取文件
        //int read() 读取单个字符并返回。
        /*int len = 0;
        while ((len = fr.read())!=-1){
            System.out.print((char) len);//你好你好你好abc,.+
        }*/

        //int read(char[] cbuf) 一次读取多个字符，将字符读入数组。
        char[] chars = new char[1024];//存储读取到的多个字符
        int len = 0;//记录的是每次读取到的有效字符个数
        while ((len = fr.read(chars)) != -1) {
            /*
                String类的构造方法
                String(char[] value)把字符数组转换为字符串
                String(char[] value, int offset, int count)把字符数组的一部分转换为字符串 offset数组的开始索引 count转换的个数
             */
            System.out.println(new String(chars,0,len));
        }

        //3.释放资源
        fr.close();
    }
}
```

### 16字符输出流 Writer类&FileWriter类介绍

### 17字符输出流的基本使用写出单个字符到文件

```java
package com.itheima12.demo05.Writer;

import java.io.FileWriter;
import java.io.IOException;

/*
    java.io.Writer字符输出流，是所有字符输出流最顶层的父类，是一个抽象类
    void write(int c) 写入单个字符。
    void write(char[] cbuf) 写入字符数组。
    abstract  void write(char[] cbuf, int off, int len) 写入字符数组的某一部分,off数组的开始索引,len写的字符个数。
    void write(String str) 写入字符串。
    void write(String str, int off, int len) 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。
    void flush() 刷新该流的缓冲。
    void close() 关闭此流，但要先刷新它。

    java.io.FileWriter extends OutputStreamWriter extends Writer
    FileWriter：文件字符输出流
    作用：把内存中字符数据写入到文件中

    构造方法
    FileWriter(File file)根据给定的 File 对象构造一个 FileWriter 对象。
    FileWriter(String fileName)根据给定的文件名构造一个 FileWriter 对象。
    参数：写入数据的目的地
        String fileName文件的路径
        File file是一个文件
    构造方法的作用
        1.会创建一个FileWriter文件
        2.会根据构造方法中传递的文件/文件的路径，创建文件
        3.会把FileWriter对象指向创建好的文件
    字符输出流的使用步骤（重点）：
        1.创建FileWriter对象，构造方法中绑定要写入数据的目的地
        2.使用FIleWriter中的方法writer，把数据写入到内存缓冲区中（字符转换为字节的过程）
        3.使用FileWriter中的方法flush，把内存缓冲区中的数据，刷新到文件中
        4.释放资源（会把内存缓冲区中的数据刷新到文件中）
 */
public class Demo01Writer {
    public static void main(String[] args) throws IOException {
        //1.创建FileWriter对象，构造方法中绑定要写入数据的目的地
        FileWriter fw = new FileWriter("D:\\IdeaProjects\\sy\\src\\com\\itheima12\\demo05\\Writer\\d.txt");
        // 2.使用FIleWriter中的方法writer，把数据写入到内存缓冲区中（字符转换为字节的过程）
        //写入单个字符
        fw.write(97);
        //3.使用FileWriter中的方法flush，把内存缓冲区中的数据，刷新到文件中
        //fw.flush();
        //4.释放资源（会把内存缓冲区中的数据刷新到文件中）
        fw.close();
    }
}
```

### 18 flushclose方法和方法的区别

```java
package com.itheima12.demo05.Writer;

import java.io.FileWriter;
import java.io.IOException;

/*
    flush方法和close方法的区别
    flush ：刷新缓冲区，流对象可以继续使用。
    close :先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。
 */
public class Demo02ClosseAndFlush {
    public static void main(String[] args) throws IOException {
        //1.创建FileWriter对象，构造方法中绑定要写入数据的目的地
        FileWriter fw = new FileWriter("D:\\IdeaProjects\\sy\\src\\com\\itheima12\\demo05\\Writer\\e.txt");
        // 2.使用FIleWriter中的方法writer，把数据写入到内存缓冲区中（字符转换为字节的过程）
        //写入单个字符
        fw.write(97);
        //3.使用FileWriter中的方法flush，把内存缓冲区中的数据，刷新到文件中
        fw.flush();
        //刷新之后流可以继续使用
        fw.write(98);

        //4.释放资源（会把内存缓冲区中的数据刷新到文件中）
        fw.close();

        //close方法之后流已经关闭了，已经从内存中消失了，流就不能再使用了
        fw.write(98);//异常Stream closed
    }
}
```

### 19字符输出流写数据的其他方法

```java
package com.itheima12.demo05.Writer;

import java.io.FileWriter;
import java.io.IOException;

/*
    字符输出流写数据的其他方法
    void write(char[] cbuf) 写入字符数组。
    abstract void write(char[] cbuf, int off, int len) 写入字符数组的某一部分,off数组的开始索引,len写的字符个数。
    void write(String str) 写入字符串。
    void write(String str, int off, int len) 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。
 */
public class Demo03Writer {
    public static void main(String[] args) throws IOException {
        FileWriter fw = new FileWriter("D:\\IdeaProjects\\sy\\src\\com\\itheima12\\demo05\\Writer\\f.txt");
        //void write(char[] cbuf) 写入字符数组。
        char[] chars = {'a','b','c','d','e'};
        fw.write(chars);

        //void write(char[] cbuf, int off, int len) 写入字符数组的某一部分,off数组的开始索引,len写的字符个数。
        fw.write(chars,1,3);//bcd

        //void write(String str) 写入字符串。
        fw.write("你好啊测试");

        //void write(String str, int off, int len) 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。
        fw.write("开始吧格斗",3,2);

        fw.close();
    }
}
```

### 20字符输出流的续写和换行

```java
package com.itheima12.demo05.Writer;

import java.io.FileWriter;
import java.io.IOException;

/*
    续写和换行写
    续写，追加写：使用两个参数的构造方法
        FileWriter(String fileName, boolean append)
        FileWriter(File file, boolean append)
        参数：
            String fileName，File file写入数据的目的地
            boolean append续写开关 true 不会创建新的文件覆盖文件； false创建新的文件覆盖源文件
        换行：换行符号
            windows \r\n
            linux /n
            mac /r
 */
public class Demo04Writer {
    public static void main(String[] args) throws IOException {
        FileWriter fw = new FileWriter("D:\\IdeaProjects\\sy\\src\\com\\itheima12\\demo05\\Writer\\g.txt",true);
        for (int i = 0; i < 10; i++) {
            fw.write("Hello Word!"+i+"\r\n");
        }

        fw.close();
    }
}
```

### 21使用 trycatchfinally处理流中的异常

```java
package com.itheima12.demo06.trycatch;

import java.io.FileWriter;
import java.io.IOException;

/*
    在jdk1.7之前使用try catch finally处理流中的异常
    格式：
        try{
            可能会产生异常的代码
        }catch(){
            异常的处理逻辑
        }finally{
            一定会执行的代码
            资源释放
        }
 */
public class Demo01TryCatch {
    public static void main(String[] args) {
        //提高变量fw的作用域，让finally可以使用
        //变量在定义的时候，可以没有值，但是使用的时候必须有值
        //fw = new FileWriter("D:\\IdeaProjects\\sy\\src\\com\\itheima12\\demo05\\Writer\\g.txt",true);执行失败，fw没有值，fw.close就会报错
        FileWriter fw = null;
        try {
            fw = new FileWriter("w:\\IdeaProjects\\sy\\src\\com\\itheima12\\demo05\\Writer\\g.txt", true);
            for (int i = 0; i < 10; i++) {
                fw.write("Hello Word!" + i + "\r\n");
            }
        } catch (IOException e) {
            //异常的处理逻辑
            System.out.println(e);
        } finally {
            //一定会执行的代码
            //创建对象失败了，fw的默认值就是null，null是不能调用方法的，会抛出NullPointerException，需要增加一个判断，不是null再把资源释放
            try {
                //fw.close方法声明抛出IOException异常，所以我们就得处理这个异常，要么throws要么try catch
                if (fw != null) {
                    fw.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

### 22jd7和JDK9流中异常的处理

```java
package com.itheima12.demo06.trycatch;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

/*
    JDK7的新特性
    在try的后边可以增加一个（），在括号中可以定义流对象
    那么这个流对象的作用域就在try中有效
    try中的代码执行完毕，会自动把流对象释放，不用finally
    格式：
       try(定义流对象；定义流对象...){
            可能会产生异常的代码
        }catch(异常的类型 变量名){
            异常的处理逻辑
        }
 */
public class Demo02JDK7 {
    public static void main(String[] args) {
        try(//1.创建一个字节输入流对象，构造方法中绑定要读取的数据源
            FileInputStream fis = new FileInputStream("c:\\1.jpg");
            // 2.创建一个字节输出流对象，构造方法中绑定要写入的目的地
            FileOutputStream fos = new FileOutputStream("d:\\1.jpg");) {
            //可能会产生异常的代码
            //读取一个字节，写入一个字节的方式
            //3.使用字节输入流的方法read读取文件
            int len = 0;
            while ((len = fis.read())!=-1){
                //4.使用字节输出流的方法write，把读取到的字节写入到目的地的文件中
                fos.write(len);
            }
        } catch (IOException e) {
            //异常的处理逻辑
            System.out.println(e);
        }
    }
}
```

```java
package com.itheima12.demo06.trycatch;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;

/*
    JDK9的新特性
    try的前边可以定义流对象
    在try的后边的()中可以直接引入流对象的名称（变量名）
    在try代码执行完毕之后，流对象也可以释放掉，不用写finally
    格式
        A a = new a();
        B b = new b();
        try(a,b){
            可能会产生异常的代码
        }catch(异常的类型 变量名){
            异常的处理逻辑
        }
 */
public class Demo02JDK9 {
    public static void main(String[] args) throws IOException {
        //1.创建一个字节输入流对象，构造方法中绑定要读取的数据源
        FileInputStream fis = new FileInputStream("c:\\1.jpg");
        // 2.创建一个字节输出流对象，构造方法中绑定要写入的目的地
        FileOutputStream fos = new FileOutputStream("d:\\1.jpg");
        try(fis;fos) {
            //可能会产生异常的代码
            //读取一个字节，写入一个字节的方式
            //3.使用字节输入流的方法read读取文件
            int len = 0;
            while ((len = fis.read())!=-1){
                //4.使用字节输出流的方法write，把读取到的字节写入到目的地的文件中
                fos.write(len);
            }
        } catch (IOException e) {
            //异常的处理逻辑
            System.out.println(e);
        }

        //fos.write(1);
    }
}
```

### 23使 Properties用集合存储数据遍历取出 Properties集合中的数据

```java
package com.itheima12.demo07.Properties;

import java.util.Properties;
import java.util.Set;

/*
    java.util.Properties集合extends Hashtable<k,v> implements Mav<k,v>
    Properties 类表示了一个持久的属性集。Properties 可保存在流中或从流中加载。
    Properties集合是一个唯一和IO流相结合的集合
        可以使用Properties集合中的方法store，把集合中的临时数据，持久化写入到硬盘中存储
        可以使用Properties集合中的方法load，把硬盘中保存的文件（键值对），读取到集合中使用
    属性列表中每个键及其对应值都是一个字符串。
        Properties集合是一个双列集合，key和value默认都是字符串
 */
public class Demo01Properties {
    public static void main(String[] args) {
        show01();
    }

    /*
        使用Properties集合存储数据，遍历取出Properties集合中的数据
        Properties集合是一个双列集合，key和value默认都是字符串
        Properties集合有一些操作字符串的特有方法
            Object setProperty(String key, String value) 调用 Hashtable 的方法 put。
            String getProperty(String key) 通过key来找到value值，此方法相当于Map集合中的方法get(key)方法
            Set<String> stringPropertyNames()返回此属性列表中的键集，其中该键及其对应值是字符串，此方法相当于Map集合中的方法keySet方法
     */
    private static void show01() {
        //创建一个Properties集合对象
        Properties prop = new Properties();
        //使用setProperty望集合中添加数据
        prop.setProperty("赵丽颖","168");
        prop.setProperty("迪丽热巴","162");
        prop.setProperty("古力娜扎","166");

        //使用stringPropertyNames把Properties集合中的键取出，存储到一个Set集合中
        Set<String> set = prop.stringPropertyNames();

        //遍历Set集合，取出Properties集合的每一个键
        for (String s : set) {
            String value = prop.getProperty(s);
            System.out.println(s + "=" + value);
        }
    }
}
```

### 24_Propertiesstore集合中的方法

```java
package com.itheima12.demo07.Properties;

import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Properties;
import java.util.Set;

/*
    java.util.Properties集合extends Hashtable<k,v> implements Mav<k,v>
    Properties 类表示了一个持久的属性集。Properties 可保存在流中或从流中加载。
    Properties集合是一个唯一和IO流相结合的集合
        可以使用Properties集合中的方法store，把集合中的临时数据，持久化写入到硬盘中存储
        可以使用Properties集合中的方法load，把硬盘中保存的文件（键值对），读取到集合中使用
    属性列表中每个键及其对应值都是一个字符串。
        Properties集合是一个双列集合，key和value默认都是字符串
 */
public class Demo01Properties {
    public static void main(String[] args) throws IOException {
        show02();
    }
    /*
        可以使用Properties集合中的方法store，把集合中的临时数据，持久化写入到硬盘中存储
        store(OutputStream out, String comments)
        store(Writer writer, String comments)
        参数：
            OutputStream out：字节输出流，不能写中文
            Writer writer：字符输出流，可以写中文
            String comments：注释，用来解释说明保存的文件是做什么用的
                    不能使用中文，会产生乱码，默认是Unicode编码
                    一般使用“ ”空字符串

        使用步骤：
            1.创建Properties集合对象，添加数据
            2.创建字节输出流/字符输出流对象,构造方法中绑定要输出的目的地
            3.使用Properties集合中的的方法store，把集合中的临时数据，持久化写入到硬盘中存储
            4.释放资源
     */
    private static void show02() throws IOException {
        //1.创建Properties集合对象，添加数据
        Properties prop = new Properties();
        prop.setProperty("赵丽颖","168");
        prop.setProperty("迪丽热巴","162");
        prop.setProperty("古力娜扎","166");

        //2.创建字节输出流/字符输出流对象,构造方法中绑定要输出的目的地
        //FileWriter fw = new FileWriter("D:\\IdeaProjects\\sy\\src\\com\\itheima12\\demo05\\Writer\\prop.txt");

        // 3.使用Properties集合中的的方法store，把集合中的临时数据，持久化写入到硬盘中存储
        //prop.store(fw,"save data");

        //4.释放资源
        //fw.close();

        prop.store(new FileOutputStream("D:\\\\IdeaProjects\\\\sy\\\\src\\\\com\\\\itheima12\\\\demo05\\\\Writer\\\\prop2.txt"),"");

    }

    /*
        使用Properties集合存储数据，遍历取出Properties集合中的数据
        Properties集合是一个双列集合，key和value默认都是字符串
        Properties集合有一些操作字符串的特有方法
            Object setProperty(String key, String value) 调用 Hashtable 的方法 put。
            String getProperty(String key) 通过key来找到value值，此方法相当于Map集合中的方法get(key)方法
            Set<String> stringPropertyNames()返回此属性列表中的键集，其中该键及其对应值是字符串，此方法相当于Map集合中的方法keySet方法
     */
    private static void show01() {
        //创建一个Properties集合对象
        Properties prop = new Properties();
        //使用setProperty望集合中添加数据
        prop.setProperty("赵丽颖","168");
        prop.setProperty("迪丽热巴","162");
        prop.setProperty("古力娜扎","166");

        //使用stringPropertyNames把Properties集合中的键取出，存储到一个Set集合中
        Set<String> set = prop.stringPropertyNames();

        //遍历Set集合，取出Properties集合的每一个键
        for (String s : set) {
            String value = prop.getProperty(s);
            System.out.println(s + "=" + value);
        }
    }
}
```

### 25_ Properties集合中的方法load

```java
package com.itheima12.demo07.Properties;

import java.io.*;
import java.util.Properties;
import java.util.Set;

/*
    java.util.Properties集合extends Hashtable<k,v> implements Mav<k,v>
    Properties 类表示了一个持久的属性集。Properties 可保存在流中或从流中加载。
    Properties集合是一个唯一和IO流相结合的集合
        可以使用Properties集合中的方法store，把集合中的临时数据，持久化写入到硬盘中存储
        可以使用Properties集合中的方法load，把硬盘中保存的文件（键值对），读取到集合中使用
    属性列表中每个键及其对应值都是一个字符串。
        Properties集合是一个双列集合，key和value默认都是字符串
 */
public class Demo01Properties {
    public static void main(String[] args) throws IOException {
        show03();
    }
    /*
        可以使用Properties集合中的方法load，把硬盘中保存的文件（键值对），读取到集合中使用
        load(InputStream inStream)
        load(Reader reader)
        参数：
            InputStream inStream：字节输入流，不能读取含有中文的键值对
            Reader reader：字符输入流，能读取含有中文的键值对
        使用步骤：
            1.创建Properties集合对象
            2.使用Properties集合对象中的方法load读取保存键值对的文件
            3.遍历Properties集合
        注意：
            1.存储键值对的文件中，键与值默认的连接符号可以使用=，空格（其他符号）
            2.存储键值对的文件中，可以使用#进行注释，被注释的键值对不会被读取
            3.存储键值对的文件中，键与值默认都是字符串，不用再加引号
     */
    private static void show03() throws IOException {
        //1.创建Properties集合对象
        Properties prop = new Properties();
        //2.使用Properties集合对象中的方法load读取保存键值对的文件
        prop.load(new FileReader("D:\\IdeaProjects\\sy\\src\\com\\itheima12\\demo05\\Writer\\prop.txt"));
        //prop.load(new FileInputStream("D:\\IdeaProjects\\sy\\src\\com\\itheima12\\demo05\\Writer\\prop.txt"));
        //3.遍历Properties集合
        Set<String> strings = prop.stringPropertyNames();
        for (String key : strings) {
            System.out.println(key + "=" + prop.getProperty(key));
        }
    }
}
```

## 10_缓冲流、转换流、序列化流、Files

### 01缓冲流的原理

![01_缓冲流的原理](C:/Users/Murphy/Pictures/01_缓冲流的原理.bmp)

### 02 BufferedOutputStream字节缓冲输出流

```java
package com.ithiema.demo01.BufferedStream;

import java.io.BufferedOutputStream;
import java.io.FileOutputStream;
import java.io.IOException;

/*
    java.io.BufferedOutputStream extends OutputStream
    BufferedOutputStream：字节缓冲输出流

    继承自父类的共性成员方法：
        public void close() ：关闭此输出流并释放与此流相关联的任何系统资源。
        public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。
        public void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流。
        public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。
        public abstract void write(int b) ：将指定的字节输出流。

    构造方法：
        BufferedOutputStream(OutputStream out)创建一个新的缓冲输出流，以将数据写入指定的底层输出流。
        BufferedOutputStream(OutputStream out, int size)创建一个新的缓冲输出流，以将具有指定缓冲区大小的数据写入指定的底层输出流。
        参数：OutputStream：字节输出流
            我们可以传递FileOutputStream，缓冲流会给FileOutputStream增加一个缓冲区，提高FileOutputStream的写入效率

            int size：指定缓冲流内部缓冲区的大小，不指定默认
    使用步骤（重点）：
        1.创建一个FileOutputStream对象，构造方法中绑定要输出的目的地
        2.创建BufferedOutputStream对象，构造方法中传递FileOutputStream对象，提高FileO对象效率
        3.使用BufferedOutputStream对象中的方法writer，把数据写入到内部缓冲区中
        4.使用BufferedOutputStream对象中的方法flush，把内部缓冲区的数据，刷新到文件中
        5.释放资源（会先调用flush方法刷新数据，第4部可以省略）
 */
public class Demo01BufferedOutputStream {
    public static void main(String[] args) throws IOException {
        //1.创建一个FileOutputStream对象，构造方法中绑定要输出的目的地
        FileOutputStream fos = new FileOutputStream("D:\\IdeaProjects\\sy\\10_IO\\src\\com\\ithiema\\demo01\\BufferedStream\\a.txt");

        //2.创建BufferedOutputStream对象，构造方法中传递FileOutputStream对象，提高FileO对象效率
        BufferedOutputStream bos = new BufferedOutputStream(fos);

        //3.使用BufferedOutputStream对象中的方法writer，把数据写入到内部缓冲区中
        bos.write("我把数据写入到内部缓冲区".getBytes());

        //4.使用BufferedOutputStream对象中的方法flush，把内部缓冲区的数据，刷新到文件中
        bos.flush();

        //5.释放资源（会先调用flush方法刷新数据，第4部可以省略）
        bos.close();
    }
}
```

### 03 BufferedInputStream字节缓冲输入流

```java
package com.ithiema.demo01.BufferedStream;

import java.io.*;

/*
    java.io.BufferedInputStream extends InputStream
    BufferedInputStream:字节缓冲输入流

    继承自父类的成员方法：
        int read()从输入流中读取数据的下一个字节。
        int read(byte[] b)从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。
        void close()关闭此输入流并释放与该流关联的所有系统资源。

    构造方法：
        BufferedInputStream(InputStream in) 创建一个 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。
        BufferedInputStream(InputStream in, int size) 创建具有指定缓冲区大小的 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。
        参数：
            InputStream：字节输入流
                我们可以传递FileInputStream，缓冲流会给FileInputStream增加一个缓冲区，提高FileInputStream
            int size：指定缓冲流内部缓冲区的大小，不指定默认
    使用步骤（重点）：
        1.创建FIleInputStream对象，构造方法中绑定要读取的数据源
        2.创建BufferedInputStream对象，构造方法中传递FileInputStream对象，提高FileInputStream对象的读取效率
        3.使用BufferedInputStream对象中的方法read，读取文件
        4.释放资源

 */
public class Demo02BufferedInputStream {
    public static void main(String[] args) throws IOException {
        //1.创建FIleInputStream对象，构造方法中绑定要读取的数据源
        FileInputStream fis = new FileInputStream("10_IO\\a.txt");
        //2.创建BufferedInputStream对象，构造方法中传递FileInputStream对象，提高FileInputStream对象的读取效率
        BufferedInputStream bis = new BufferedInputStream(fis);
        //3.使用BufferedInputStream对象中的方法read，读取文件

        byte[] bytes = new byte[1024];//存储每次读取的数据
        int len = 0;//记录每次读取的有效字节个数
        while ((len = bis.read(bytes))!= -1){
            System.out.println(new String(bytes,0,len));
        }
        
        //4.释放资源
        bis.close();
    }
}
```

### 04缓冲流的效率测试复制文件

```java
package com.ithiema.demo02.CopyFile;

import java.io.*;

/*
    文件复制练习：一读一写
    明确：
        数据源：c:\\1.jpg
        数据目的地：d:\\1.jpg
    文件复制的步骤：
        1.创建字节缓冲输入流对象，构造方法中传递字节输入流
        2.创建字节缓冲输出流对象，构造方法中传递字节输出流
        3.创建字节缓冲输入流对象中的方法read，读取文件
        4.创建字节缓冲输出流的方法write，把读取的数据写入到内部缓冲区中
        5.释放资源（会把缓冲区的数据，刷新到文件中）
 */
public class Demo02CopyFile {
    public static void main(String[] args) throws IOException {
        long s = System.currentTimeMillis();
        //1.创建字节缓冲输入流对象，构造方法中传递字节输入流
        BufferedInputStream bis = new BufferedInputStream(new FileInputStream("c:\\1.jpg"));
        //2.创建字节缓冲输出流对象，构造方法中传递字节输出流
        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("d:\\1.jpg"));

        //3.创建字节缓冲输入流对象中的方法read，读取文件
        //一次读写一个字节的方式
        /*int len = 0;
        while ((len = bis.read())!= -1){
            bos.write(len);//27毫秒
        }*/

        //
        byte[] bytes = new byte[1024];
        int len =0;
        while((len = bis.read(bytes))!= -1){
            bos.write(bytes,0,len);//3毫秒
        }

        //5.释放资源（会把缓冲区的数据，刷新到文件中）
        bos.close();
        bis.close();

        long e = System.currentTimeMillis();
        System.out.println("复制文件共耗时"+(e-s)+"毫秒");
    }
}
```

### 05 BufferedWriter字符缓冲输出流

```java
package com.ithiema.demo01.BufferedStream;

import java.io.*;

/*
    java.io.BufferedWriter extends Writer
    BufferedWriter:字符缓冲输出流

    继承自父类的共性成员方法：
        void write(int c) 写入单个字符。
        void write(char[] cbuf) 写入字符数组。
        abstract  void write(char[] cbuf, int off, int len) 写入字符数组的某一部分,off数组的开始索引,len写的字符个数。
        void write(String str) 写入字符串。
        void write(String str, int off, int len) 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。
        void flush() 刷新该流的缓冲。
        void close() 关闭此流，但要先刷新它。

    构造方法：
        BufferedWriter(Writer out) 创建一个使用默认大小输出缓冲区的缓冲字符输出流。
        BufferedWriter(Writer out, int sz) 创建一个使用给定大小输出缓冲区的新缓冲字符输出流。
        参数：
            Writer out:字符输出流
                我们可以传递FIleWriter，缓冲流会给FIleWriter增加一个缓冲区，提高FileWriter的写入效率
            int sz：指定缓冲区的大小，不写默认大小

    特有的成员方法：
        newLine()写入一个行分隔符。会根据不同的操作系统，获取不同的行分隔符
        换行：写换行符号
        windows：\r\n
        linux:/n
        mac:/r

    使用步骤：
        1.调用字符缓冲输出流对象，构造方法中传递字符输出流
        2.调用字符缓冲输出流的方法write，把数据写入到内存缓冲区中
        3.调用字符缓冲输出流的方法flush，把内存缓冲区的数据刷新到文件中
        4.释放资源
 */
public class Demo03BufferedWriter {
    public static void main(String[] args) throws IOException {
        //1.调用字符缓冲输出流对象，构造方法中传递字符输出流
        BufferedWriter bw = new BufferedWriter(new FileWriter("10_IO\\b.txt"));

        //2.调用字符缓冲输出流的方法write，把数据写入到内存缓冲区中
        for (int i = 0; i < 10; i++) {
            bw.write("你好！");
            bw.newLine();
        }

        //3.调用字符缓冲输出流的方法flush，把内存缓冲区的数据刷新到文件中
        bw.flush();

        //4.释放资源
        bw.close();
    }
}
```

### 06BufferedReader_字符缓冲输入流

```java
package com.ithiema.demo01.BufferedStream;

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;

/*
    java.io.BufferedReader extenda Reader

    继承自父类的共性成员方法：
        int read() 读取单个字符并返回。
        int read(char[] cbuf) 一次读取多个字符，将字符读入数组。
        abstract  void close() 关闭该流并释放与之关联的所有资源。

    构造方法：
        BufferedReader(Reader in) 创建一个使用默认大小输入缓冲区的缓冲字符输入流。
        BufferedReader(Reader in, int sz) 创建一个使用指定大小输入缓冲区的缓冲字符输入流。
        参数：
            Reader in：字符输入流
                我们可以传递FileReader，缓冲流会给FileReader增加一个缓冲区，提高FileReader的读取效率

    特有的成员方法：
        String readLine()读取一个文本行。 读取一行数据
            行的终止符号：通过下列字符之一即可认为某行已终止：换行 ('\n')、回车 ('\r') 或回车后直接跟着换行。
            返回值：
                包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null

    使用步骤；
        1.创建自负缓冲输入流对象，构造方法中传递只读输入流
        2.使用字符缓冲输入流对象中的方法read/readLine读取文本
        3.释放资源

 */
public class Demo04BufferedReader {
    public static void main(String[] args) throws IOException {
        //1.创建自负缓冲输入流对象，构造方法中传递只读输入流
        BufferedReader br = new BufferedReader(new FileReader("10_IO\\b.txt"));

        //2.使用字符缓冲输入流对象中的方法read/readLine读取文本
        /*String s = br.readLine();
        System.out.println(s);

        String s = br.readLine();
        System.out.println(s);

        String s = br.readLine();
        System.out.println(s);

        String s = br.readLine();
        System.out.println(s);*/

        /*
            发现以上读取是一个重复的过程，所以可以使用循环优化
            不知道文件中有多少行数据，所以使用while循环
            while的结束条件，读到null结束
         */

        String line;

        while((line = br.readLine())!= null){
            System.out.println(line);
        }

        //3.释放资源
        br.close();
    }
}
```

### 07练习对文本的内容进行排序

```java
package com.ithiema.demo01.BufferedStream;

import java.io.*;
import java.util.HashMap;

/*
    练习：
        对文本内容进行排序
        按照1.2.3...顺序排序
    分析：
        1.创建一个HashMap集合对象，可以：存储每行文本的序号；value存储每行的文本
        2.创建字节缓冲输入流对象，构造方法中绑定字符输入流
        3.创建字符缓冲输出流对象，构造方法中绑定字符输出流
        4.使用字符缓冲输入流中的方法readLine，逐行读取文本
        5.对读取到的文本进行切割，获取行中的序号和文本内容
        6.把切割好的序号和文本的内容存储到HashMap集合中（key是有序的，会自动排序1,2，3,4）
        7.遍历HashMap集合，获取每一个键值对
        8.把每一个键值对，拼接为一个文本行
        9.把拼接好的文本，使用字符缓冲输出流中的方法writer，写入到文件中
        10.释放资源
 */
public class Demo05Test {
    public static void main(String[] args) throws IOException {
        //1.创建一个HashMap集合对象，可以：存储每行文本的序号；value存储每行的文本
        HashMap<String,String> map = new HashMap<>();
        //2.创建字节缓冲输入流对象，构造方法中绑定字符输入流
        BufferedReader br = new BufferedReader(new FileReader("10_IO\\c.txt"));
        //3.创建字符缓冲输出流对象，构造方法中绑定字符输出流
        BufferedWriter bw = new BufferedWriter(new FileWriter("10_IO\\d.txt"));
        //4.使用字符缓冲输入流中的方法readLine，逐行读取文本
        String line;
        while ((line = br.readLine())!=null ){
            //5.对读取到的文本进行切割，获取行中的序号和文本内容
            String[] arr = line.split("\\.");
            //6.把切割好的序号和文本的内容存储到HashMap集合中（key是有序的，会自动排序1,2，3,4）
            map.put(arr[0],arr[1]);
        }

        //7.遍历HashMap集合，获取每一个键值对
        for(String key:map.keySet()){
            String value = map.get(key);
            //8.把每一个键值对，拼接为一个文本行
            line = key + "." + value;
            //9.把拼接好的文本，使用字符缓冲输出流中的方法writer，写入到文件中
            bw.write(line);
            bw.newLine();
        }

        //10.释放资源
        bw.close();
        br.close();
    }
}
```

### 08字符编码和字符集

### 09编码引出的问题 File Reader读取GBK格式的文件

```java
package com.ithiema.demo03.ReverStream;

import java.io.FileReader;
import java.io.IOException;

/*
    FileReader可以读取默认编码格式（UTF-8）的文件
    FileReader读取系统默认编码（中文GBK）会产生乱码
 */
public class Demo01FileReader {
    public static void main(String[] args) throws IOException {
        FileReader fr = new FileReader("10_IO\\我是GBK.txt");
        int len = 0;
        while ((len = fr.read())!= -1){
            System.out.println((char)len);
        }
        fr.close();
    }
}
```

### 10转换流的原理

![02_转换流的原理](C:/Users/Murphy/Pictures/02_转换流的原理.bmp)

### 11OutputStreamWriter介绍&代码实现 

```java
package com.ithiema.demo03.ReverStream;

import java.io.*;

/*
    java.io.OutputStreamWriter extends Writer
    OutputStreamWriter:是字符流通向字节流的桥梁：可使用指定的 charset 将要写入流中的字符编码成字节。(编码：把能看懂的编程看不懂的)

    继承自父类的共性成员方法：
        void write(int c) 写入单个字符。
        void write(char[] cbuf) 写入字符数组。
        abstract  void write(char[] cbuf, int off, int len) 写入字符数组的某一部分,off数组的开始索引,len写的字符个数。
        void write(String str) 写入字符串。
        void write(String str, int off, int len) 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。
        void flush() 刷新该流的缓冲。
        void close() 关闭此流，但要先刷新它。
    构造方法：
        OutputStreamWriter(OutputStream out)创建使用默认字符编码的 OutputStreamWriter。
        OutputStreamWriter(OutputStream out, String charsetName)创建使用指定字符集的 OutputStreamWriter。
        参数：
            OutputStream out：字节输出流，可以用来写转换之后的字节到文件中
            String charsetName:指定的编码表名称，不区分大小写，可以是utf-8/UTF-8，gbk/GBK...不指定默认使用UTF-8
    使用步骤：
        1.创建OutputStreamWriter对象，构造方法中传递字节输出流和指定的编码表名称
        2.使用OutPutStreamWriter对象中的方法write，把字符转换为字节存储缓冲区中（编码）
        3.使用OutputStreamWriter对象中的方法flush，把内存缓冲区中的字节刷新到文件中（使用字节流写字节的过程）
        4.释放资源
 */
public class Demo02OutputStreamWriter {
    public static void main(String[] args) throws IOException {
        //write_utf_8();
        write_gbk();
    }

    /*
        使用转换流OutputStreamWriter写GBK格式的文件
     */
    private static void write_gbk() throws IOException {
        //1.创建OutputStreamWriter对象，构造方法中传递字节输出流和指定的编码表名称
        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream("10_IO\\gbk.txt"),"gbk");//不指定默认使用UTF-8
        //2.使用OutPutStreamWriter对象中的方法write，把字符转换为字节存储缓冲区中（编码）
        osw.write("你好");
        //3.使用OutputStreamWriter对象中的方法flush，把内存缓冲区中的字节刷新到文件中（使用字节流写字节的过程）
        osw.flush();
        //4.释放资源
        osw.close();
    }

    /*
        使用转换流OutputStreamWriter写UTF-8格式的文件
     */
    private static void write_utf_8() throws IOException {
        //1.创建OutputStreamWriter对象，构造方法中传递字节输出流和指定的编码表名称
        //OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream("10_IO\\utf_8.txt"),"utf-8");
        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream("10_IO\\utf_8.txt"));//不指定默认使用UTF-8
        //2.使用OutPutStreamWriter对象中的方法write，把字符转换为字节存储缓冲区中（编码）
        osw.write("你好");
        //3.使用OutputStreamWriter对象中的方法flush，把内存缓冲区中的字节刷新到文件中（使用字节流写字节的过程）
        osw.flush();
        //4.释放资源
        osw.close();
    }
}
```

### 12InputStreamReader介绍&代码实现

```java
package com.ithiema.demo03.ReverStream;

import java.io.*;

/*
    java.io.InputStreamReader extends Reader
    InputStreamReader 是字节流通向字符流的桥梁：它使用指定的 charset 读取字节并将其解码为字符。(解码：把看不懂的编程能看懂的）

    继承自父类的共性成员方法：
        int read() 读取单个字符并返回。
        int read(char[] cbuf) 一次读取多个字符，将字符读入数组。
        abstract  void close() 关闭该流并释放与之关联的所有资源。

    构造方法：
        InputStreamReader(InputStream in)创建一个使用默认字符集的 InputStreamReader。
        InputStreamReader(InputStream in, String charsetName)创建使用指定字符集的 InputStreamReader。
        参数：
            InputStream in：字节输入流，用来读取文件中保存的字节
            String charsetName：指定的编码表名称，不区分大小写，可以是utf-8/UTF-8，gbk/GBK...不指定默认使用UTF-8

    使用步骤：
        1.创建InputStreamReader对象，构造方法中传递字节输入流和指定的编码表名称
        2.使用InputStreanReader对象中的方法read文件
        3.释放资源
    注意事项：
        构造方法中指定的编码表名称要和文件的编码相同，否则会发生乱码
 */
public class Demo03InputStreamReader {
    public static void main(String[] args) throws IOException {
        //read_utf_8();
        read_gbk();
    }

    private static void read_gbk() throws IOException {
        //1.创建InputStreamReader对象，构造方法中传递字节输入流和指定的编码表名称
        InputStreamReader isr = new InputStreamReader(new FileInputStream("10_IO\\gbk.txt"),"gbk");
        // 2.使用InputStreanReader对象中的方法read文件
        int len = 0;

        while((len = isr.read())!= -1){
            System.out.print((char)len);
        }
        //3.释放资源
        isr.close();
    }

    private static void read_utf_8() throws IOException {
        //1.创建InputStreamReader对象，构造方法中传递字节输入流和指定的编码表名称
        InputStreamReader isr = new InputStreamReader(new FileInputStream("10_IO\\utf_8.txt"));
        // 2.使用InputStreanReader对象中的方法read文件
        int len = 0;

        while((len = isr.read())!= -1){
            System.out.print((char)len);
        }
        //3.释放资源
        isr.close();
    }
}
```

### 13练习转换文件编码

```java
package com.ithiema.demo03.ReverStream;

import java.io.*;

/*
    练习：转换文件的编码
        将GBK编码的文本文件，转换为utf-8编码的文本文件。

    分析：
        1.创建InputStreamReader对象，构造方法中传递字节输入流和指定的编码表名称GBK
        2.创建OutputStreamWriter对象，构造方法中换地字节输出流和指定的编码表UFT-8
        3.使用InputStreamReader对象中的方法read读取文件
        4.使用OutputStreamWriter对象中的方法write，把读取的数据写入到文件中
        5.释放资源
 */
public class Demo04Test {
    public static void main(String[] args) throws IOException {
        //1.创建InputStreamReader对象，构造方法中传递字节输入流和指定的编码表名称GBK
        InputStreamReader isr = new InputStreamReader(new FileInputStream("10_IO\\我是GBK.txt"),"gbk");
        //2.创建OutputStreamWriter对象，构造方法中换地字节输出流和指定的编码表UFT-8
        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream("10_IO\\我是utf_8.txt"),"utf-8");
        //3.使用InputStreamReader对象中的方法read读取文件
        int len = 0;
        while ((len = isr.read())!=-1){
            //4.使用OutputStreamWriter对象中的方法write，把读取的数据写入到文件中
            osw.write(len);
        }
        //5.释放资源
        osw.close();
        isr.close();
    }
}
```

### 14序列化和反序列化的概述

![03_序列化和反序列化的概述](C:/Users/Murphy/Pictures/03_序列化和反序列化的概述.bmp)

### 15对象的序 ObjectOutputStream列化流

```java
package com.ithiema.ObjectStream;

import java.io.Serializable;

/*
    序列化和反序列化的时候，会抛出NotSerializableException没有序列化异常
    类通过实现 java.io.Serializable 接口以启用其序列化功能。未实现此接口的类将无法使其任何状态序列化或反序列化。
    Serializable接口也叫标记型接口
        要进行序列化和反序列化的类必须事先Serializable接口，就会给类添加一个标记
        当我们进行序列化和反序列化的时候们就会检测类上是否有这个标记
            有:就可以序列化和反序列化
            没有：就会抛出NotSerializableException异常
 */
public class Person implements Serializable {
    private String name;
    int age;

    public Person() {
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
```

```java
package com.ithiema.ObjectStream;

import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;

/*
    java.io.ObjectOutputStream extends OutputStream
    ObjectOutputStream:对象的序列化流
    作用：把对象以流的方式写入到文件中保存

    构造方法：
        ObjectOutputStream()为完全重新实现 ObjectOutputStream 的子类提供一种方法，让它不必分配仅由 ObjectOutputStream 的实现使用的私有数据。
        ObjectOutputStream(OutputStream out)创建写入指定 OutputStream 的 ObjectOutputStream。
        参数：
            OutputStream out：字节输出流
    特有的成员方法：
        void writeObject(Object obj)将指定的对象写入 ObjectOutputStream。

    使用步骤：
        1.创建ObjectOutputStream对象，构造方法中传递字节输出流
        2.使用ObjectOutputStream对象中的方法writeObject，把对象写入到文件中
        3.释放资源
 */
public class Demo01ObjectOutputStream {
    public static void main(String[] args) throws IOException {
        //1.创建ObjectOutputStream对象，构造方法中传递字节输出流
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("10_IO\\person.txt"));
        //2.使用ObjectOutputStream对象中的方法writeObject，把对象写入到文件中
        oos.writeObject(new Person("小美女",18));
        //3.释放资源
        oos.close();
    }
}
```

### 16对象的反序列化流 ObjectInputStream

```java
package com.ithiema.ObjectStream;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.ObjectInputStream;

/*
    java.io.ObjectInputStream extends InputStream
    ObjectInputStream:对象的反序列化流
    作用：把文件中保存的对象，以流的方式读取出来使用

    构造方法：
        ObjectInputStream() 为完全重新实现 ObjectInputStream 的子类提供一种方式，让它不必分配仅由 ObjectInputStream 的实现使用的私有数据。
        ObjectInputStream(InputStream in) 创建从指定 InputStream 读取的 ObjectInputStream。
    参数：
        InputStream in：字节输入流
    特有的成员方法：
        ject readObject() 从 ObjectInputStream 读取对象。

    使用步骤：
        1.创建ObjectInputStream对象，构造方法中传递字节输入流
        2.使用ObjectInputStream对象中的方法readObject读取保存对象的文件
        3.释放资源
        4.使用读取出来的对象（打印）

    readObject 方法声明抛出了ClassNotFoundException（class文件找不到异常）
    当不存在对象的class文件时抛出次异常
    反序列化的前提：
        1.类必须实现Serializable
        2.必须存在类对应的class文件
 */
public class Demo02ObjectInputStream {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        //1.创建ObjectInputStream对象，构造方法中传递字节输入流
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream("10_IO\\person.txt"));
        //2.使用ObjectInputStream对象中的方法readObject读取保存对象的文件
        Object object = ois.readObject();
        //3.释放资源
        ois.close();
        //4.使用读取出来的对象（打印）
        System.out.println(object);
        Person p = (Person) object;
        System.out.println(p.getName() + p.getAge());
    }
}
```

### 17 transient关键字瞬态关键字

```java
package com.ithiema.ObjectStream;

import java.io.Serializable;

/*
    序列化和反序列化的时候，会抛出NotSerializableException没有序列化异常
    类通过实现 java.io.Serializable 接口以启用其序列化功能。未实现此接口的类将无法使其任何状态序列化或反序列化。
    Serializable接口也叫标记型接口
        要进行序列化和反序列化的类必须事先Serializable接口，就会给类添加一个标记
        当我们进行序列化和反序列化的时候们就会检测类上是否有这个标记
            有:就可以序列化和反序列化
            没有：就会抛出NotSerializableException异常

    ststic：静态关键字
        静态优先于非静态加载到内存中（静态优先于对象进入到内存中）
        被ststic修饰的成员变量不能被序列化的，序列化的都是对象

    transient关键字：瞬态关键字
        被transient修饰的成员变量不能被序列化
        有静态的功能，没有静态的含义，不想成员被序列化时使用
 */
public class Person implements Serializable {
    private  String name;
    //private static int  age;//添加ststic后age为0
    private transient int  age;//添加transient后age为0

    public Person() {
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
```

### 18 InvalidClassException异常原理和解决方案

![04_序列号冲突异常的原理和解决方案](C:/Users/Murphy/Pictures/04_序列号冲突异常的原理和解决方案.bmp)

```java
package com.ithiema.ObjectStream;

import java.io.Serializable;

/*
    序列化和反序列化的时候，会抛出NotSerializableException没有序列化异常
    类通过实现 java.io.Serializable 接口以启用其序列化功能。未实现此接口的类将无法使其任何状态序列化或反序列化。
    Serializable接口也叫标记型接口
        要进行序列化和反序列化的类必须事先Serializable接口，就会给类添加一个标记
        当我们进行序列化和反序列化的时候们就会检测类上是否有这个标记
            有:就可以序列化和反序列化
            没有：就会抛出NotSerializableException异常

    ststic：静态关键字
        静态优先于非静态加载到内存中（静态优先于对象进入到内存中）
        被ststic修饰的成员变量不能被序列化的，序列化的都是对象

    transient关键字：瞬态关键字
        被transient修饰的成员变量不能被序列化
        有静态的功能，没有静态的含义，不想成员被序列化时使用
 */
public class Person implements Serializable {
    private static final long serialVersionUID = 42L;
    private  String name;
    //private static int  age;//添加ststic后age为0
    //private transient int  age;//添加transient后age为0
    public int  age;//添加transient后age为0

    public Person() {
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
```

### 19练习序列化集合

```java
package com.ithiema.ObjectStream;

import java.io.*;
import java.util.ArrayList;

/*
    练习：序列化集合
        当我们想在文件中保存多个对象的时候
        可以把多个对象存储到一个集合中
        对集合进行序列化和反序列化
    分析：
        1.定义一个Person对象的ArrayList集合
        2.往ArrayList集合中存储Person对象
        3.创建一个ObjectOutputStream对象
        4.使用OutputStreamW对象中的方法WriteObject，对集合进行序列化
        5.创建一个反序列化ObjectInputStream对象
        6.使用ObjectInputStream对象中的方法readObject读取文件中保存的集合
        7.把Object类型的集合转化为ArrayList类型
        8.遍历ArrayList集合
        9.释放资源
 */
public class Demo03Test {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        //1.定义一个Person对象的ArrayList集合
        ArrayList<Person> list = new ArrayList<>();
        //2.往ArrayList集合中存储Person对象
        list.add(new Person("张三",18));
        list.add(new Person("李四",19));
        list.add(new Person("王五",20));
        //3.创建一个ObjectOutputStream对象
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("10_IO\\list.txt"));
        //4.使用OutputStreamW对象中的方法WriteObject，对集合进行序列化
        oos.writeObject(list);
        //5.创建一个反序列化ObjectInputStream对象
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream("10_IO\\list.txt"));
        //6.使用ObjectInputStream对象中的方法readObject读取文件中保存的集合
        Object o = ois.readObject();
        //7.把Object类型的集合转化为ArrayList类型
        ArrayList<Person> list2 = (ArrayList<Person>)o;
        //8.遍历ArrayList集合
        for (Person p : list2) {
            System.out.println(p);
        }
        //9.释放资源
        ois.close();
        oos.close();
    }
}
```

### 20打印流概述和使用

## 11_网络编程

### 01软件结构

### 02网络通信协议

### 03网络通信协议分类

### 04ip地址

### 05端口号

![01_端口号](C:/Users/Murphy/Pictures/01_端口号.bmp)

### 06tcp通信的概述

![02_TCP通信的概述](C:/Users/Murphy/Pictures/02_TCP通信的概述.bmp)

### 08tcp通信的客户端代码实现

```java
package com.itheima.demo01.TCP;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;

/*
    TCP通信的客户端：向服务器发送链接请求，给服务器发送数据，读取服务器写回的数据
    表示客户的类：
        java.net.Socket：此类实现客户端套接字（也可以就叫“套接字”）。套接字是两台机器间通信的端点。
        套接字：包含了ip地址和端口号的网络单位

    构造方法：
        Socket(String host, int port) 创建一个流套接字并将其连接到指定主机上的指定端口号。
        参数：
            String host：服务器主机的名称/服务器的ip地址
            int port：服务器的端口号

    成员方法：
        OutputStream getOutputStream()返回此套接字的输出流。
        InputStream getInputStream() 返回此套接字的输入流。
        void close() 关闭此套接字。

    实现步骤：
        1.创建一个客户端对象Socket，构造方法绑定服务器的ip地址和端口号
        2.使用Socket对象中的方法getOutputStream()获取网络字节输出流OutputStream对象
        3.使用网络字节输出流OutputStream()对象中的方法write，给服务器发送数据
        4.使用Socket对象中的方法getInputStream()获取网络字节输入流Inputstream对象
        5.使用网络字节输入流InputStream对象中的方法read，读取服务器写回的数据
        6.释放资源(Scoket)
    注意：
        1.客户端和服务器端进行交互，必须使用Socket中提供的网络流，不能使用自己创建的流对象
        2.当我们创建客户端对象Socket的时候，就会去请求服务器和服务器经过3次握手建立连接通路
            这时如果服务器没有启动，那么就会抛出异常
            如果服务器已经启动，那么就可以进行交互了
 */
public class TCPClient {
    public static void main(String[] args) throws IOException {
        //1.创建一个客户端对象Socket，构造方法绑定服务器的ip地址和端口号
        Socket socket = new Socket("127.0.0.1",8888);
        //2.使用Socket对象中的方法getOutputStream()获取网络字节输出流OutputStream对象
        OutputStream os = socket.getOutputStream();
        //3.使用网络字节输出流OutputStream()对象中的方法write，给服务器发送数据
        os.write("你好服务器".getBytes());

        //4.使用Socket对象中的方法getInputStream()获取网络字节输入流Inputstream对象
        InputStream is = socket.getInputStream();
        //5.使用网络字节输入流InputStream对象中的方法read，读取服务器写回的数据
        byte[] bytes = new byte[1024];
        int len = is.read(bytes);
        System.out.println(new String(bytes,0,len));
        //6.释放资源(Scoket)
        socket.close();
    }
}
```

### 09tcp通信的服务器端代码实现

```java
package com.itheima.demo01.TCP;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;

/*
    TCP通信的服务端：接收客户端的请求，读取客户端发送的数据，给客户端回写数据
    表示服务器的类：
        java.net.ServerScoket：此类实现服务器套接字。

    构造方法：
        ServerSocket(int port) 创建绑定到特定端口的服务器套接字。

    服务器端必须明确一件事情：必须的知道是哪个客户端请求的服务器
    所以可以使用accept方法获取到请求的客户端对象Socket
    成员方法：
        Socket accept() 侦听并接受到此套接字的连接。

    服务器的实现步骤：
    1.创建服务器ServerSocket对象和系统要指定的端口号
    2.使用ServerScoket对象中的方法accept，获取到请求的客户端对象Socket
    3.使用Socket对象中的方法getInputStream（）获取网络字节输入流对象InputStream对象
    4.使用网络字节输入流InputStream对象中的方法read，读取客户端发送的数据
    5.使用Socket对象中的方法getOutputStream（）获取网络字节输出流OutputStream对象
    6.使用网络字节输出流OutputStream对象中的方法write，给客户端回写数据
    7.释放资源（Socket，ServerSocket）
 */
public class TCPServer {
    public static void main(String[] args) throws IOException {
        //1.创建服务器ServerSocket对象和系统要指定的端口号
        ServerSocket server = new ServerSocket(8888);
        //2.使用ServerScoket对象中的方法accept，获取到请求的客户端对象Socket
        Socket socket = server.accept();
        //3.使用Socket对象中的方法getInputStream（）获取网络字节输入流对象InputStream对象
        InputStream is = socket.getInputStream();
        //4.使用网络字节输入流InputStream对象中的方法read，读取客户端发送的数据
        byte[] bytes = new byte[1024];
        int len = is.read(bytes);
        System.out.println(new String(bytes,0,len));
        // 5.使用Socket对象中的方法getOutputStream（）获取网络字节输出流OutputStream对象
        OutputStream os = socket.getOutputStream();
        //6.使用网络字节输出流OutputStream对象中的方法write，给客户端回写数据
        os.write("收到，谢谢".getBytes());
        //7.释放资源（Socket，ServerSocket）
        socket.close();
        server.close();
    }
}
```

### 10综合案例文件上传的原理

![03_文件上传的原理](C:/Users/Murphy/Pictures/03_文件上传的原理.bmp)

### 11综合案例文件上传案例的客户端

```java
package FileUpload;

import java.io.*;
import java.net.Socket;

/*
    文件上传案例的客户端:读取本地文件，上传到服务器，读取服务器回写数据

    明确：
        数据源：c:\\1.jpg
        目的地：服务器

    实现步骤：
        1.创建一个本地字节输入流FileInputStream对象，构造方法中绑定要读取的数据源
        2.创建一个客户端Socket对象，构造方法中绑定服务器的IP地址和端口号
        3.使用Socket中的方法getOutputStream，获取网络字节输出流OutputStream对象
        4.使用本地字节输入流FileInputStream对象中的方法read，把读取到的文件上传到服务器
        5.使用网络字节输出流OutputStream对象中的方法write，把读取到的文件上传到服务器
        6.使用Socket中的方法getOutputStream，获取网络字节输入流InputStream对象
        7.使用网络字节输入流InputStream对象中的方法read读取服务器写回的数据
        8.释放资源(FileInputStream,Socket)
 */
public class TCPClient {
    public static void main(String[] args) throws IOException {
        //1.创建一个本地字节输入流FileInputStream对象，构造方法中绑定要读取的数据源
        FileInputStream fis = new FileInputStream("c:\\\\1.jpg");
        //2.创建一个客户端Socket对象，构造方法中绑定服务器的IP地址和端口号
        Socket socket = new Socket("127.0.0.1", 8888);
        //3.使用Socket中的方法getOutputStream，获取网络字节输出流OutputStream对象
        OutputStream os = socket.getOutputStream();
        //4.使用本地字节输入流FileInputStream对象中的方法read，把读取到的文件上传到服务器
        int len = 0;
        byte[] bytes = new byte[1024];
        while ((len = fis.read(bytes)) != -1) {
            //5.使用网络字节输出流OutputStream对象中的方法write，把读取到的文件上传到服务器
            os.write(bytes, 0, len);
        }
        //6.使用Socket中的方法getOutputStream，获取网络字节输入流InputStream对象
        InputStream is = socket.getInputStream();
        //7.使用网络字节输入流InputStream对象中的方法read读取服务写回的数据
        while ((len = is.read(bytes)) != -1) {
            System.out.println(new String(bytes, 0, len));
        }
        //8.释放资源
        fis.close();
        socket.close();
    }
}
```

### 12综合案例文件上传案例的服务器端

```java
package FileUpload;

import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;

/*
    文件上传案例服务器端，读取客户端上传的文件，保存到服务器的硬盘，给客户端回传“上传成功”

    明确：
        数据源：客户端上传的文件
        目的地：服务器的硬盘d:\\upload\\1.jpg

    实现步骤：
        1.创建一个服务器ServerSocket对象，和系统要指定的端口号
        2.使用ServerSocket对象中的方法accept，获取到请求的客户端Socket对象
        3.使用Socket对象中的方法getInputStream，获取到网络字节输入流InputStream对象
        4.判断d:\\upload文件夹是否存在，不存在则创建
        5.创建一个本地字节输出流FIleOutputStream对象，构造方法中绑定要输出的目的地
        6.使用网络字节输入流InputStream对象中的方法read，读取客户端上传的文件
        7.使用本地字节输出流FileOutputStream对象中的方法write，把读取到的文件保存到服务器的硬盘上
        8.使用Socket对象中的方法getOutputStream，获取到网络字节输出流OUtputStream对象
        9.使用网络字节输出流OutputStream对象中的方法write，给客户端回写“上传成功”
        10.释放资源（FileOutputStream，Socket，ServerSocket）
 */
public class TCPServer {
    public static void main(String[] args) throws IOException {
        //1.创建一个服务器ServerSocket对象，和系统要指定的端口号
        ServerSocket server = new ServerSocket(8888);
        //2.使用ServerSocket对象中的方法accept，获取到请求的客户端Socket对象
        Socket socket = server.accept();
        // 3.使用Socket对象中的方法getInputStream，获取到网络字节输入流InputStream对象
        InputStream is = socket.getInputStream();
        //4.判断d:\\upload文件夹是否存在，不存在则创建
        File file = new File("d:\\upload");
        if(!file.exists()){
            file.mkdirs();
        }
        //5.创建一个本地字节输出流FIleOutputStream对象，构造方法中绑定要输出的目的地
        FileOutputStream fos = new FileOutputStream(file + "\\1.jpg");
        //6.使用网络字节输入流InputStream对象中的方法read，读取客户端上传的文件
        int len = 0;
        byte[] bytes = new byte[1024];
        while ((len = is.read(bytes))!=-1){
            //7.使用本地字节输出流FileOutputStream对象中的方法write，把读取到的文件保存到服务器的硬盘上
            fos.write(bytes,0,len);
        }
        //8.使用Socket对象中的方法getOutputStream，获取到网络字节输出流OUtputStream对象
        //9.使用网络字节输出流OutputStream对象中的方法write，给客户端回写“上传成功”
        socket.getOutputStream().write("上传成功".getBytes());
        //10.释放资源（FileOutputStream，Socket，ServerSocket）
        fos.close();
        socket.close();
        server.close();
    }
}
```

### 13综合案例文件上传案例阻塞问题

![04_文件上传案例的阻塞问题](C:/Users/Murphy/Pictures/04_文件上传案例的阻塞问题.bmp)

```java
package FileUpload;

import java.io.*;
import java.net.Socket;

/*
    文件上传案例的客户端:读取本地文件，上传到服务器，读取服务器回写数据

    明确：
        数据源：c:\\1.jpg
        目的地：服务器

    实现步骤：
        1.创建一个本地字节输入流FileInputStream对象，构造方法中绑定要读取的数据源
        2.创建一个客户端Socket对象，构造方法中绑定服务器的IP地址和端口号
        3.使用Socket中的方法getOutputStream，获取网络字节输出流OutputStream对象
        4.使用本地字节输入流FileInputStream对象中的方法read，把读取到的文件上传到服务器
        5.使用网络字节输出流OutputStream对象中的方法write，把读取到的文件上传到服务器
        6.使用Socket中的方法getOutputStream，获取网络字节输入流InputStream对象
        7.使用网络字节输入流InputStream对象中的方法read读取服务器写回的数据
        8.释放资源(FileInputStream,Socket)
 */
public class TCPClient {
    public static void main(String[] args) throws IOException {
        //1.创建一个本地字节输入流FileInputStream对象，构造方法中绑定要读取的数据源
        FileInputStream fis = new FileInputStream("c:\\1.jpg");
        //2.创建一个客户端Socket对象，构造方法中绑定服务器的IP地址和端口号
        Socket socket = new Socket("127.0.0.1", 8888);
        //3.使用Socket中的方法getOutputStream，获取网络字节输出流OutputStream对象
        OutputStream os = socket.getOutputStream();
        //4.使用本地字节输入流FileInputStream对象中的方法read，把读取到的文件上传到服务器
        int len = 0;
        byte[] bytes = new byte[1024];
        while ((len = fis.read(bytes)) != -1) {
            //5.使用网络字节输出流OutputStream对象中的方法write，把读取到的文件上传到服务器
            os.write(bytes, 0, len);
        }
        /*
            解决：上传完文件，给我服务写一个结束标记
            void shutdownInput()此套接字的输入流置于“流的末尾”。
            对于 TCP 套接字，任何以前写入的数据都将被发送，并且后跟 TCP 的正常连接终止序列
         */
        socket.shutdownOutput();
        //6.使用Socket中的方法getOutputStream，获取网络字节输入流InputStream对象
        InputStream is = socket.getInputStream();
        //7.使用网络字节输入流InputStream对象中的方法read读取服务写回的数据
        while ((len = is.read(bytes)) != -1) {
            System.out.println(new String(bytes, 0, len));
        }
        //8.释放资源
        fis.close();
        socket.close();
    }
}
```

### 14综合案例文件上传案例优化

```java
package com.itheima.demo03.FileUpload;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.Random;

/*
    文件上传案例服务器端，读取客户端上传的文件，保存到服务器的硬盘，给客户端回传“上传成功”

    明确：
        数据源：客户端上传的文件
        目的地：服务器的硬盘d:\\upload\\1.jpg

    实现步骤：
        1.创建一个服务器ServerSocket对象，和系统要指定的端口号
        2.使用ServerSocket对象中的方法accept，获取到请求的客户端Socket对象
        3.使用Socket对象中的方法getInputStream，获取到网络字节输入流InputStream对象
        4.判断d:\\upload文件夹是否存在，不存在则创建
        5.创建一个本地字节输出流FIleOutputStream对象，构造方法中绑定要输出的目的地
        6.使用网络字节输入流InputStream对象中的方法read，读取客户端上传的文件
        7.使用本地字节输出流FileOutputStream对象中的方法write，把读取到的文件保存到服务器的硬盘上
        8.使用Socket对象中的方法getOutputStream，获取到网络字节输出流OUtputStream对象
        9.使用网络字节输出流OutputStream对象中的方法write，给客户端回写“上传成功”
        10.释放资源（FileOutputStream，Socket，ServerSocket）
 */
public class TCPServer {
    public static void main(String[] args) throws IOException {
        //1.创建一个服务器ServerSocket对象，和系统要指定的端口号
        ServerSocket server = new ServerSocket(8888);
        /*
            让服务器一直处于监听状态（死循环accept方法）
            有一个客户端上传文件，就保存一个文件
         */
        while (true) {
            //2.使用ServerSocket对象中的方法accept，获取到请求的客户端Socket对象
            Socket socket = server.accept();
            /*
                使用多线程技术，提高程序的效率
                有一个客户端上传文件，就开启一个线程，完成文件的上传
             */
            new Thread(new Runnable() {
                //完成文件的上传
                @Override
                public void run() {
                    try {
                        // 3.使用Socket对象中的方法getInputStream，获取到网络字节输入流InputStream对象
                        InputStream is = socket.getInputStream();
                        //4.判断d:\\upload文件夹是否存在，不存在则创建
                        File file = new File("d:\\upload");
                        if (!file.exists()) {
                            file.mkdirs();
                        }
                    /*
                        自定义一个文件的命名规则：防止同名的文件被覆盖
                        规则：域名+毫秒值+随机数
                     */
                        String filename = "itcast" + System.currentTimeMillis() + new Random().nextInt(999999) + ".jpg";
                        //5.创建一个本地字节输出流FIleOutputStream对象，构造方法中绑定要输出的目的地
                        FileOutputStream fos = new FileOutputStream(file + "\\" + filename);

                        //6.使用网络字节输入流InputStream对象中的方法read，读取客户端上传的文件
                        int len = 0;
                        byte[] bytes = new byte[1024];
                        while ((len = is.read(bytes)) != -1) {
                            //7.使用本地字节输出流FileOutputStream对象中的方法write，把读取到的文件保存到服务器的硬盘上
                            fos.write(bytes, 0, len);
                        }
                        //8.使用Socket对象中的方法getOutputStream，获取到网络字节输出流OUtputStream对象
                        //9.使用网络字节输出流OutputStream对象中的方法write，给客户端回写“上传成功”
                        socket.getOutputStream().write("上传成功".getBytes());
                        //10.释放资源（FileOutputStream，Socket，ServerSocket）
                        fos.close();
                        socket.close();
                    } catch (IOException e) {
                        System.out.println(e);
                    }
                }
            }).start();

            //服务器就不用关闭
            //server.close();
        }

    }
}
```

### 15模拟BS服务器分析

![05_模拟BS服务器分析](C:/Users/Murphy/Pictures/05_模拟BS服务器分析.bmp)

16模拟BS服务器代码实现

```java
package com.itheima.demo04.BSTCP;

import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;

/*
    创建BS版本的TCP服务器
 */
public class TCPServerThread {
    public static void main(String[] args) throws IOException {
        //创建一个服务器ServerSocket，和系统要指定的端口号
        ServerSocket server = new ServerSocket(8080);

        /*
            浏览器解析服务器回写的html页面，页面中如果有图片，那么浏览器就会单独的开启一个线程，读取服务器的图片
            我们就得让服务器一直处于监听状态。客户端请求一次，服务器就回写一次
         */


        while (true) {
            //使用accept方法获取到请求的客户端对象
            Socket socket = server.accept();

            new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                        //使用Socket对象中的方法getInputStream，获取到网络字节输入流InputStream对象
                        InputStream is = socket.getInputStream();
                        //使用网络字节输入流InputStream对象中的方法read读取客户端的请求信息
                        //把is网络字节输入流，转换为字符缓冲输入流
                        BufferedReader br = new BufferedReader(new InputStreamReader(is));
                        //把客户端请求信息的第一行读取出来 GET /11_Net/web/index.html HTTP/1.1
                        String line = br.readLine();
                        System.out.println(line);
                        //把读取的信息进行切割，只要中间部分/11_Net/web/index.html
                        String[] arr = line.split(" ");
                        //把路径前边的/去掉，进行截取
                        String htmlpath = arr[1].substring(1);

                        //创建一个本地字节输入流，构造方法中绑定要读取的html路径
                        FileInputStream fis = new FileInputStream(htmlpath);
                        //使用SocketStream中的方法getOutputStream获取网络字节输入流OutputStream对象
                        OutputStream os = socket.getOutputStream();

                        // 写入HTTP协议响应头,固定写法
                        os.write("HTTP/1.1 200 OK\r\n".getBytes());
                        os.write("Content-Type:text/html\r\n".getBytes());
                        // 必须要写入空行,否则浏览器不解析
                        os.write("\r\n".getBytes());

                        //一读一写复制文件，把服务器读取的html文件回写到客户端
                        int len = 0;
                        byte[] bytes = new byte[1024];
                        while ((len = fis.read(bytes)) != -1) {
                            os.write(bytes, 0, len);
                        }

                        //释放资源
                        fis.close();
                        socket.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }).start();
        }
        //server.close();
    }
}
```

## 12_函数式接口

### 01函数式接口的概念&函数式接口的定义

```java
package com.itheima.demo01.FunctionalInterface;
/*
    函数式接口：有且只有一个抽象方法的接口，称之为函数式接口
    当然接口中可以包含其他的方法（默认，静态，私有）

    @FunctionalInterface注解
    作用：可以检测接口是够是一个函数式接口
        是：编译成功
        否：编译失败（接口中没有抽象方法，抽象方法的个数多余1个）
 */
@FunctionalInterface
public interface MyFunctionalInterface {
    //定义一个抽象方法
    public abstract void method();
}
```

### 02函数式接口的使用

```java
package com.itheima.demo01.FunctionalInterface;
/*
    函数式接口的使用：一般可以作为方法的参数和返回值类型
 */
public class Demo {
    //定义一个抽象方法
    public static void show(MyFunctionalInterface myInter){
        myInter.method();
    }

    public static void main(String[] args) {
        //调用show方法，方法的参数是一个接口，所以可以传递接口的实现类对象
        show(new MyFunctionalInterdaceImpl());

        //调用show方法，方法的参数是一个接口，所以可以传递接口的匿名内部类
        show(new MyFunctionalInterface() {
            @Override
            public void method() {
                System.out.println("使用匿名内部类重写接口中的抽象方法");
            }
        });

        //调用show方法，方法的参数是一个函数式接口。所以我们可以Lambda表达式
        show(()->{
            System.out.println("使用Lambda表达式重写接口中的抽象方法");
        });

        //简化Lambda表达式
        show(()-> System.out.println("使用Lambda表达式重写接口中的抽象方法")
        );
    }
}
```

### 03性能浪费的日志案例

```java
package com.itheima.demo02.Lambda;

/*
    日志案例

    发现以下代码存在着性能浪费的的问题
    调用showLog方法，传递的第二个参数是一个拼接后的字符串
    先把字符串拼接好，然后再调用showLog方法
    showLog方法中如果传递烦人日志等级不是1级
    那么就不会是如此拼接后的字符串
    所以感觉字符串就白拼接了，存在了浪费
 */
public class Demo01Logger {
    //定义一个根据日志级别，显示日志信息的方法
    public static void showLog(int level, String message) {
        //对日志的等级进行判断，如果是1级，那么输出日志信息
        if (level == 1) {
            System.out.println(message);
        }
    }


    public static void main(String[] args) {
        //定义三个日志信息
        String msg1 = "Hello";
        String msg2 = "World";
        String msg3 = "Java";

        //调用showLog方法，传递日志级别和信息
        showLog(2, msg1 + msg2 + msg3);
    }
}
```

### 04使用 Lambda优化日志案例

```java
package com.itheima.demo02.Lambda;
@FunctionalInterface
public interface MessageBuilder {
    //定义一个拼接消息的抽象方法，返回被拼接的消息
    public abstract String builderMessage();
}
```

```java
package com.itheima.demo02.Lambda;

/*
    使用Lambda优化日志案例
    Lambda的特点：延迟加载
    Lambda使用前提，必须存在函数式接口
 */
public class Demo02Lamdba {
    //定义一个显示日志的方法，方法的参数传递日志的等级和Messagbulider旧口
    public static void showlog(int level, MessageBuilder mb) {
        //对日志的等级进行判断，如果是1级，则调用MessageBulider接口中的builderMessage方法
        if (level == 1) {
            System.out.println(mb.builderMessage());
        }
    }

    public static void main(String[] args) {
        //定义三个日志信息
        String msg1 = "Hello";
        String msg2 = "World";
        String msg3 = "Java";

        //调用showLog方法，参数MessageBuilder是一个函数式接口，所以可以传递Lambda表达式
        /*showlog(2,()->{
            //返回一个拼接好的字符串
            return msg1 + msg2 + msg3;
        });*/

        /*
            使用Lambda表达式作为参数传递，仅仅是把参数传递到showLog方法中
            只有满足条件，日志等级是1级
                才会调用接口MessageBuilder中的方法builderMessage
                才会进行字符串的拼接
            如果条件不满足，日志的等级不是1级
                那么MessageBuilder接口中的方法builderMessage也不会执行
            所以不会存在性能的浪费
         */

        showlog(1,()->{
            System.out.println("不满足条件不执行");
            //返回一个拼接好的字符串
            return msg1 + msg2 + msg3;
        });
    }
}
```

### 05函数式接口作为方法的参数案例

```java
package com.itheima.demo03.Runnable;
/*
    例如java.lang.Runnable 接口就是一个函数式接口，假设有一个startThread 方法使用该接口作为参数，那么就
    可以使用Lambda进行传参。这种情况其实和Thread 类的构造方法参数为Runnable 没有本质区别。
 */
public class Demo01Runnable {
    //定义一个方法startThread，方法的参数使用函数式接口Runnable
    public static void startThread(Runnable run){
        //开启多线程
        new Thread(run).start();
    }

    public static void main(String[] args) {
        //调用startThread方法，方法的参数是一个接口，那么我们可以传递这个接口的匿名内部类
        startThread(new Runnable() {
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName()+"-->"+"线程启动了");
            }
        });

        //调用startThread方法，方法的参数是一个接口，所以可以传递Lambda表达式
        startThread(()->{
            System.out.println(Thread.currentThread().getName()+"-->"+"线程启动了");
        });

        //优化Lambda表达式
        startThread(()-> System.out.println(Thread.currentThread().getName()+"-->"+"线程启动了"));
    }
}
```

### 06函数式接口作为方法的返回值类型案例

```java
package com.itheima.demo03.Runnable;

import java.util.Arrays;
import java.util.Comparator;

/*
    如果一个方法的返回值类型是一个函数式接口，那么就可以直接返回一个Lambda表达式。当需要通过一
    个方法来获取一个java.util.Comparator 接口类型的对象作为排序器时,就可以调该方法获取。
 */
public class Demo02Comparator {
    //定义一个方法，方法的返回值类型使用函数式接口Comparator
    public static Comparator<String> getComparator() {
        //方法的返回值类型是一个接口，那么我们可以返回这个接口的匿名内部类
        /*return new Comparator<String>() {
            @Override
            public int compare(String o1, String o2) {
                //按照字符串的降序排序
                return o2.length() - o1.length();
            }
        };*/

        //方法的返回值类型是一个函数式接口，所以我们可以返回一个Lambda表达式
        /*return (String o1, String o2)->{
            //按照字符串的降序排序
            return o2.length() - o1.length();
        };*/

        //继续优化Lambda表达式
        return (o1, o2) -> o2.length() - o1.length();
    }

    public static void main(String[] args) {
        //创建一个字符串数组
        String[] arr = {"aaa","bbb","dddddddddd"};
        //输出排序前的数组
        System.out.println(Arrays.toString(arr));//[aaa, bbb, dddddddddd]
        //调用Arrays中的sort方法，对字符串数组进行排序
        Arrays.sort(arr,getComparator());
        //输出排序后的数组
        System.out.println(Arrays.toString(arr));//[dddddddddd, aaa, bbb]
    }
}
```

### 07_常用的函数式接口_Supplier接口

```java
package com.itheima.demo04.Supplier;

import java.util.function.Supplier;

/*
    常用的函数式接口
    java.util.function.Supplier<T> 接口仅包含一个无参的方法： T get() 。用来获取一个泛型参数指定类型的对象数据。

    Supplier<T> 接口被称之为生产型接口，指定接口的泛型是什么类型，那么接口中的get方法就会产生什么类型的数据
 */
public class Demo01Supplier {
    //定义一个方法，方法的参数传递Supplier<T>接口，泛型执行String，get方法就会返回一个String
    public static String getString(Supplier<String> sup) {
        return sup.get();
    }

    public static void main(String[] args) {
        //调用getString方法，方法的参数Supplier是一个函数式接口，所以可以传递Lambda表达式
        String s = getString(() -> {
            //生产一个字符串并返回
            return "胡歌";
        });
        System.out.printf(s);

        //优化Lambda表达式
        String s2 = getString(() -> "胡歌");
        System.out.printf(s2);
    }
}
```

### 08_常用的函数式接口Supplier接口练习求数组元素最大值

```java
package com.itheima.demo04.Supplier;

import java.util.function.Supplier;

/*
    练习：
    使用Supplier 接口作为方法参数类型，通过Lambda表达式求出int数组中的最大值。
    提示：接口的泛型请使用java.lang.Integer 类。
 */
public class Demo02Test {
    //定义一个方法，用于获取int类型数组中元素的最大值，方法的参数传递Supplier接口，泛型使用Integer
    public static int getMax(Supplier<Integer> sup){
        return sup.get();
    }

    public static void main(String[] args) {
        //定义一个int类型的数组，并赋值
        int[] arr = {100,0,-50,88,99,33,-90};
        //调用getMax方法，方法的参数Supplier是一个函数式接口，所以可以传递Lambda表达式
        int maxValue = getMax(() -> {
            //获取数组的最大值，并返回
            //定义一个变量，把数组中的第一个元素赋值给该变量，记录数组中元素的最大值
            int max = arr[0];
            //遍历数组，获取数组中的其他元素
            for (int i : arr) {
                //使用其他的元素和最大值比较
                if (i > max) {
                    //如果i>max，则替换max作为最大值
                }
            }
            //返回最大值
            return max;
        });
        System.out.println("数组中元素的最大值是" + maxValue);//数组中元素的最大值是100
    }
}
```

### 09常用的函数式接口 Consumer接口

```java
package com.itheima.demo05.Consumer;

import java.util.function.Consumer;

/*
    java.util.function.Consumer<T> 接口则正好与Supplier接口相反，
    它不是生产一个数据，而是消费一个数据，其数据类型由泛型决定。
    Consumer 接口中包含抽象方法void accept(T t) ，意为消费一个指定泛型的数据

    Consumer接口是一个消费型接口，泛型执行什么类型，就可以使用accept方法消费什么类型的数据
    至于怎么消费（使用），需要自定义（输出，计算）
 */
public class Demo01Consumer {
    //定义一个方法
    /*方法的参数传递一个字符串的姓名
    方法的参数传递Consumer接口，泛型使用String
    可以使用Consumer接口消费字符串的姓名*/
    public static void method(String name, Consumer<String> con){
        con.accept(name);
    }

    public static void main(String[] args) {
        //调用method方法，传递字符串姓名，方法的另一个参数是Consumer接口，是一个函数式接口，所以可以传递Lambda表达式
        method("赵丽颖", Demo01Consumer::accept);
    }

    private static void accept(String name) {
        //对传递的字符串进行消费
        //消费方式，直接输出字符串
        //System.out.println(name);

        //消费方式：把字符串进行翻转输出
        String rename = new StringBuffer(name).reverse().toString();
        System.out.printf(rename);//颖丽赵
    }
}
```

### 10常用的函 Consumer数式接口接口的默认方法

```java
package com.itheima.demo05.Consumer;

import java.util.function.Consumer;

/*
    Consumer 接口的默认方法andThen
    作用：需要两个Consumer接口，可以吧两个Consumer接口组合到一起，再对数据进行消费

    例如：
    Consumer<String> con1
    Consumer<String> con2
    String s = 'hello';
    con1.accept(s);
    con2.accept(s);
    连接两个Consumer接口 再进行消费
    con1.andThen(con2).accept(s);谁写前边谁先消费
 */
public class Demo02AndThen {
    //定义一个方法，方法的参数传递一个字符串和两个Consumer接口，Consumer接口的泛型使用字符串
    public static void method(String s, Consumer<String> con1, Consumer<String> con2) {
        //con1.accept(s);
        //con2.accept(s);
        //使用andThen方法，把两个Consumer接口连接到一起，再消费数据
        con1.andThen(con2).accept(s);//con1连接con2，先执行con1消费数据，再执行con2消费数据
    }

    public static void main(String[] args) {
        //调用method方法，传递一个字符串，两个Lambda表达式
        method("Hello",
                (t) -> {
                    //消费方式：把字符串转换为大写输出
                    System.out.println(t.toUpperCase());//HELLO
                },
                (t) -> {
                    //消费方式：把字符串转换为小写输出
                    System.out.println(t.toLowerCase());//hello
                });
    }
}
```

### 11常用的函数式接口 Consumer接口练习字符串拼接输出

```java
package com.itheima.demo05.Consumer;

import java.util.function.Consumer;

/*
    练习：
    字符串数组当中存有多条信息，请按照格式"姓名：xx。性别：xx。”的格式将信息打印出来。
    要求将打印姓名的动作作为第一个 Consumer接口的实例，
    将打印性别的动作作为第二个 ConsumerL接口的 Lambda实例，
    将两个 Consumer接口按照顺序拼接到一起。
 */
public class Demo03Test {
    //定义一个方法，参数传递String类型的数组和两个Consumer接口，泛型使用String
    public static void printInfo(String[] arr, Consumer<String> con1, Consumer<String> con2) {
        //遍历字符串数组
        for (String message : arr) {
            con1.andThen(con2).accept(message);
        }
    }

    public static void main(String[] args) {
        String[] arr = {"迪丽热巴,女", "古力娜扎,女", "马尔扎哈,男", "赵丽颖,女"};

        //调用printInfo方法，传递一个字符串数组，和两个Lambda表达式
        printInfo(arr, (message) -> {
            //消费方式，对message进行切割，获取姓名，按照指定的格式输出
            String name = message.split(",")[0];
            System.out.print("姓名：" + name);
        }, (message) -> {
            //消费方式，对message进行切割，获取姓名，按照指定的格式输出
            String age = message.split(",")[1];
            System.out.println("。年龄：" + age + "。");
        });
    }
}
```

### 12常用的函数式接口 Predicate接口

```java
package com.itheima.demo06.Predicate;

import java.util.function.Predicate;

/*
     java.util.function.Predicate<T>接口
     作用：对某种数据类型的数据进行判断，结果返回一个boolean值

     Predicate 接口中包含一个抽象方法：
        boolean test(T t) 。用来对指定数据类型数据进行判断的方法
            结果：
                符合条件，返回true
                不符合条件，返回false
 */
public class Demo01Predicate {
    /*
        传递一个方法
        参数传递一个String类型的字符串
        传递一个Predicate接口，泛型使用String
        使用Predicate中的方法test对字符串进行判断，并把判断的结果返回
     */
    public static boolean checkString(String s, Predicate<String> pre){
        return pre.test(s);
    }

    public static void main(String[] args) {
        //定义一个字符串
        String s = "abcdef";

        //调用checkString方法对字符串进行校验，参数传递字符串和Lambda表达式
        /*  boolean b = checkString(s, (String str) -> {
            //对参数传递的字符串进行判断，判断字符串的长度是否大于5，并把判断的结果返回
            return str.length() > 5;
        });
        */
        //优化Lambda表达式
        boolean b = checkString(s, str -> str.length() > 5);
        System.out.println(b);//true
    }
}
```

### 13常用的函 Predicate数式接口接口默认方法and

```java
package com.itheima.demo06.Predicate;

import java.util.function.Predicate;

/*
    逻辑表达式：可以连接多个判断的条件
    &&:与运算，有false则false
    //:或运算，有true则true
    !:（取反）运算符，非真则假，非假则真

    需求：判断一个字符串，有两个判断的条件
        1.判断字符串的长度是否大于5
        2.判断字符串中是否包含a
    两个条件必须同时满足，我们就可以使用&&运算符连接两个条件

    Predicate接口中有一个人方法and，标识并且关系，也可连接两个判断条件

    default Predicate<T> and(Predicate<? super T> other) {
        Objects.requireNonNull(other);
        return (t) ‐> test(t) && other.test(t);
    }
    方法内部的两个判断条件，也是使用&&运算符连接起来的
 */
public class Demo02Predicate_and {
    /*
        定义一个方法，方法的参数，传递一个字符串
        传递两个Predicate接口
            一个用于判断字符串的长度是否大于5
            一个用于判断字符串中是否包含a
     */
    public static boolean checkString(String s, Predicate<String> pre1, Predicate<String> pre2){
//        return pre1.test(s) && pre2.test(s);
        return pre1.and(pre2).test(s);//等价于return pre1.test(s) && pre2.test(s);
    }

    public static void main(String[] args) {
        //定义一个字符串
        String s = "abcdef";
        //调用checkString方法，参数传递字符串和Lambda表达式
        boolean b = checkString(s, (String str) -> {
            //判断字符串的长度是否大于5
            return str.length() > 5;
        }, (String str) -> {
            //判断字符串是否包含a
            return str.contains("a");
        });
        System.out.println(b);//true
    }
}
```

### 14_常用的函 Predicate数式接口接口默认方法or&negate

```java
package com.itheima.demo06.Predicate;

import java.util.function.Predicate;

/*
    需求：判断一个字符串，有两个判断的条件
        1.判断字符串的长度是否大于5
        2.判断字符串中是否包含a
    满足一个条件即可，我们就可以使用//运算符连接两个条件

    Predicate接口中有一个人方法or，标识或者关系，也可连接两个判断条件

    default Predicate<T> or(Predicate<? super T> other) {
        Objects.requireNonNull(other);
        return (t) ‐> test(t) || other.test(t);
    }
    方法内部的两个判断条件，也是使用//运算符连接起来的
 */
public class Demo02Predicate_or {
    /*
    定义一个方法，方法的参数，传递一个字符串
    传递两个Predicate接口
        一个用于判断字符串的长度是否大于5
        一个用于判断字符串中是否包含a
        满足一个条件即可
 */
    public static boolean checkString(String s, Predicate<String> pre1, Predicate<String> pre2){
        //return pre1.test(s) || pre2.test(s);
        return pre1.or(pre2).test(s);//等价于return pre1.test(s) || pre2.test(s);
    }

    public static void main(String[] args) {
        //定义一个字符串
        String s = "bcde";
        //调用checkString方法，参数传递字符串和Lambda表达式
        boolean b = checkString(s, (String str) -> {
            //判断字符串的长度是否大于5
            return str.length() > 5;
        }, (String str) -> {
            //判断字符串是否包含a
            return str.contains("a");
        });
        System.out.println(b);//false
    }
}
```

```java
package com.itheima.demo06.Predicate;

import java.util.function.Predicate;

/*
    需求：判断一个字符串，有两个判断的条件
        1.判断字符串的长度是否大于5
        如果字符串的长度大于5，那返回false
        如果字符串的长度不大于5，那么返回true
    所以我们可以使用取反符号!对判断的结果进行取反
    default Predicate<T> negate() {
    return (t) ‐> !test(t);
    }
 */
public class Demo02Predicate_negate {
    /*
    定义一个方法，方法的参数，传递一个字符串
    使用Predicate接口对字符串进行判断
        一个用于判断字符串的长度是否大于5
 */
    public static boolean checkString(String s, Predicate<String> pre1){
        //return !pre1.test(s);
        return pre1.negate().test(s);//等价于return !pre1.test(s);
    }

    public static void main(String[] args) {
        //定义一个字符串
        String s = "abc";

        //调用ckeckString方法，参数传递字符串和Lambda表达式
        boolean b = checkString(s, (String str) -> {
            //判断字符串的长度是否大于5，并返回结果
            return str.length()>5;//true
        });
        System.out.println(b);
    }
}
```

### 15常用的函 Predicate数式接口接口练习集合信息筛选

```java
package com.itheima.demo06.Predicate;

import java.util.ArrayList;
import java.util.function.Predicate;

/*
    练习：集合信息筛选
    题目
    数组当中有多条“姓名+性别”的信息如下，
    String[] array = { "迪丽热巴,女", "古力娜扎,女", "马尔扎哈,男", "赵丽颖,女" };
    请通过Predicate 接口的拼装将符合要求的字符串筛选到集合ArrayList 中，
    需要同时满足两个条件：
        1. 必须为女生；
        2. 姓名为4个字。

    分析：
        1.有两个判断条件判断条件，所以需要使用两个Predicate接口，对条件进行判断
        2.必须同时满足两个条件，所以可以使用and方法连接两个判断条件
 */
public class Demo05Test {
    /*
        定义一个方法
        方法的参数传递一个包含人员信息的数组
        传递两个Predicate接口,用于对数组中的信息进行过滤
        把满足条件的信息存储到ArrayList集合中并返回
     */
    public static ArrayList<String> filter(String[] arr, Predicate<String> pre1, Predicate<String> pre2){
        //定义一个ArrayList集合，存储过滤之后的信息
        ArrayList<String> list = new ArrayList<>();
        //遍历数组，获取数组中的每一条信息
        for(String s:arr){
            //使用Predicate接口中的方法test对获取到的字符串进行判断
            boolean b = pre1.and(pre2).test(s);
            //对得到的boolean值进行判断
            if(b){
                //条件成立，两个条件都满足，把信息存储到ArrayList集合中
                list.add(s);
            }
        }
        //把集合返回
        return list;
    }

    public static void main(String[] args) {
        //定义一个存储字符串的数组
        String[] array = { "迪丽热巴,女", "古力娜扎,女", "马尔扎哈,男", "赵丽颖,女" };
        //调用filter方法，传递字符串数组和两个Lambda表达式
        ArrayList<String> list = filter(array, (String s) -> {
            //获取字符串中的性别,判断是否为女
            return s.split(",")[1].equals("女");
        }, (String s) -> {
            //判断字符中的姓名，判断长度是否为4个字符
            return s.split(",")[0].length() == 4;
        });
        //遍历集合
        for (String s : list) {
            System.out.println(s);
        }
    }
}
```

### 16常用的函 Function数式接口接口

```java
package com.itheima.demo07.Function;

import java.util.function.Function;

/*
    java.util.function.Function<T,R> 接口用来根据一个类型的数据得到另一个类型的数据，
        前者称为前置条件，后者称为后置条件。
    Function 接口中最主要的抽象方法为： R apply(T t) ，根据类型T的参数获取类型R的结果。
        使用的场景例如：将String 类型转换为Integer 类型。
 */
public class Demo01Function {
    /*
        定义一个方法
        方法的参数传递一个字符串类型的整型
        方法的参数传递一个Function接口，泛型使用<String,Integer>
        使用Function接口中的方法apply把字符串类型的整数，转换为Integer类型的整数
     */
    public static void change(String s, Function<String,Integer> fun){
        //Integer in = fun.apply(s);
        int in = fun.apply(s);
        System.out.println(in);
    }

    public static void main(String[] args) {
        //定义一个字符串类型的整数
        String s = "1234";
        //调用change方法，传递字符串类型的整数，和Lambda表达式
        change(s,(String str)->{
            //把字符串类型的整数，转换为Integer类型的整数返回
            return Integer.parseInt(str);//1234
        });
        //优化Lambda表达式
        change(s,str-> Integer.parseInt(str));
    }
}
```

### 17常用的函 Functionar数式接口接口默认方法

```java
package com.itheima.demo07.Function;
import java.util.function.Function;

/*
    Function接口中的默认方法andThen:用来进行组合操作

    需求:
        把String类型的"123",转换为Inteter类型,把转换后的结果加10
        把增加之后的Integer类型的数据,转换为String类型

    分析:
        转换了两次
        第一次是把String类型转换为了Integer类型
            所以我们可以使用Function<String,Integer> fun1
                Integer i = fun1.apply("123")+10;
        第二次是把Integer类型转换为String类型
            所以我们可以使用Function<Integer,String> fun2
                String s = fun2.apply(i);
        我们可以使用andThen方法,把两次转换组合在一起使用
            String s = fun1.andThen(fun2).apply("123");
            fun1先调用apply方法,把字符串转换为Integer
            fun2再调用apply方法,把Integer转换为字符串
 */
public class Demo02Function_andThen {
    /*
        定义一个方法
        参数串一个字符串类型的整数
        参数再传递两个Function接口
            一个泛型使用Function<String,Integer>
            一个泛型使用Function<Integer,String>
     */
    public static void change(String s, Function<String,Integer> fun1,Function<Integer,String> fun2){
        String ss = fun1.andThen(fun2).apply(s);
        System.out.println(ss);
    }

    public static void main(String[] args) {
        //定义一个字符串类型的整数
        String s = "123";
        //调用change方法,传递字符串和两个Lambda表达式
        change(s,(String str)->{
            //把字符串转换为整数+10
            return Integer.parseInt(str)+10;
        },(Integer i)->{
            //把整数转换为字符串
            return i+"";
        });

        //优化Lambda表达式
        change(s,str->Integer.parseInt(str)+10,i->i+"");
    }
}
```

### 18常用的函数式接口 Function接口练习自定义函数模型拼接

```java
package com.itheima.demo07.Function;

import java.util.function.Function;

/*
    练习：自定义函数模型拼接
    题目
    请使用Function进行函数模型的拼接，按照顺序需要执行的多个函数操作为：
        String str = "赵丽颖,20";

    分析:
    1. 将字符串截取数字年龄部分，得到字符串；
        Function<String,String> "赵丽颖,20"->"20"
    2. 将上一步的字符串转换成为int类型的数字；
        Function<String,Integer> "20"->20
    3. 将上一步的int数字累加100，得到结果int数字。
        Function<Integer,Integer> 20->120
 */
public class Demo03_Test {
    /*
        定义一个方法
        参数传递包含姓名和年龄的字符串
        参数再传递3个Function接口用于类型转换
     */
    public static int change(String s, Function<String,String> fun1,
                             Function<String,Integer> fun2,Function<Integer,Integer> fun3){
        //使用andThen方法把三个转换组合到一起
        return fun1.andThen(fun2).andThen(fun3).apply(s);
    }

    public static void main(String[] args) {
        //定义一个字符串
        String str = "赵丽颖,20";
        //调用change方法,参数传递字符串和3个Lambda表达式
        int num = change(str,(String s)->{
            //"赵丽颖,20"->"20"
            return s.split(",")[1];
        },(String s)->{
            //"20"->20
            return Integer.parseInt(s);
        },(Integer i)->{
            //20->120
            return i+100;
        });
        System.out.println(num);
    }
}
```

## 13_Stream流、方法引用

### 01使用传统的方式遍历集合，对集合中的数据进行过滤

```java
package com.itheima.demo01.Stream;

import java.util.ArrayList;
import java.util.List;

/*
    使用传统的方式，遍历集合，对集合中的数据进行过滤
 */
public class Demo01Stream {
    public static void main(String[] args) {
        //创建一个集合，存储姓名‘
        List<String> list = new ArrayList<>();
        list.add("张无忌");
        list.add("周芷若");
        list.add("赵敏");
        list.add("张强");
        list.add("张三丰");

        //对集合中的元素进行过滤，只要以张开头的元素，存储到一个新的集合
        List<String> listA = new ArrayList<>();
        for (String s : list){
            if (s.startsWith("张")){
                listA.add(s);
            }
        }

        //对List集合中进行过滤，只要姓名长度为3的人，存储到一个新集合中
        List<String> listB = new ArrayList<>();
        for (String s : listA){
            if (s.length()==3){
                listB.add(s);
            }
        }

        //遍历ListB集合
        for (String s : listB){
            System.out.println(s);
        }
    }
}
```

### 02使用 Stream流的方式遍历集合对集合中的数据进行过滤

```java
package com.itheima.demo01.Stream;

import java.util.ArrayList;
import java.util.List;

/*
    使用Stream流的方式，遍历集合，对集合中的数据进行过滤
 */
public class Demo02Stream {
    public static void main(String[] args) {
        //创建一个集合，存储姓名‘
        List<String> list = new ArrayList<>();
        list.add("张无忌");
        list.add("周芷若");
        list.add("赵敏");
        list.add("张强");
        list.add("张三丰");

        //对集合中的元素进行过滤，只要以张开头的元素，存储到一个新的集合
        //对List集合中进行过滤，只要姓名长度为3的人，存储到一个新集合中
        //遍历ListB集合
        list.stream()
                .filter(name->name.startsWith("张"))
                .filter(name->name.length()==3)
                .forEach(name-> System.out.println(name));
    }
}
```

03流式思想概述



### 04两种获取 Stream流的方式

```java
package com.itheima.demo02.Stream;

import java.util.*;
import java.util.stream.Stream;

/*
    java.util.stream.Stream<T> 是Java 8新加入的最常用的流接口。（这并不是一个函数式接口。）
    获取一个流非常简单，有以下几种常用的方式：
        所有的Collection 集合都可以通过stream 默认方法获取流；
            default Stream<E> stream()
        Stream 接口的静态方法of 可以获取数组对应的流。
            static <T> Stream<T> of(T... values)
            参数是一个可变参数，那么我们就可以传递一个数组
 */
public class Dwmo02GetStream {
    public static void main(String[] args) {
        //把集合转换为Stream流
        List<String> list = new ArrayList<>();
        Stream<String> stream1 = list.stream();

        Set<String> set = new HashSet<>();
        Stream<String> stream2 = set.stream();

        Map<String,String> map = new HashMap<>();
        //获取键，存储到一个Set集合中
        Set<String> keySet = map.keySet();
        Stream<String> stream3 = keySet.stream();

        //存储值，存储到一个Collection集合中
        Collection<String> values = map.values();
        Stream<String> stream4 = values.stream();

        //获取键值对（键与值的映射关系entrySet）
        Set<Map.Entry<String, String>> entries = map.entrySet();
        Stream<Map.Entry<String, String>> stream5 = entries.stream();

        //把数组转换为stream流
        Stream<Integer> stream6 = Stream.of(1, 2, 3, 4, 5);

        //可变参数可以传递数组
        Integer[] arr = {1,2,3,4,5};
        Stream<Integer> stream7 = Stream.of(arr);
        String[] arr2 = {"a","bb","ccc"};
        Stream<String> stream8 = Stream.of(arr2);
    }
}
```

### 05 Stream流中的常用方法 forEach

```java
package com.itheima.demo07.Function;

import java.util.stream.Stream;

/*
    Strewam流中的常用方法_forEach
    void forEach(Consumer<? super T> action);
    该方法接收一个Consumer 接口函数，会将每一个流元素交给该函数进行处理。
    Consumer接口是一个消费型的函数式接口，可以传递Lambda表达式，消费数据

    简单记：
        forEach方法，用来遍历流中的数据
        是一个终结方法，遍历之后不能继续调用Stream流中的其他方法
 */
public class Demo02Stream_forEach {
    public static void main(String[] args) {
        //获取一个Stream流
        Stream<String> stream = Stream.of("张三", "李四", "王五", "赵六", "田七");
        //使用Stream流中的方法forEach对Stream流中的数据进行遍历
        /*stream.forEach((String name)->{
            System.out.println(name);
        });*/

        stream.forEach((name)-> System.out.println(name));
    }
}
```

### 06 Stream流中的常用方法 filter

```java
package com.itheima.demo02.Stream;

import java.util.stream.Stream;

/*
    Stream流中的常用方法_filter：用于对Stream流中的数据进行过滤
    Stream<T> filter(Predicate<? super T> predicate);
    filter方法的参数Predicate是一个函数式接口，所以可以传达Lambda表达式，对数据进行过滤
    Predicate中的抽象方法：
        boolean test（T t）；
 */
public class Demo03Stream_filter {
    public static void main(String[] args) {
        //创建一个Stream流
        Stream<String> stream = Stream.of("张三丰", "张翠山", "赵敏", "周芷若", "张无忌");
        Stream<String> stream2 = stream.filter((String name) -> {
            return name.startsWith("张");
        });
        //遍历steam2流
        stream2.forEach(name-> System.out.println(name));
    }
}
```

### 07 Stream流的特点只能使用一次

```java
/*
    Stream流属于管道流，只能被消费（使用)一次
    第一个Stream流调用完毕，方法就会流转到下一个Stream上
    而这时第一个Stream流已经使用完毕，就会关闭了
    所以第一个Stream流就不能再调用方法了

 */
```

### 08_ Stream流中的常用方法map

```java
package com.itheima.demo02.Stream;

import java.util.stream.Stream;

/*
    如果将流中的元素映射到另一个流中，可以使用map方法
    <R> Stream <R> map (Function<? T,? extends R> mapper);
    该接口需要一个Function函数式接口参数，可以将当前流中的T类型数据转换成另一种R类型的流。
    Function中的抽象方法：
        R apply（T t）；
 */
public class Demo04Stream_map {
    public static void main(String[] args) {
        //获取一个Stream流
        Stream<String> stream = Stream.of("1", "2", "3", "4");
        //使用map方法，把字符串类型的整数，转换（映射）为Integer类型的整数
        Stream<Integer> stream2 = stream.map((String s) -> {
            return Integer.parseInt(s);
        });
        //遍历stream2
        stream2.forEach(i-> System.out.println(i));
    }
}
```

### 09 Stream流中的常用方法 count

```java
package com.itheima.demo02.Stream;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Stream;

/*
    Stream流中的常用方法_count:用于统计Stream中元素的个数
    long count（）；
    count方法是一个终结方法，返回值是一个long类型的整数
    所以不能再继续调用Stream流中的其他方法了
 */
public class Demo05Stream_count {
    public static void main(String[] args) {
        //获取一个Stream流
        List<Integer> list = new ArrayList<>();
        list.add(1);
        list.add(2);
        list.add(3);
        list.add(4);
        list.add(5);
        list.add(6);
        Stream<Integer> stream = list.stream();
        long count = stream.count();
        System.out.println(count);//6
    }
}
```

### 10 Stream流中的常用方法 limit

```java
package com.itheima.demo02.Stream;

import java.util.stream.Stream;

/*
    Stream流中的常用方法_limit:用于截取流中的元素
    方法可以对流进行截取，只取用前n个。方法签名：
    Stream<T> limit(long maxSize);
    参数是一个long型，如果集合当前长度大于参数则进行截取；否则不进行操作。
    limit方法是一个延迟方法，只是对流中的元素进行截取，返回的是一个新的流，所以可以继续调用Stream；流中的其他方法
 */
public class Demo06Stream_limit {
    public static void main(String[] args) {
        //获取一个Stream流
        String[] array = {"美羊羊","懒羊羊","喜羊羊","灰太狼","红太狼"};
        Stream<String> stream1 = Stream.of(array);
        Stream<String> stream2 = stream1.limit(3);
        //遍历stream2
        stream2.forEach(name-> System.out.println(name));//美羊羊 懒羊羊 喜羊羊
    }
}
```

### 11 Stream流中的常用方法skip

```java
package com.itheima.demo02.Stream;

import java.util.stream.Stream;

/*
    Stream流中的常用方法_skip:用于跳过元素
    如果希望跳过前几个元素，可以使用skip方法获取一个截取之后的新流：
    Stream<T> skip(long n);
        如果流的当前长度大于n，则跳过前n个；否则将会得到一个长度为0的空流。
 */
public class Demo07Stream_skip {
    public static void main(String[] args) {
        //获取一个Stream流
        String[] arr = {"美羊羊","喜洋洋","懒洋洋","灰太狼","红太狼"};
        Stream<String> stream = Stream.of(arr);
        //使用skip方法跳过前3个元素
        Stream<String> stream2 = stream.skip(3);
        //遍历stream2流
        stream2.forEach(name-> System.out.println(name));//灰太狼 红太狼
    }
}
```

### 12Stream流中的常用方法

```java
package com.itheima.demo02.Stream;

import java.util.stream.Stream;

/*
    Stream流中的常用方法_concat:用于把流组合到一起
    如果有两个流，希望合并成为一个流，那么可以使用Stream接口的静态方法concat
    static <T> Stream<T> concat(Stream<? extends T> a, Stream<? extends T> b)
 */
public class Demo08Stream_concat {
    public static void main(String[] args) {
        //创建一个Stream流
        Stream<String> stream1 = Stream.of("张三丰", "张翠山", "赵敏", "周芷若", "张无忌");
        //获取一个Stream流
        String[] arr = {"美羊羊","喜洋洋","懒洋洋","灰太狼","红太狼"};
        Stream<String> stream2 = Stream.of(arr);
        //把以上两个流组合为一个流
        Stream<String> concat = Stream.concat(stream1, stream2);
        //遍历concat流
        concat.forEach(name-> System.out.println(name));
    }
}
```

### 13练习：集合元素处理（传统方式）

```java
package com.itheima.demo03.Stream;

import java.util.ArrayList;

/*
    练习：集合元素处理（传统方式）
        现在有两个ArrayList 集合存储队伍当中的多个成员姓名，要求使用传统的for循环（或增强for循环）依次进行以
        下若干操作步骤：
        1. 第一个队伍只要名字为3个字的成员姓名；存储到一个新集合中。
        2. 第一个队伍筛选之后只要前3个人；存储到一个新集合中。
        3. 第二个队伍只要姓张的成员姓名；存储到一个新集合中。
        4. 第二个队伍筛选之后不要前2个人；存储到一个新集合中。
        5. 将两个队伍合并为一个队伍；存储到一个新集合中。
        6. 根据姓名创建Person 对象；存储到一个新集合中。
        7. 打印整个队伍的Person对象信息。
 */
public class Demo01StreamTeat {
    public static void main(String[] args) {
        //第一支队伍
        ArrayList<String> one = new ArrayList<String>();
        one.add("迪丽热巴");
        one.add("宋远桥");
        one.add("苏星河");
        one.add("石破天");
        one.add("石中玉");
        one.add("老子");
        one.add("庄子");
        one.add("洪七公");
        //1. 第一个队伍只要名字为3个字的成员姓名；存储到一个新集合中。
        ArrayList<String> one1 = new ArrayList<String>();
        for (String name : one) {
            if (name.length()==3){
                one1.add(name);
            }
        }
        //2. 第一个队伍筛选之后只要前3个人；存储到一个新集合中。
        ArrayList<String> one2 = new ArrayList<String>();
        for (int i = 0; i < 3; i++) {
            one2.add(one1.get(i));//i的值等于0，1,2
        }

        ArrayList<String> two = new ArrayList<String>();
        two.add("古力娜扎");
        two.add("张无忌");
        two.add("赵丽颖");
        two.add("张三丰");
        two.add("尼古拉斯赵四");
        two.add("张天爱");
        two.add("张二狗");
        //3. 第二个队伍只要姓张的成员姓名；存储到一个新集合中。
        ArrayList<String> two1 = new ArrayList<String>();
        for (String name : two) {
            if(name.startsWith("张")){
                two1.add(name);
            }
        }
        //4. 第二个队伍筛选之后不要前2个人；存储到一个新集合中。
        ArrayList<String> two2 = new ArrayList<String>();
        for (int i = 2; i < two1.size(); i++) {
            two2.add(two1.get(i));//i不包含0和1
        }
        //5. 将两个队伍合并为一个队伍；存储到一个新集合中。
        ArrayList<String> all = new ArrayList<String>();
        all.addAll(one2);
        all.addAll(two2);

        //6. 根据姓名创建Person 对象；存储到一个新集合中。
        ArrayList<Person> list = new ArrayList<Person>();
        for (String name : all) {
            list.add(new Person(name));
        }
        //7. 打印整个队伍的Person对象信息。
        for (Person person : list) {
            System.out.println(person);
        }
    }
}
```

### 14练习：集合元素处理（Stream方式）

```java
package com.itheima.demo03.Stream;

import java.util.ArrayList;
import java.util.stream.Stream;

/*
    练习：
        将上一题当中的传统for循环写法更换为Stream流式处理方式。两个集合的初始内容不变， Person 类的定义也不
变。
 */
public class Demo02StreamTest {
    public static void main(String[] args) {
        //第一支队伍
        ArrayList<String> one = new ArrayList<String>();
        one.add("迪丽热巴");
        one.add("宋远桥");
        one.add("苏星河");
        one.add("石破天");
        one.add("石中玉");
        one.add("老子");
        one.add("庄子");
        one.add("洪七公");
        //1. 第一个队伍只要名字为3个字的成员姓名；存储到一个新集合中。
        //2. 第一个队伍筛选之后只要前3个人；存储到一个新集合中。
        Stream<String> oneStrea = one.stream().filter(name -> name.length() == 3).limit(3);


        ArrayList<String> two = new ArrayList<String>();
        two.add("古力娜扎");
        two.add("张无忌");
        two.add("赵丽颖");
        two.add("张三丰");
        two.add("尼古拉斯赵四");
        two.add("张天爱");
        two.add("张二狗");
        //3. 第二个队伍只要姓张的成员姓名；存储到一个新集合中。
        //4. 第二个队伍筛选之后不要前2个人；存储到一个新集合中。
        Stream<String> twoStream = two.stream().filter(name -> name.startsWith("张")).skip(2);
        //5. 将两个队伍合并为一个队伍；存储到一个新集合中。
        //6. 根据姓名创建Person 对象；存储到一个新集合中。
        //7. 打印整个队伍的Person对象信息。
        Stream.concat(oneStrea,twoStream).map(name->new Person(name)).forEach(p-> System.out.println(p));
    }
}
```

### 15方法引用基本介绍

两种写法，完全等效：
Lambda表达式写法： s -> System.out.println(s);
方法引用写法： System.out::println
第一种语义是指：拿到参数之后经Lambda之手，继而传递给System.out.println 方法去处理。
第二种等效写法的语义是指：直接让System.out 中的println 方法来取代Lambda。两种写法的执行效果完全一
样，而第二种方法引用的写法复用了已有方案，更加简洁。
注:Lambda 中 传递的参数 一定是方法引用中 的那个方法可以接收的类型,否则会抛出异常

```java
package com.itheima.demo04.MethodReference;
/*
    定义一个打印的函数式接口
 */
@FunctionalInterface
public interface Printable {
    //定义字符串的抽象方法
    void print(String s);
}
```

```java
package com.itheima.demo04.MethodReference;

import org.w3c.dom.ls.LSOutput;

public class Demo01Printable {
    //定义一个方法，参数传递Printable接口，对字符串进行打印
    public static void printString(Printable p){
        p.print("HelloWord");
    }

    public static void main(String[] args) {
        //调用printable方法，方法的参数Printable是一个函数式接口，所以可以传递Lambda
        printString((s)-> System.out.println(s));

        /*
        分析Lambda表达式的目的，打印参数传递的字符串
        把参数s，传递给了System。out对象，调用out对象中的方法println对字符串进行了输出
        注意：
            1.System.out对象是已经存在的
            2.println方法也是直接存在的
        所以我们可以使用方法引用来优化Lambda表达式
        可以使用System.out方法直接引用（调用）方法
     */
        printString(System.out::println);
    }
}
```

### 16方法引用通过对象名引用成员方法

```java
package com.itheima.demo05.MethodReference;
/*
    定义一个打印的函数式接口
 */
@FunctionalInterface
public interface Printable {
    //定义字符串的抽象方法
    void print(String s);
}
```

```java
package com.itheima.demo05.MethodReference;

public class MethodRefObject {
    //定义一个成员方法，传递字符串，把字符串按照大写输出
    public void printUpperCaseString(String str){
        System.out.println(str.toUpperCase());
    }
}
```

```java
package com.itheima.demo05.MethodReference;
/*
    通过对象名引用成员方法、
    使用前提示对象名是已经存在的，成员方法也是已经存在的
    就可以使用对象名来引用成员方法
 */
public class Demo01ObjectMethodReference {
    //定义一个方法，方法的参数传递Printable接口
    public static void printString(Printable p){
        System.out.println("Hello");
    }

    public static void main(String[] args) {
        //调用printString方法，方法的参数Printable是一个函数式接口，所以可以传递Lambda表达式
        printString((s)->{
            //创建MethodReference对象
            MethodRefObject obj = new MethodRefObject();
            //调用MethRerObject对象中的成员方法printUpperCaseString，把字符串按照大写输出
            obj.printUpperCaseString(s);
        });

        /*
            使用方法引用优化Lambda
            对象是已经存在MethRerObject
            成员方法平printUpperCaseString
            所以我们可以使用对象名来引用成员方法
         */
        MethodRefObject obj = new MethodRefObject();
        printString(obj::printUpperCaseString);
    }
}
```

### 17方法引用通过类名引用静态成员方法

```java
package com.itheima.demo06.StaticMethodReference;
@FunctionalInterface
public interface Caclable {
    //定义一个方法，传递一个整数，对整数进行绝对值计算并返回
    int calAbs(int number);
}
```

```java
package com.itheima.demo06.StaticMethodReference;
/*
    通过类名引用静态成员方法
    类已经存在，静态成员方法也已经存在
    就可以通过类名直接引用静态成员方法
 */
public class Demo01StaticMethodReference {
    //定义一个方法，方法的参数传递要计算绝对值的整数，和函数式接口Calable
    public static  int method(int number,Caclable c){
        return c.calAbs(number);
    }

    public static void main(String[] args) {
        //调用method方法，传递绝对值得整数，和Lambda表达式
        int number = method(-10, (n) -> {
            //对参数进行绝对值的计算并返回结果
            return Math.abs(n);
        });
        System.out.println(number);

        /*
            使用方法引用优化Lambda表达式
            Math类是存在的
            avs计算绝对值的静态方法也是存在的
            所以我们可以直接通过类名引用静态方法
         */
        int number2 = method(-10, Math::abs);
        System.out.println(number2);
    }
}
```

### 18方法引 super用通过引用父类的成员方法

```java
package com.itheima.demo07SuperMethodReference;
/*
    定义见面的函数式接口
 */
public interface Greetable {
    //定义一个见面的方法
    void greet();
}
```

```java
package com.itheima.demo07SuperMethodReference;
/*
    定义父类
 */
public class Human {
    //定义一个sayhello的方法
    public void sayHello(){
        System.out.println("Hello,我是Human！");
    }
}
```

```java
package com.itheima.demo07SuperMethodReference;
/*
    定义子类
 */
public class Man extends Human{
    //子类重写父类sayHello的方法

    @Override
    public void sayHello() {
        System.out.println("Hello,我是Man");
    }

    //定义一个方法，参数传递Greetable接口
    public void method(Greetable g){
        g.greet();
    }

    public void show(){
        //调用method方法，方法的参数Greetable是一个函数是吧接口，所以可以传递Lambda
        /*method(()->{
            //创建父类Human对象
            Human h = new Human();
            //调用父类的sayHello方法
            h.sayHello();//Hello,我是Human！
        });*/

        //因为有子父类关系，所以存在一个关键字super，代表父类，所以我们可以直接使用super调用父类的成员方法
        /*method(()->{
            super.sayHello();//Hello,我是Human！
        });*/

        /*
            使用super引用父类的成员方法
            super已经是存在的
            父类的成员方法sayHello也是已经存在的
            所以我们可以直接使用super引用父类的成员方法
         */
        method(super::sayHello);//Hello,我是Human！
    }

    public static void main(String[] args) {
        new Man().show();
    }
}
```

### 19方法引用通过this引用本类的成员方法

```java
package com.itheima.demo08.ThisMethodReference;
/*
    定义一个富有的函数式接口
 */
@FunctionalInterface
public interface Richable {
    //定义一个想买什么就买什么的方法
    void buy();
}
```

```java
package com.itheima.demo08.ThisMethodReference;
/*
    使用this引用本类的成员方法
 */
public class Husband {
    //定义一个买房子的方法
    public void buyHouse(){
        System.out.println("北京二环内买一套四合院!");
    }

    //定义一个结婚的方法,参数传递Richable接口
    public void marry(Richable r){
        r.buy();
    }

    //定义一个非常高兴的方法
    public void soHappy(){
        //调用结婚的方法,方法的参数Richable是一个函数式接口,传递Lambda表达式
       /* marry(()->{
            //使用this.成员方法,调用本类买房子的方法
            this.buyHouse();
        });*/

        /*
            使用方法引用优化Lambda表达式
            this是已经存在的
            本类的成员方法buyHouse也是已经存在的
            所以我们可以直接使用this引用本类的成员方法buyHouse
         */
        marry(this::buyHouse);
    }

    public static void main(String[] args) {
        new Husband().soHappy();
    }
}
```

### 20方法引用类的构造器（构造方法）引用

```java
package com.itheima.demo09.ConstructorMethodReference;
/*
    定义一个创建Person对象的函数式接口
 */
@FunctionalInterface
public interface PersonBuilder {
    //定义一个方法，根据传递的姓名创建Person对象返回
    Person builderPerson(String name);
}
```

```java
package com.itheima.demo09.ConstructorMethodReference;

public class Person {
    private String name;

    public Person() {
    }

    public Person(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

```java
package com.itheima.demo09.ConstructorMethodReference;
/*
    类的构造器（构造方法）引用
 */
public class Demo {
    //定义一个方法，参数传递姓名和PersonBuilder接口，方法中通过姓名创建Person对象
    public static void printName(String name,PersonBuilder pb){
        Person person = pb.builderPerson(name);
        System.out.println(person.getName());
    }

    public static void main(String[] args) {
        //调用printName方法，方法的参数PersonBuilder接口是一个函数式接口，可以传递Lambda
        printName("迪丽热巴",(String name)->{
            return new Person(name);
        });

        /*
            使用方法引用优化Lambda表达式
            构造方法new Person(String name)已知
            创建对象已知 new
            就可以使用Person引用new创建对象
         */
        printName("古力娜扎",Person::new);//使用Person类的带参构造方法，通过传递的姓名创建对象
    }
}
```

### 21方法引用数组的构造器引用

```java
package com.itheima.demo10.ArrayMethodReference;
/*
    定义一个创建数组的函数式接口
 */
@FunctionalInterface
public interface ArrayBuilder {
    //定义一个创建int类型数组的方法，参数传递数组的长度，返回创建好的int类型数组
    int[] buildArray(int length);
}
```

```java
package com.itheima.demo10.ArrayMethodReference;
/*
    数组的构造器引用
 */
public class Demo {
    /*
        定义一个方法
        方法的参数传递创建数组的长度和Arraybuilder接口
        方法内部根据传递的长度使用ArrayBuilder中的方法创建数组并返回
     */
    public static int[] createArray(int length,ArrayBuilder ab){
        return ab.buildArray(length);
    }

    public static void main(String[] args) {
        //调用createArray方法，传递数组的长度和Lambda表达式
        int[] array1 = createArray(10, (len) -> {
            //根据数组的长度，创建数组并返回
            return new int[len];
        });

        System.out.println(array1.length);//10

        /*
            使用方法引用优化Lambda表达式
            已知创建的就是int[]数组
            数组的长度也是已知的
            就可以使用方法引用
            int[]引用new，根据参数传递的长度来创建数组
         */
        int[] array2 = createArray(10,int[]::new);
        System.out.println(array2.length);//10
    }
}
```

# javaweb

## 01_基础加强

### Junit使用步骤

* 测试分类：
	1. 黑盒测试：不需要写代码，给输入值，看程序是否能够输出期望的值。
	2. 白盒测试：需要写代码的。关注程序具体的执行流程。

* Junit使用：白盒测试
	* 步骤：
		1. 定义一个测试类(测试用例)
			* 建议：
				* 测试类名：被测试的类名Test		CalculatorTest
				* 包名：xxx.xxx.xx.test		cn.itcast.test

		2. 定义测试方法：可以独立运行
			* 建议：
				* 方法名：test测试的方法名		testAdd()  
				* 返回值：void
				* 参数列表：空参

		3. 给方法加@Test
		4. 导入junit依赖环境

	* 判定结果：
		* 红色：失败
		* 绿色：成功
		* 一般我们会使用断言操作来处理结果
			* Assert.assertEquals(期望的结果,运算的结果);

	* 补充：
		* @Before:
			* 修饰的方法会在测试方法之前被自动执行
		* @After:
			* 修饰的方法会在测试方法执行之后自动被执行

```java
package cn.itcast.test;

import cn.itcast.junit.Calculator;
import org.junit.After;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

public class CalculatorTest {

    /**
     * 初始化方法
     * 用于资源申请，所有测试方法在执行之前都会先执行该方法
     */
    @Before
    public void init(){
        System.out.println("int...");
    }

    /**
     * 释放资源方法
     * 在所有测试方法执行完后，都会自动执行该方法
     */
    @After
    public void close(){
        System.out.println("close...");
    }

    /**
     * 测试add方法
     */
    @Test
    public void testAdd() {
        //System.out.println("我被执行了");
        //1.创建计算器对象
        System.out.println("testAdd...");
        Calculator c = new Calculator();
        //2.调用add方法
        int result = c.add(1, 2);
        //System.out.println(result);
        //3.断言 我断言结果是3
        Assert.assertEquals(3,result);//绿色
    }

    @Test
    public void testSub(){
        //1.创建计算器对象
        Calculator c = new Calculator();
        //2.调用add方法
        int result = c.sub(1, 1);
        System.out.println("testSub...");
        //3.断言 我断言结果是3
        Assert.assertEquals(0,result);//绿色
    }
}
```

### 反射：框架设计的灵魂

	* 框架：半成品软件。可以在框架的基础上进行软件开发，简化编码
	* 反射：将类的各个组成部分封装为其他对象，这就是反射机制
		* 好处：
			1. 可以在程序运行过程中，操作这些对象。
			2. 可以解耦，提高程序的可扩展性。

#### 获取Class对象的方式


	* 获取Class对象的方式：
		1. Class.forName("全类名")：将字节码文件加载进内存，返回Class对象
			* 多用于配置文件，将类名定义在配置文件中。读取文件，加载类
		2. 类名.class：通过类名的属性class获取
			* 多用于参数的传递
		3. 对象.getClass()：getClass()方法在Object类中定义着。
			* 多用于对象的获取字节码的方式
			
		* 结论：
			同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。

```java
//* 获取Class对象的方式示例代码
package cn.itcast.Reflect;

import cn.itcast.domain.Person;

/*
    获取Class对象的方式：
	1. Class.forName("全类名")：将字节码文件加载进内存，返回Class对象
	2. 类名.class：通过类名的属性class获取
	3. 对象.getClass()：getClass()方法在Object类中定义着。
 */
public class ReflectDemo1 {
    public static void main(String[] args) throws ClassNotFoundException {
        //	1. Class.forName("全类名")：将字节码文件加载进内存，返回Class对象
        Class cls1 = Class.forName("cn.itcast.domain.Person");
        System.out.println(cls1);//class cn.itcast.domain.Person
        //2. 类名.class：通过类名的属性class获取
        Class cls2 = Person.class;
        System.out.println(cls2);//class cn.itcast.domain.Person
        //3. 对象.getClass()：getClass()方法在Object类中定义着。
        Person p = new Person();
        Class cls3 = p.getClass();
        System.out.println(cls3);//class cn.itcast.domain.Person

        //==比较三个对象
        System.out.println(cls1==cls2);//true
        System.out.println(cls1==cls3);//true

    }
}
```

#### Class对象功能（方法使用未学习）


	* Class对象功能：
		* 获取功能：
			1. 获取成员变量们
				* Field[] getFields() ：获取所有public修饰的成员变量
				* Field getField(String name)   获取指定名称的 public修饰的成员变量
	
				* Field[] getDeclaredFields()  获取所有的成员变量，不考虑修饰符
				* Field getDeclaredField(String name)  
			2. 获取构造方法们
				* Constructor<?>[] getConstructors()  
				* Constructor<T> getConstructor(类<?>... parameterTypes)  
	
				* Constructor<T> getDeclaredConstructor(类<?>... parameterTypes)  
				* Constructor<?>[] getDeclaredConstructors()  
			3. 获取成员方法们：
				* Method[] getMethods()  
				* Method getMethod(String name, 类<?>... parameterTypes)  
	
				* Method[] getDeclaredMethods()  
				* Method getDeclaredMethod(String name, 类<?>... parameterTypes)  
	
			4. 获取全类名	
				* String getName()  


	* Field：成员变量
		* 操作：
			1. 设置值
				* void set(Object obj, Object value)  
			2. 获取值
				* get(Object obj) 
	
			3. 忽略访问权限修饰符的安全检查
				* setAccessible(true):暴力反射
	
	* Constructor:构造方法
		* 创建对象：
			* T newInstance(Object... initargs)  
	
			* 如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法


	* Method：方法对象
		* 执行方法：
			* Object invoke(Object obj, Object... args)  
	
		* 获取方法名称：
			* String getName:获取方法名

#### 案例


	* 案例：
		* 需求：写一个"框架"，不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中任意方法
			* 实现：
				1. 配置文件
				2. 反射
			* 步骤：
				1. 将需要创建的对象的全类名和需要执行的方法定义在配置文件中
				2. 在程序中加载读取配置文件
				3. 使用反射技术来加载类文件进内存
				4. 创建对象
				5. 执行方法

```java
package cn.itcast.Reflect;

import cn.itcast.domain.Person;
import cn.itcast.domain.Student;

import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Method;
import java.util.Properties;

/**
 * 框架类
 */
public class ReflectTest {
    public static void main(String[] args) throws Exception {
        //可以创建任意类的对象，可以执行任意方法

        /*
            前提：不能改变该类的任何代码。可以创建任意类的对象，可以执行任意方法
         */
        /*Person p = new Person();
        p.eat();*/

        /*Student stu = new Student();
        stu.sleep();*/

        //1.加载配置文件
        //1.1创建Properties对象
        Properties pro = new Properties();
        //1.2加载配置文件，转换为一个集合
        //1.2.1获取class目录下的配置文件
        ClassLoader classLoader = ReflectTest.class.getClassLoader();
        InputStream is = classLoader.getResourceAsStream("pro.properties");
        pro.load(is);

        //2.获取配置文件中定义的数据
        String className = pro.getProperty("className");
        String methodName = pro.getProperty("methodName");

        //3.加载该类进内存
        Class cls = Class.forName(className);
        //4.创建对象
        Object obj = cls.newInstance();
        //5.获取方法对象
        Method method = cls.getMethod(methodName);
        //6.执行方法
        method.invoke(obj);
    }
}
```

![Java代码的三个阶段](D:\SQL\笔记\基础加强\Java代码的三个阶段.bmp)

### 注解

	* 概念：说明程序的。给计算机看的
	* 注释：用文字描述程序的。给程序员看的
	
	* 定义：注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。
	* 概念描述：
		* JDK1.5之后的新特性
		* 说明程序的
		* 使用注解：@注解名称
	
	* 作用分类：
		①编写文档：通过代码里标识的注解生成文档【生成文档doc文档】
		②代码分析：通过代码里标识的注解对代码进行分析【使用反射】
		③编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】

#### JDK中预定义的一些注解

```
* JDK中预定义的一些注解
	* @Override	：检测被该注解标注的方法是否是继承自父类(接口)的
	* @Deprecated：该注解标注的内容，表示已过时
	* @SuppressWarnings：压制警告
		* 一般传递参数all  @SuppressWarnings("all")
```

```java
package cn.itcast.annotation;

import java.util.Date;

/**
 * JDK中预定义的一些注解
 *         * @Override    ：检测被该注解标注的方法是否是继承自父类(接口)的
 *         * @Deprecated：该注解标注的内容，表示已过时
 *         * @SuppressWarnings：压制警告
 */
@SuppressWarnings("all")
public class AnnoDemo2 {
    @Override
    public String toString() {
        return super.toString();
    }

    @Deprecated
    public void show1() {
        //有缺陷
    }


    public void show2() {
        //替代show1方法
    }

    public void demo(){
        show1();
        Date date = new Date();
    }
}
```

#### 自定义注解


	* 自定义注解
		* 格式：
			元注解
			public @interface 注解名称{
				属性列表;
			}
	
		* 本质：注解本质上就是一个接口，该接口默认继承Annotation接口
			* public interface MyAnno extends java.lang.annotation.Annotation {}
	
	* 属性：接口中的抽象方法
		* 要求：
		1. 属性的返回值类型有下列取值
				* 基本数据类型
				* String
				* 枚举
				* 注解
				* 以上类型的数组
	
		2. 定义了属性，在使用时需要给属性赋值
			1. 如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。
			2. 如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可。
			3. 数组赋值时，值使用{}包裹。如果数组中只有一个值，则{}可以省略


​	

```java
package cn.itcast.annotation;

public @interface Myanno2 {
}
```

```java
package cn.itcast.annotation;

public enum Person {
    P1,P2;
}
```

```java
package cn.itcast.annotation;

public @interface Myanno {
    int value();

    Person per();

    Myanno2 anno2();

    String[] strs();
    //String name() default "zhangsan";
    /*String show2();

    Person per();
    Myanno2 anno2();

    String[] strs();*/

    //Worker();
}
```

```java
package cn.itcast.annotation;



@Myanno(value = 12,per = Person.P1,anno2 = @Myanno2,strs = {"abc","bbb"})
public class Worker {
}
```

```
* 元注解：用于描述注解的注解
		* @Target：描述注解能够作用的位置
			* ElementType取值：
				* TYPE：可以作用于类上
				* METHOD：可以作用于方法上
				* FIELD：可以作用于成员变量上
		* @Retention：描述注解被保留的阶段
			* @Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到
		* @Documented：描述注解是否被抽取到api文档中
		* @Inherited：描述注解是否被子类继承
```



#### 在程序使用(解析)注解


	* 在程序使用(解析)注解：获取注解中定义的属性值
		1. 获取注解定义的位置的对象  （Class，Method,Field）
		2. 获取指定的注解
			* getAnnotation(Class)
			//其实就是在内存中生成了一个该注解接口的子类实现对象
	
		            public class ProImpl implements Pro{
		                public String className(){
		                    return "cn.itcast.annotation.Demo1";
		                }
		                public String methodName(){
		                    return "show";
		                }
		            }
		3. 调用注解中的抽象方法获取配置的属性值


	* 案例：简单的测试框架
	* 小结：
		1. 以后大多数时候，我们会使用注解，而不是自定义注解
		2. 注解给谁用？
			1. 编译器
			2. 给解析程序用
		3. 注解不是程序的一部分，可以理解为注解就是一个标签

* 案例：简单的测试框架
* 小结：
	1. 以后大多数时候，我们会使用注解，而不是自定义注解
	2. 注解给谁用？
		1. 编译器
		2. 给解析程序用
	3. 注解不是程序的一部分，可以理解为注解就是一个标签

## 02_MySQL_基础

### 今日内容

1. 数据库的基本概念


2. MySQL数据库软件
   1. 安装
   2. 卸载
   3. 配置

3. SQL


### 数据库的基本概念

	1. 数据库的英文单词： DataBase 简称 ： DB
	2. 什么数据库？
		* 用于存储和管理数据的仓库。
	
	3. 数据库的特点：
		1. 持久化存储数据的。其实数据库就是一个文件系统
		2. 方便存储和管理数据
		3. 使用了统一的方式操作数据库 -- SQL


​	

	4. 常见的数据库软件
		* 参见《MySQL基础.pdf》


### MySQL数据库软件

	1. 安装
		* 参见《MySQL基础.pdf》
	2. 卸载
		1. 去mysql的安装目录找到my.ini文件
			* 复制 datadir="C:/ProgramData/MySQL/MySQL Server 5.5/Data/"
		2. 卸载MySQL
		3. 删除C:/ProgramData目录下的MySQL文件夹。
		
	3. 配置
		* MySQL服务启动
			1. 手动。
			2. cmd--> services.msc 打开服务的窗口
			3. 使用管理员打开cmd
				* net start mysql : 启动mysql的服务
				* net stop mysql:关闭mysql服务
		* MySQL登录
			1. mysql -uroot -p密码
			2. mysql -hip -uroot -p连接目标的密码
			3. mysql --host=ip --user=root --password=连接目标的密码
		* MySQL退出
			1. exit
			2. quit
	
		* MySQL目录结构
			1. MySQL安装目录：basedir="D:/develop/MySQL/"
				* 配置文件 my.ini
			2. MySQL数据目录：datadir="C:/ProgramData/MySQL/MySQL Server 5.5/Data/"
				* 几个概念
					* 数据库：文件夹
					* 表：文件
					* 数据：数据



### SQL

	1.什么是SQL？
		Structured Query Language：结构化查询语言
		其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。
		
	2.SQL通用语法
		1. SQL 语句可以单行或多行书写，以分号结尾。
		2. 可使用空格和缩进来增强语句的可读性。
		3. MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。
		4. 3 种注释
			* 单行注释: -- 注释内容 或 # 注释内容(mysql 特有) 
			* 多行注释: /* 注释 */
		
	3. SQL分类
		1) DDL(Data Definition Language)数据定义语言
			用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等
		2) DML(Data Manipulation Language)数据操作语言
			用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等
		3) DQL(Data Query Language)数据查询语言
			用来查询数据库中表的记录(数据)。关键字：select, where 等
		4) DCL(Data Control Language)数据控制语言(了解)
			用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等

### DDL:操作数据库、表

	1. 操作数据库：CRUD
		1. C(Create):创建
			* 创建数据库：
				* create database 数据库名称;
			* 创建数据库，判断不存在，再创建：
				* create database if not exists 数据库名称;
			* 创建数据库，并指定字符集
				* create database 数据库名称 character set 字符集名;
	
			* 练习： 创建db4数据库，判断是否存在，并制定字符集为gbk
				* create database if not exists db4 character set gbk;
		2. R(Retrieve)：查询
			* 查询所有数据库的名称:
				* show databases;
			* 查询某个数据库的字符集:查询某个数据库的创建语句
				* show create database 数据库名称;
		3. U(Update):修改
			* 修改数据库的字符集
				* alter database 数据库名称 character set 字符集名称;
		4. D(Delete):删除
			* 删除数据库
				* drop database 数据库名称;
			* 判断数据库存在，存在再删除
				* drop database if exists 数据库名称;
		5. 使用数据库
			* 查询当前正在使用的数据库名称
				* select database();
			* 使用数据库
				* use 数据库名称;


	2. 操作表
		1. C(Create):创建
			1. 语法：
				create table 表名(
					列名1 数据类型1,
					列名2 数据类型2,
					....
					列名n 数据类型n
				);
				* 注意：最后一列，不需要加逗号（,）
				* 数据库类型：
					1. int：整数类型
						* age int,
					2. double:小数类型
						* score double(5,2)
					3. date:日期，只包含年月日，yyyy-MM-dd
					4. datetime:日期，包含年月日时分秒	 yyyy-MM-dd HH:mm:ss
					5. timestamp:时间错类型	包含年月日时分秒	 yyyy-MM-dd HH:mm:ss	
						* 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值
	
					6. varchar：字符串
						* name varchar(20):姓名最大20个字符
						* zhangsan 8个字符  张三 2个字符


			* 创建表
				create table student(
					id int,
					name varchar(32),
					age int ,
					score double(4,1),
					birthday date,
					insert_time timestamp
				);
			* 复制表：
				* create table 表名 like 被复制的表名;	  	
		2. R(Retrieve)：查询
			* 查询某个数据库中所有的表名称
				* show tables;
			* 查询表结构
				* desc 表名;
		3. U(Update):修改
			1. 修改表名
				alter table 表名 rename to 新的表名;
			2. 修改表的字符集
				alter table 表名 character set 字符集名称;
			3. 添加一列
				alter table 表名 add 列名 数据类型;
			4. 修改列名称 类型
				alter table 表名 change 列名 新列别 新数据类型;
				alter table 表名 modify 列名 新数据类型;
			5. 删除列
				alter table 表名 drop 列名;
		4. D(Delete):删除
			* drop table 表名;
			* drop table  if exists 表名 ;

* 客户端图形化工具：SQLYog

### DML：增删改表中数据

	1. 添加数据：
		* 语法：
			* insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n);
		* 注意：
			1. 列名和值要一一对应。
			2. 如果表名后，不定义列名，则默认给所有列添加值
				insert into 表名 values(值1,值2,...值n);
			3. 除了数字类型，其他类型需要使用引号(单双都可以)引起来
	2. 删除数据：
		* 语法：
			* delete from 表名 [where 条件]
		* 注意：
			1. 如果不加条件，则删除表中所有记录。
			2. 如果要删除所有记录
				1. delete from 表名; -- 不推荐使用。有多少条记录就会执行多少次删除操作
				2. TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。
	3. 修改数据：
		* 语法：
			* update 表名 set 列名1 = 值1, 列名2 = 值2,... [where 条件];
	
		* 注意：
			1. 如果不加任何条件，则会将表中所有记录全部修改。



### DQL：查询表中的记录

	* select * from 表名;
	
	1. 语法：
		select
			字段列表
		from
			表名列表
		where
			条件列表
		group by
			分组字段
		having
			分组之后的条件
		order by
			排序
		limit
			分页限定


	2. 基础查询
		1. 多个字段的查询
			select 字段名1，字段名2... from 表名；
			* 注意：
				* 如果查询所有字段，则可以使用*来替代字段列表。
		2. 去除重复：
			* distinct
		3. 计算列
			* 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算）
			* ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null
				* 表达式1：哪个字段需要判断是否为null
				* 如果该字段为null后的替换值。
		4. 起别名：
			* as：as也可以省略


	3. 条件查询
		1. where子句后跟条件
		2. 运算符
			* > 、< 、<= 、>= 、= 、<>
			* BETWEEN...AND  
			* IN( 集合) 
			* LIKE：模糊查询
				* 占位符：
					* _:单个任意字符
					* %：多个任意字符
			* IS NULL  
			* and  或 &&
			* or  或 || 
			* not  或 !
			
				-- 查询年龄大于20岁
	
				SELECT * FROM student WHERE age > 20;
				SELECT * FROM student WHERE age >= 20;
				
				-- 查询年龄等于20岁
				SELECT * FROM student WHERE age = 20;
				
				-- 查询年龄不等于20岁
				SELECT * FROM student WHERE age != 20;
				SELECT * FROM student WHERE age <> 20;
				
				-- 查询年龄大于等于20 小于等于30
				SELECT * FROM student WHERE age >= 20 &&  age <=30;
				SELECT * FROM student WHERE age >= 20 AND  age <=30;
				SELECT * FROM student WHERE age BETWEEN 20 AND 30;
				
				-- 查询年龄22岁，18岁，25岁的信息
				SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25
				SELECT * FROM student WHERE age IN (22,18,25);
				
				-- 查询英语成绩为null
				SELECT * FROM student WHERE english = NULL; -- 不对的。null值不能使用 = （!=） 判断	
				SELECT * FROM student WHERE english IS NULL;
				
				-- 查询英语成绩不为null
				SELECT * FROM student WHERE english  IS NOT NULL;



				-- 查询姓马的有哪些？ like
				SELECT * FROM student WHERE NAME LIKE '马%';
				
				-- 查询姓名第二个字是化的人
				SELECT * FROM student WHERE NAME LIKE "_化%";
				
				-- 查询姓名是3个字的人
				SELECT * FROM student WHERE NAME LIKE '___';
				
				-- 查询姓名中包含德的人
				SELECT * FROM student WHERE NAME LIKE '%德%';

## 03_MySQL约束

### 今日内容

	1. DQL:查询语句
		1. 排序查询
		2. 聚合函数
		3. 分组查询
		4. 分页查询
	
	2. 约束
	3. 多表之间的关系
	4. 范式
	5. 数据库的备份和还原

### DQL:查询语句

	1. 排序查询
		* 语法：order by 子句
			* order by 排序字段1 排序方式1 ，  排序字段2 排序方式2...
	
		* 排序方式：
			* ASC：升序，默认的。
			* DESC：降序。
	
		* 注意：
			* 如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。


	2. 聚合函数：将一列数据作为一个整体，进行纵向的计算。
		1. count：计算个数
			1. 一般选择非空的列：主键
			2. count(*)
		2. max：计算最大值
		3. min：计算最小值
		4. sum：计算和
		5. avg：计算平均值


		* 注意：聚合函数的计算，排除null值。
			解决方案：
				1. 选择不包含非空的列进行计算
				2. IFNULL函数
	
	3. 分组查询:
		1. 语法：group by 分组字段；
		2. 注意：
			1. 分组之后查询的字段：分组字段、聚合函数
			2. where 和 having 的区别？
				1. where 在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来
				2. where 后不可以跟聚合函数，having可以进行聚合函数的判断。
	
			-- 按照性别分组。分别查询男、女同学的平均分
			SELECT sex , AVG(math) FROM student GROUP BY sex;
			
			-- 按照性别分组。分别查询男、女同学的平均分,人数
			
			SELECT sex , AVG(math),COUNT(id) FROM student GROUP BY sex;
			
			--  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组
			SELECT sex , AVG(math),COUNT(id) FROM student WHERE math > 70 GROUP BY sex;
			
			--  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组,分组之后。人数要大于2个人
			SELECT sex , AVG(math),COUNT(id) FROM student WHERE math > 70 GROUP BY sex HAVING COUNT(id) > 2;
			
			SELECT sex , AVG(math),COUNT(id) 人数 FROM student WHERE math > 70 GROUP BY sex HAVING 人数 > 2;


​			

	4. 分页查询
		1. 语法：limit 开始的索引,每页查询的条数;
		2. 公式：开始的索引 = （当前的页码 - 1） * 每页显示的条数
			-- 每页显示3条记录 
	
			SELECT * FROM student LIMIT 0,3; -- 第1页
			
			SELECT * FROM student LIMIT 3,3; -- 第2页
			
			SELECT * FROM student LIMIT 6,3; -- 第3页
	
		3. limit 是一个MySQL"方言"


### 约束

	* 概念： 对表中的数据进行限定，保证数据的正确性、有效性和完整性。	
	* 分类：
		1. 主键约束：primary key
		2. 非空约束：not null
		3. 唯一约束：unique
		4. 外键约束：foreign key
	
	* 非空约束：not null，某一列的值不能为null
		1. 创建表时添加约束
			CREATE TABLE stu(
				id INT,
				NAME VARCHAR(20) NOT NULL -- name为非空
			);
		2. 创建表完后，添加非空约束
			ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL;
	
		3. 删除name的非空约束
			ALTER TABLE stu MODIFY NAME VARCHAR(20);
	
	* 唯一约束：unique，某一列的值不能重复
		1. 注意：
			* 唯一约束可以有NULL值，但是只能有一条记录为null
		2. 在创建表时，添加唯一约束
			CREATE TABLE stu(
				id INT,
				phone_number VARCHAR(20) UNIQUE -- 手机号
			);
		3. 删除唯一约束
			ALTER TABLE stu DROP INDEX phone_number;
		4. 在表创建完后，添加唯一约束
			ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE;
	
	* 主键约束：primary key。
		1. 注意：
			1. 含义：非空且唯一
			2. 一张表只能有一个字段为主键
			3. 主键就是表中记录的唯一标识
	
		2. 在创建表时，添加主键约束
			create table stu(
				id int primary key,-- 给id添加主键约束
				name varchar(20)
			);
	
		3. 删除主键
			-- 错误 alter table stu modify id int ;
			ALTER TABLE stu DROP PRIMARY KEY;
	
		4. 创建完表后，添加主键
			ALTER TABLE stu MODIFY id INT PRIMARY KEY;
	
		5. 自动增长：
			1.  概念：如果某一列是数值类型的，使用 auto_increment 可以来完成值得自动增长
	
			2. 在创建表时，添加主键约束，并且完成主键自增长
			create table stu(
				id int primary key auto_increment,-- 给id添加主键约束
				name varchar(20)
			);


​			

			3. 删除自动增长
			ALTER TABLE stu MODIFY id INT;
			4. 添加自动增长
			ALTER TABLE stu MODIFY id INT AUTO_INCREMENT;


	* 外键约束：foreign key,让表于表产生关系，从而保证数据的正确性。
		1. 在创建表时，可以添加外键
			* 语法：
				create table 表名(
					....
					外键列
					constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称)
				);
	
		2. 删除外键
			ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;
	
		3. 创建表之后，添加外键
			ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称);


​		

		4. 级联操作		1. 添加级联操作			语法：ALTER TABLE 表名 ADD CONSTRAINT 外键名称 					FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE  ;		2. 分类：			1. 级联更新：ON UPDATE CASCADE 			2. 级联删除：ON DELETE CASCADE 


### 数据库的设计

```sql
1. 多表之间的关系	
	1. 分类：		
	1. 一对一(了解)：			
		* 如：人和身份证			
		* 分析：一个人只有一个身份证，一个身份证只能对应一个人		
	2. 一对多(多对一)：			
		* 如：部门和员工			
		* 分析：一个部门有多个员工，一个员工只能对应一个部门		
	3. 多对多：			
		* 如：学生和课程			
		* 分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择	
	2. 实现关系：		
	1. 一对多(多对一)：			
		* 如：部门和员工			
		* 实现方式：在多的一方建立外键，指向一的一方的主键。		
	2. 多对多：			
		* 如：学生和课程			
		* 实现方式：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键     3. 一对一(了解)：			
		* 如：人和身份证			
		* 实现方式：一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键。	
	3. 案例		
	-- 创建旅游线路分类表 tab_category		
	-- cid 旅游线路分类主键，自动增长		
	-- cname 旅游线路分类名称非空，唯一，字符串 100
    
	CREATE TABLE tab_category (			
		cid INT PRIMARY KEY AUTO_INCREMENT,			
        cname VARCHAR(100) NOT NULL UNIQUE		
    );				
    -- 创建旅游线路表 tab_route		
    /*		rid 旅游线路主键，自动增长		
    rname 旅游线路名称非空，唯一，字符串 100		
    price 价格		
    rdate 上架时间，日期类型		
    cid 外键，所属分类		*/	
    
    CREATE TABLE tab_route(			
        rid INT PRIMARY KEY AUTO_INCREMENT,			
        rname VARCHAR(100) NOT NULL UNIQUE,			
        price DOUBLE,			
        rdate DATE,			
        cid INT,			
        FOREIGN KEY (cid) REFERENCES tab_category(cid)		
    );				
    /*创建用户表 tab_user		
    uid 用户主键，自增长		
    username 用户名长度 100，唯一，非空		
    password 密码长度 30，非空		
    name 真实姓名长度 100		
    birthday 生日		
    sex 性别，定长字符串 1		
    telephone 手机号，字符串 11		
    email 邮箱，字符串长度 100		*/		
    
    CREATE TABLE tab_user (			
        uid INT PRIMARY KEY AUTO_INCREMENT,			
        username VARCHAR(100) UNIQUE NOT NULL,			
        PASSWORD VARCHAR(30) NOT NULL,			
        NAME VARCHAR(100),			
        birthday DATE,			
        sex CHAR(1) DEFAULT '男',			
        telephone VARCHAR(11),			
        email VARCHAR(100)		);				
        
        /*创建收藏表 tab_favorite		
        rid 旅游线路 id，外键		
        date 收藏时间		
        uid 用户 id，外键		
        rid 和 uid 不能重复，设置复合主键，同一个用户不能收藏同一个线路两次		*/		
        
        CREATE TABLE tab_favorite (			
            rid INT, -- 线路id			
            DATE DATETIME,			
            uid INT, -- 用户id			
            -- 创建复合主键			
            PRIMARY KEY(rid,uid), -- 联合主键			
            FOREIGN KEY (rid) REFERENCES tab_route(rid),			
            FOREIGN KEY(uid) REFERENCES tab_user(uid)		
        );
```


​		

	2. 数据库设计的范式
		* 概念：设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求
	
			设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。
			目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。
	
		* 分类：
			1. 第一范式（1NF）：每一列都是不可分割的原子数据项
			2. 第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖）
				* 几个概念：
					1. 函数依赖：A-->B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A
						例如：学号-->姓名。  （学号，课程名称） --> 分数
					2. 完全函数依赖：A-->B， 如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值。
						例如：（学号，课程名称） --> 分数
					3. 部分函数依赖：A-->B， 如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。
						例如：（学号，课程名称） -- > 姓名
					4. 传递函数依赖：A-->B, B -- >C . 如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A
						例如：学号-->系名，系名-->系主任
					5. 码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码
						例如：该表中码为：（学号，课程名称）
						* 主属性：码属性组中的所有属性
						* 非主属性：除过码属性组的属性
						
			3. 第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）


### 数据库的备份和还原

	1. 命令行：
		* 语法：
			* 备份： mysqldump -u用户名 -p密码 数据库名称 > 保存的路径
			* 还原：
				1. 登录数据库
				2. 创建数据库
				3. 使用数据库
				4. 执行文件。source 文件路径
	2. 图形化工具：

## 04_MySQL多表&事务

### 今日内容

	1. 多表查询
	
	2. 事务
	
	3. DCL


### 多表查询：

	* 查询语法：
		select
			列名列表
		from
			表名列表
		where....
	* 准备sql
		# 创建部门表
		CREATE TABLE dept(
			id INT PRIMARY KEY AUTO_INCREMENT,
			NAME VARCHAR(20)
		);
		INSERT INTO dept (NAME) VALUES ('开发部'),('市场部'),('财务部');
		# 创建员工表
		CREATE TABLE emp (
			id INT PRIMARY KEY AUTO_INCREMENT,
			NAME VARCHAR(10),
			gender CHAR(1), -- 性别
			salary DOUBLE, -- 工资
			join_date DATE, -- 入职日期
			dept_id INT,
			FOREIGN KEY (dept_id) REFERENCES dept(id) -- 外键，关联部门表(部门表的主键)
		);
		INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES('孙悟空','男',7200,'2013-02-24',1);
		INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES('猪八戒','男',3600,'2010-12-02',2);
		INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES('唐僧','男',9000,'2008-08-08',2);
		INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES('白骨精','女',5000,'2015-10-07',3);
		INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES('蜘蛛精','女',4500,'2011-03-14',1);
	* 笛卡尔积：
		* 有两个集合A,B .取这两个集合的所有组成情况。
		* 要完成多表查询，需要消除无用的数据
	* 多表查询的分类：
		1. 内连接查询：
			1. 隐式内连接：使用where条件消除无用数据
				* 例子：
				-- 查询所有员工信息和对应的部门信息
	
				SELECT * FROM emp,dept WHERE emp.`dept_id` = dept.`id`;
				
				-- 查询员工表的名称，性别。部门表的名称
				SELECT emp.name,emp.gender,dept.name FROM emp,dept WHERE emp.`dept_id` = dept.`id`;
				
				SELECT 
					t1.name, -- 员工表的姓名
					t1.gender,-- 员工表的性别
					t2.name -- 部门表的名称
				FROM
					emp t1,
					dept t2
				WHERE 
					t1.`dept_id` = t2.`id`;


​	

			2. 显式内连接：
				* 语法： select 字段列表 from 表名1 [inner] join 表名2 on 条件
				* 例如：
					* SELECT * FROM emp INNER JOIN dept ON emp.`dept_id` = dept.`id`;	
					* SELECT * FROM emp JOIN dept ON emp.`dept_id` = dept.`id`;	
	
			3. 内连接查询：
				1. 从哪些表中查询数据
				2. 条件是什么
				3. 查询哪些字段
		2. 外链接查询：
			1. 左外连接：
				* 语法：select 字段列表 from 表1 left [outer] join 表2 on 条件；
				* 查询的是左表所有数据以及其交集部分。
				* 例子：
					-- 查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称
					SELECT 	t1.*,t2.`name` FROM emp t1 LEFT JOIN dept t2 ON t1.`dept_id` = t2.`id`;
			2. 右外连接：
				* 语法：select 字段列表 from 表1 right [outer] join 表2 on 条件；
				* 查询的是右表所有数据以及其交集部分。
				* 例子：
					SELECT 	* FROM dept t2 RIGHT JOIN emp t1 ON t1.`dept_id` = t2.`id`;
		3. 子查询：
			* 概念：查询中嵌套查询，称嵌套查询为子查询。
				-- 查询工资最高的员工信息
				-- 1 查询最高的工资是多少 9000
				SELECT MAX(salary) FROM emp;
				
				-- 2 查询员工信息，并且工资等于9000的
				SELECT * FROM emp WHERE emp.`salary` = 9000;
				
				-- 一条sql就完成这个操作。子查询
				SELECT * FROM emp WHERE emp.`salary` = (SELECT MAX(salary) FROM emp);
	
			* 子查询不同情况
				1. 子查询的结果是单行单列的：
					* 子查询可以作为条件，使用运算符去判断。 运算符： > >= < <= =
					* 
					-- 查询员工工资小于平均工资的人
					SELECT * FROM emp WHERE emp.salary < (SELECT AVG(salary) FROM emp);
				2. 子查询的结果是多行单列的：
					* 子查询可以作为条件，使用运算符in来判断
					-- 查询'财务部'和'市场部'所有的员工信息
					SELECT id FROM dept WHERE NAME = '财务部' OR NAME = '市场部';
					SELECT * FROM emp WHERE dept_id = 3 OR dept_id = 2;
					-- 子查询
					SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE NAME = '财务部' OR NAME = '市场部');
	
				3. 子查询的结果是多行多列的：
					* 子查询可以作为一张虚拟表参与查询
					-- 查询员工入职日期是2011-11-11日之后的员工信息和部门信息
					-- 子查询
					SELECT * FROM dept t1 ,(SELECT * FROM emp WHERE emp.`join_date` > '2011-11-11') t2
					WHERE t1.id = t2.dept_id;
					
					-- 普通内连接
					SELECT * FROM emp t1,dept t2 WHERE t1.`dept_id` = t2.`id` AND t1.`join_date` >  '2011-11-11'
	
		* 多表查询练习
	
				-- 部门表
				CREATE TABLE dept (
				  id INT PRIMARY KEY PRIMARY KEY, -- 部门id
				  dname VARCHAR(50), -- 部门名称
				  loc VARCHAR(50) -- 部门所在地
				);
				
				-- 添加4个部门
				INSERT INTO dept(id,dname,loc) VALUES 
				(10,'教研部','北京'),
				(20,'学工部','上海'),
				(30,'销售部','广州'),
				(40,'财务部','深圳');


​				
​				

				-- 职务表，职务名称，职务描述
				CREATE TABLE job (
				  id INT PRIMARY KEY,
				  jname VARCHAR(20),
				  description VARCHAR(50)
				);
				
				-- 添加4个职务
				INSERT INTO job (id, jname, description) VALUES
				(1, '董事长', '管理整个公司，接单'),
				(2, '经理', '管理部门员工'),
				(3, '销售员', '向客人推销产品'),
				(4, '文员', '使用办公软件');


​				
​				

				-- 员工表
				CREATE TABLE emp (
				  id INT PRIMARY KEY, -- 员工id
				  ename VARCHAR(50), -- 员工姓名
				  job_id INT, -- 职务id
				  mgr INT , -- 上级领导
				  joindate DATE, -- 入职日期
				  salary DECIMAL(7,2), -- 工资
				  bonus DECIMAL(7,2), -- 奖金
				  dept_id INT, -- 所在部门编号
				  CONSTRAINT emp_jobid_ref_job_id_fk FOREIGN KEY (job_id) REFERENCES job (id),
				  CONSTRAINT emp_deptid_ref_dept_id_fk FOREIGN KEY (dept_id) REFERENCES dept (id)
				);
				
				-- 添加员工
				INSERT INTO emp(id,ename,job_id,mgr,joindate,salary,bonus,dept_id) VALUES 
				(1001,'孙悟空',4,1004,'2000-12-17','8000.00',NULL,20),
				(1002,'卢俊义',3,1006,'2001-02-20','16000.00','3000.00',30),
				(1003,'林冲',3,1006,'2001-02-22','12500.00','5000.00',30),
				(1004,'唐僧',2,1009,'2001-04-02','29750.00',NULL,20),
				(1005,'李逵',4,1006,'2001-09-28','12500.00','14000.00',30),
				(1006,'宋江',2,1009,'2001-05-01','28500.00',NULL,30),
				(1007,'刘备',2,1009,'2001-09-01','24500.00',NULL,10),
				(1008,'猪八戒',4,1004,'2007-04-19','30000.00',NULL,20),
				(1009,'罗贯中',1,NULL,'2001-11-17','50000.00',NULL,10),
				(1010,'吴用',3,1006,'2001-09-08','15000.00','0.00',30),
				(1011,'沙僧',4,1004,'2007-05-23','11000.00',NULL,20),
				(1012,'李逵',4,1006,'2001-12-03','9500.00',NULL,30),
				(1013,'小白龙',4,1004,'2001-12-03','30000.00',NULL,20),
				(1014,'关羽',4,1007,'2002-01-23','13000.00',NULL,10);


​				
​				

				-- 工资等级表
				CREATE TABLE salarygrade (
				  grade INT PRIMARY KEY,   -- 级别
				  losalary INT,  -- 最低工资
				  hisalary INT -- 最高工资
				);
				
				-- 添加5个工资等级
				INSERT INTO salarygrade(grade,losalary,hisalary) VALUES 
				(1,7000,12000),
				(2,12010,14000),
				(3,14010,20000),
				(4,20010,30000),
				(5,30010,99990);
				
				-- 需求：
				
				-- 1.查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述
				/*
					分析：
						1.员工编号，员工姓名，工资，需要查询emp表  职务名称，职务描述 需要查询job表
						2.查询条件 emp.job_id = job.id
				
				*/
				SELECT 
					t1.`id`, -- 员工编号
					t1.`ename`, -- 员工姓名
					t1.`salary`,-- 工资
					t2.`jname`, -- 职务名称
					t2.`description` -- 职务描述
				FROM 
					emp t1, job t2
				WHERE 
					t1.`job_id` = t2.`id`;


​				
​				

				-- 2.查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置
				/*
					分析：
						1. 员工编号，员工姓名，工资 emp  职务名称，职务描述 job  部门名称，部门位置 dept
						2. 条件： emp.job_id = job.id and emp.dept_id = dept.id
				*/
				
				SELECT 
					t1.`id`, -- 员工编号
					t1.`ename`, -- 员工姓名
					t1.`salary`,-- 工资
					t2.`jname`, -- 职务名称
					t2.`description`, -- 职务描述
					t3.`dname`, -- 部门名称
					t3.`loc` -- 部门位置
				FROM 
					emp t1, job t2,dept t3
				WHERE 
					t1.`job_id` = t2.`id` AND t1.`dept_id` = t3.`id`;
				   
				-- 3.查询员工姓名，工资，工资等级
				/*
					分析：
						1.员工姓名，工资 emp  工资等级 salarygrade
						2.条件 emp.salary >= salarygrade.losalary and emp.salary <= salarygrade.hisalary
							emp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary
				*/
				SELECT 
					t1.ename ,
					t1.`salary`,
					t2.*
				FROM emp t1, salarygrade t2
				WHERE t1.`salary` BETWEEN t2.`losalary` AND t2.`hisalary`;


​				
​				

				-- 4.查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工资等级
				/*
					分析：
						1. 员工姓名，工资 emp ， 职务名称，职务描述 job 部门名称，部门位置，dept  工资等级 salarygrade
						2. 条件： emp.job_id = job.id and emp.dept_id = dept.id and emp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary
							
				*/
				SELECT 
					t1.`ename`,
					t1.`salary`,
					t2.`jname`,
					t2.`description`,
					t3.`dname`,
					t3.`loc`,
					t4.`grade`
				FROM 
					emp t1,job t2,dept t3,salarygrade t4
				WHERE 
					t1.`job_id` = t2.`id` 
					AND t1.`dept_id` = t3.`id`
					AND t1.`salary` BETWEEN t4.`losalary` AND t4.`hisalary`;


​				
​				

				-- 5.查询出部门编号、部门名称、部门位置、部门人数
				
				/*
					分析：
						1.部门编号、部门名称、部门位置 dept 表。 部门人数 emp表
						2.使用分组查询。按照emp.dept_id完成分组，查询count(id)
						3.使用子查询将第2步的查询结果和dept表进行关联查询
						
				*/
				SELECT 
					t1.`id`,t1.`dname`,t1.`loc` , t2.total
				FROM 
					dept t1,
					(SELECT
						dept_id,COUNT(id) total
					FROM 
						emp
					GROUP BY dept_id) t2
				WHERE t1.`id` = t2.dept_id;


​				

				-- 6.查询所有员工的姓名及其直接上级的姓名,没有领导的员工也需要查询
				
				/*
					分析：
						1.姓名 emp， 直接上级的姓名 emp
							* emp表的id 和 mgr 是自关联
						2.条件 emp.id = emp.mgr
						3.查询左表的所有数据，和 交集数据
							* 使用左外连接查询
					
				*/
				/*
				select
					t1.ename,
					t1.mgr,
					t2.`id`,
					t2.ename
				from emp t1, emp t2
				where t1.mgr = t2.`id`;
				
				*/
				
				SELECT 
					t1.ename,
					t1.mgr,
					t2.`id`,
					t2.`ename`
				FROM emp t1
				LEFT JOIN emp t2
				ON t1.`mgr` = t2.`id`;


### 事务

	1. 事务的基本介绍
		1. 概念：
			*  如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。
			
		2. 操作：
			1. 开启事务： start transaction;
			2. 回滚：rollback;
			3. 提交：commit;
		3. 例子：
			CREATE TABLE account (
				id INT PRIMARY KEY AUTO_INCREMENT,
				NAME VARCHAR(10),
				balance DOUBLE
			);
			-- 添加数据
			INSERT INTO account (NAME, balance) VALUES ('zhangsan', 1000), ('lisi', 1000);


​			

			SELECT * FROM account;
			UPDATE account SET balance = 1000;
			-- 张三给李四转账 500 元
			
			-- 0. 开启事务
			START TRANSACTION;
			-- 1. 张三账户 -500
			
			UPDATE account SET balance = balance - 500 WHERE NAME = 'zhangsan';
			-- 2. 李四账户 +500
			-- 出错了...
			UPDATE account SET balance = balance + 500 WHERE NAME = 'lisi';
			
			-- 发现执行没有问题，提交事务
			COMMIT;
			
			-- 发现出问题了，回滚事务
			ROLLBACK;
		4. MySQL数据库中事务默认自动提交
			
			* 事务提交的两种方式：
				* 自动提交：
					* mysql就是自动提交的
					* 一条DML(增删改)语句会自动提交一次事务。
				* 手动提交：
					* Oracle 数据库默认是手动提交事务
					* 需要先开启事务，再提交
			* 修改事务的默认提交方式：
				* 查看事务的默认提交方式：SELECT @@autocommit; -- 1 代表自动提交  0 代表手动提交
				* 修改默认提交方式： set @@autocommit = 0;


	2. 事务的四大特征：
		1. 原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。
		2. 持久性：当事务提交或回滚后，数据库会持久化的保存数据。
		3. 隔离性：多个事务之间。相互独立。
		4. 一致性：事务操作前后，数据总量不变
	3. 事务的隔离级别（了解）
		* 概念：多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。
		* 存在问题：
			1. 脏读：一个事务，读取到另一个事务中没有提交的数据
			2. 不可重复读(虚读)：在同一个事务中，两次读取到的数据不一样。
			3. 幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。
		* 隔离级别：
			1. read uncommitted：读未提交
				* 产生的问题：脏读、不可重复读、幻读
			2. read committed：读已提交 （Oracle）
				* 产生的问题：不可重复读、幻读
			3. repeatable read：可重复读 （MySQL默认）
				* 产生的问题：幻读
			4. serializable：串行化
				* 可以解决所有的问题
	
			* 注意：隔离级别从小到大安全性越来越高，但是效率越来越低
			* 数据库查询隔离级别：
				* select @@tx_isolation;
			* 数据库设置隔离级别：
				* set global transaction isolation level  级别字符串;
	
		* 演示：
			set global transaction isolation level read uncommitted;
			start transaction;
			-- 转账操作
			update account set balance = balance - 500 where id = 1;
			update account set balance = balance + 500 where id = 2;

### DCL：

* SQL分类：
	1. DDL：操作数据库和表
	2. DML：增删改表中数据
	3. DQL：查询表中数据
	4. DCL：管理用户，授权

* DBA：数据库管理员

* DCL：管理用户，授权
	1. 管理用户
		1. 添加用户：
		  * 语法：CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码';
		2. 删除用户：
			* 语法：DROP USER '用户名'@'主机名';
		3. 修改用户密码：
			
			UPDATE USER SET PASSWORD = PASSWORD('新密码') WHERE USER = '用户名';
			UPDATE USER SET PASSWORD = PASSWORD('abc') WHERE USER = 'lisi';
			
			SET PASSWORD FOR '用户名'@'主机名' = PASSWORD('新密码');
			SET PASSWORD FOR 'root'@'localhost' = PASSWORD('123');

			* mysql中忘记了root用户的密码？
				1. cmd -- > net stop mysql 停止mysql服务
					* 需要管理员运行该cmd

				2. 使用无验证方式启动mysql服务： mysqld --skip-grant-tables
				3. 打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功
				4. use mysql;
				5. update user set password = password('你的新密码') where user = 'root';
				6. 关闭两个窗口
				7. 打开任务管理器，手动结束mysqld.exe 的进程
				8. 启动mysql服务
				9. 使用新密码登录。
		4. 查询用户：
			-- 1. 切换到mysql数据库
			USE myql;
			-- 2. 查询user表
			SELECT * FROM USER;
			
			* 通配符： % 表示可以在任意主机使用用户登录数据库

	2. 权限管理：
		1. 查询权限：
			-- 查询权限
			SHOW GRANTS FOR '用户名'@'主机名';
			SHOW GRANTS FOR 'lisi'@'%';

		2. 授予权限：
			-- 授予权限
			grant 权限列表 on 数据库名.表名 to '用户名'@'主机名';
			-- 给张三用户授予所有权限，在任意数据库任意表上
			
			GRANT ALL ON *.* TO 'zhangsan'@'localhost';
		3. 撤销权限：
			-- 撤销权限：
			revoke 权限列表 on 数据库名.表名 from '用户名'@'主机名';
			REVOKE UPDATE ON db3.`account` FROM 'lisi'@'%';

## 05_JDBC-

### 02jdbc概念

Java DataBase Connectivity  Java 数据库连接

JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。

父类引用指向子类对象

![JDBC本质](C:/Users/Murphy/Pictures/JDBC本质.bmp)

### 03jdbc快速入门

* 步骤：
   1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar
   		1.复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下
   		2.右键-->Add As Library
   	2. 注册驱动
   	3. 获取数据库连接对象 Connection
   	4. 定义sql
   	5. 获取执行sql语句的对象 Statement
   	6. 执行sql，接受返回结果
   	7. 处理结果
   	8. 释放资源
   	   

   * ```java
     	package cn.itcast.jdbc;
      
      import java.sql.Connection;
      import java.sql.DriverManager;
      import java.sql.SQLException;
      import java.sql.Statement;
      
      public class JdbcDemo1 {
          public static void main(String[] args) throws ClassNotFoundException, SQLException {
              //1. 导入驱动jar包
              //2.注册驱动
              Class.forName("com.mysql.jdbc.Driver");
              //3.获取数据库连接对象
              Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/db3", "root", "123456");
              //4.定义sql语句
              String sql = "update account set balance = 500 where id = 1";
              //5.获取执行sql的对象 Statement
              Statement stmt = conn.createStatement();
              //6.执行sql
              int count = ((Statement) stmt).executeUpdate(sql);
              //7.处理结果
              System.out.println(count);
              //8.释放资源
              stmt.close();
              conn.close();
          }
      }
     ```

### 04详解DriverManager注册驱动

```
1. DriverManager：驱动管理对象
	* 功能：
	1. 注册驱动：告诉程序该使用哪一个数据库驱动jar
				static void registerDriver(Driver driver) :注册与给定的驱动程序 DriverManager 。 
				写代码使用：  Class.forName("com.mysql.jdbc.Driver");
				通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块
				 static {
				        try {
				            java.sql.DriverManager.registerDriver(new Driver());
				        } catch (SQLException E) {
				            throw new RuntimeException("Can't register driver!");
				        }
					}

	注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。
```

### 05详解DriverManager获取数据库连接

```

2. 获取数据库连接：

   * 方法：static Connection getConnection(String url, String user, String

     password) 

     参数：

     * url：指定连接的路径
       * 语法：jdbc:mysql://ip地址(域名):端口号/数据库名称
       * 例子：jdbc:mysql://localhost:3306/db3
       * 细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称
       * user：用户名
       * password：密码 
```

### 06详解 Connection.

```
2. Connection：数据库连接对象
		1. 功能：
			1. 获取执行sql 的对象
				* Statement createStatement()
				* PreparedStatement prepareStatement(String sql)  
			2. 管理事务：
				* 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务
				* 提交事务：commit() 
				* 回滚事务：rollback() 
```

### 07详解Statement

```
3. Statement：执行sql的对象
		1. 执行sql
			1. boolean execute(String sql) ：可以执行任意的sql 了解 
			2. int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句
				* 返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值>0的则执行成功，反之，则失败。
			3. ResultSet executeQuery(String sql)  ：执行DQL（select)语句
```

### 08jdbc练习insert语句

```java
package cn.itcast.jdbc;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;

/**
 * account表添加一条记录 insert语句
 */

public class JdbcDemo2 {
    public static void main(String[] args) {
        Statement stmt = null;
        Connection coon = null;
        try {
            //1.注册驱动
            Class.forName("com.mysql.jdbc.Driver");
            //2.定义SQL
            String sql = "insert into account values(null,'王五',3000)";
            //3.获取Connection对象
            coon = DriverManager.getConnection("jdbc:mysql:///mysql","root","123456");
            //4.获取sql的对象Statement
            stmt = coon.createStatement();
            //5.执行sql
            int count = stmt.executeUpdate(sql);
            //6.处理结果
            System.out.println(count);
            if (count > 0) {
                System.out.println("添加成功");
            }else {
                System.out.println("添加失败");
            }

        } catch (ClassNotFoundException | SQLException e) {
            e.printStackTrace();
        }finally {
            //7.释放资源
            //避免空指针异常
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException throwables) {
                    throwables.printStackTrace();
                }
            }

            if (coon != null) {
                try {
                    coon.close();
                } catch (SQLException throwables) {
                    throwables.printStackTrace();
                }
            }
        }
    }
}

```

### 9jdbc练习update语句

```java
package cn.itcast.jdbc;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;

/**
 * account表修改记录
 */

public class JdbcDemo3 {
    public static void main(String[] args) {
        Connection conn = null;
        Statement stmt = null;
        try {
            //1.注册驱动
            Class.forName("com.mysql.jdbc.Driver");
            //2.获取连接对象
            conn = DriverManager.getConnection("jdbc:mysql:///mysql", "root", "123456");
            //3.定义SQL
            String sql = "update account set balance = 1500 where id = 1";
            //4.获取执行sql对象
            stmt = conn.createStatement();
            //5.执行sql
            int count = stmt.executeUpdate(sql);
            //
            if (count > 0) {
                System.out.println("修改成功");
            }else {
                System.out.println("修改失败");
            }
        } catch (ClassNotFoundException | SQLException e) {
            e.printStackTrace();
        }finally {
            //7.释放资源
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException throwables) {
                    throwables.printStackTrace();
                }
            }

            if (conn != null) {
                try {
                    conn.close();
                } catch (SQLException throwables) {
                    throwables.printStackTrace();
                }
            }
        }
    }
}
```

10jdbc练习update、DD语句

### 11详解ResultSet基本使用

4. ResultSet：结果集对象,封装查询结果
		* boolean next(): 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true
		* getXxx(参数):获取数据
			* Xxx：代表数据类型   如： int getInt() ,	String getString()
			* 参数：
				1. int：代表列的编号,从1开始   如： getString(1)
				2. String：代表列名称。 如： getDouble("balance")
		
		
		```java
		package cn.itcast.jdbc;
	
	
	​	
	
		```

import java.sql.*;
		
	  /**
	   * account表修改记录
	   */
	  
	  public class JdbcDemo6 {
	      public static void main(String[] args) {
	          Connection conn = null;
	          Statement stmt = null;
	          ResultSet rs = null;
	          try {
	              //1.注册驱动
	              Class.forName("com.mysql.jdbc.Driver");
	              //2.获取连接对象
	              conn = DriverManager.getConnection("jdbc:mysql:///mysql", "root", "123456");
	              //3.定义SQL
	              String sql = "select * from account";
	              //4.获取执行sql对象
	              stmt = conn.createStatement();
	              //5.执行sql
	               rs = stmt.executeQuery(sql);
	              //6.处理结果
	              // 6.1让游标向下移动一行
	             rs.next();
	             //6.2获取数据
	              int id = rs.getInt(1);
	              String name = rs.getString("name");
	              double balance = rs.getDouble(3);
	              System.out.println(id + "---" + name +"---"+ balance);
	          } catch (ClassNotFoundException | SQLException e) {
	              e.printStackTrace();
	          }finally {
	              //7.释放资源
	              if (rs != null) {
	                  try {
	                      rs.close();
	                  } catch (SQLException throwables) {
	                      throwables.printStackTrace();
	                  }
	              }
	  
	              if (stmt != null) {
	                  try {
	                      stmt.close();
	                  } catch (SQLException throwables) {
	                      throwables.printStackTrace();
	                  }
	              }
	  
	              if (conn != null) {
	                  try {
	                      conn.close();
	                  } catch (SQLException throwables) {
	                      throwables.printStackTrace();
	                  }
	              }
	          }
	      }
	  }


​	  
​	  
​	  ```
​	
​	* 注意：
​		* 使用步骤：
​			1. 游标向下移动一行
​			2. 判断是否有数据
​			3. 获取数据
​	
​		   //循环判断游标是否是最后一行末尾。
​	    
​	    ```java
​	    package cn.itcast.jdbc;

### 12详解 ResultSet遍历结果集

```java
package cn.itcast.jdbc;


import java.sql.*;

/**
 * account表修改记录
 */

public class JdbcDemo7 {
    public static void main(String[] args) {
        Connection conn = null;
        Statement stmt = null;
        ResultSet rs = null;
        try {
            //1.注册驱动
            Class.forName("com.mysql.jdbc.Driver");
            //2.获取连接对象
            conn = DriverManager.getConnection("jdbc:mysql:///mysql", "root", "123456");
            //3.定义SQL
            String sql = "select * from account";
            //4.获取执行sql对象
            stmt = conn.createStatement();
            //5.执行sql
            rs = stmt.executeQuery(sql);
            //6.处理结果
            // 6.1让游标向下移动一行
           while (rs.next()) {
               //循环判断游标是否是最后一行末尾
                   //6.2获取数据
                   int id = rs.getInt(1);
                   String name = rs.getString("name");
                   double balance = rs.getDouble(3);
                   System.out.println(id + "---" + name +"---"+ balance);
           }
        } catch (ClassNotFoundException | SQLException e) {
            e.printStackTrace();
        }finally {
            //7.释放资源
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException throwables) {
                    throwables.printStackTrace();
                }
            }

            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException throwables) {
                    throwables.printStackTrace();
                }
            }

            if (conn != null) {
                try {
                    conn.close();
                } catch (SQLException throwables) {
                    throwables.printStackTrace();
                }
            }
        }
    }
}
```

### 13jdbc练习 select语句

* 练习：
	* 定义一个方法，查询emp表的数据将其封装为对象，然后装载集合，返回。
		1. 定义Emp类
		2. 定义方法 public List<Emp> findAll(){}
		3. 实现方法 select * from emp;

```java
package cn.itcast.domain;

import java.util.Date;

/**
 * 封装Emp表数据的JavaBean
 */
public class Emp {
    private int id;
    private String ename;
    private int job_id;
    private int mgr;
    private Date joindate;
    private double salary;
    private double bonus;
    private int dept_id;


    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getEname() {
        return ename;
    }

    public void setEname(String ename) {
        this.ename = ename;
    }

    public int getJob_id() {
        return job_id;
    }

    public void setJob_id(int job_id) {
        this.job_id = job_id;
    }

    public int getMgr() {
        return mgr;
    }

    public void setMgr(int mgr) {
        this.mgr = mgr;
    }

    public Date getJoindate() {
        return joindate;
    }

    public void setJoindate(Date joindate) {
        this.joindate = joindate;
    }

    public double getSalary() {
        return salary;
    }

    public void setSalary(double salary) {
        this.salary = salary;
    }


    public int getDept_id() {
        return dept_id;
    }

    public void setDept_id(int dept_id) {
        this.dept_id = dept_id;
    }


    public double getBonus() {
        return bonus;
    }

    public void setBonus(double bonus) {
        this.bonus = bonus;
    }


    @Override
    public String toString() {
        return "Emp{" +
                "id=" + id +
                ", ename='" + ename + '\'' +
                ", job_id=" + job_id +
                ", mgr=" + mgr +
                ", joindate=" + joindate +
                ", salary=" + salary +
                ", bonus=" + bonus +
                ", dept_id=" + dept_id +
                '}';
    }
}
```

```java
package cn.itcast.jdbc;




//import cn.itcast.util.JDBCUtils;

import cn.itcast.domain.Emp;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;

/**
 * * 定义一个方法，查询emp表的数据将其封装为对象，然后装载集合，返回。
 */
public class JDBCDemo8 {

    public static void main(String[] args) {
        List<Emp> list = new JDBCDemo8().findAll();
        System.out.println(list);
        System.out.println(list.size());
    }
    /**
     * 查询所有emp对象
     * @return
     */
    public List<Emp> findAll(){
        Connection conn = null;
        Statement stmt = null;
        ResultSet rs = null;
        List<Emp> list = null;
        try {
            //1.注册驱动
            Class.forName("com.mysql.jdbc.Driver");
            //2.获取连接
            conn = DriverManager.getConnection("jdbc:mysql:///mysql", "root", "123456");
            //3.定义sql
            String sql = "select * from emp";
            //4.获取执行sql的对象
            stmt = conn.createStatement();
            //5.执行sql
            rs = stmt.executeQuery(sql);
            //6.遍历结果集，封装对象，装载集合
            Emp emp = null;
            list = new ArrayList<Emp>();
            while(rs.next()){
                //获取数据
                int id = rs.getInt("id");
                String ename = rs.getString("ename");
                int job_id = rs.getInt("job_id");
                int mgr = rs.getInt("mgr");
                Date joindate = rs.getDate("joindate");
                double salary = rs.getDouble("salary");
                double bonus = rs.getDouble("bonus");
                int dept_id = rs.getInt("dept_id");
                // 创建emp对象,并赋值
                emp = new Emp();
                emp.setId(id);
                emp.setEname(ename);
                emp.setJob_id(job_id);
                emp.setMgr(mgr);
                emp.setJoindate(joindate);
                emp.setSalary(salary);
                emp.setBonus(bonus);
                emp.setDept_id(dept_id);

                //装载集合
                list.add(emp);
            }

        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            if(rs != null){
                try {
                    rs.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }

            if(stmt != null){
                try {
                    stmt.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }

            if(conn != null){
                try {
                    conn.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
        }
        return list;
    }


    /**
     * 演示JDBC工具类
     * @return
     */
/*    public List<Emp> findAll2(){
        Connection conn = null;
        Statement stmt = null;
        ResultSet rs = null;
        List<Emp> list = null;
        try {
            //1.注册驱动
            Class.forName("com.mysql.jdbc.Driver");
            //2.获取连接
            conn = DriverManager.getConnection("jdbc:mysql:///db3", "root", "root");
            //conn = JDBCUtils.getConnection();
            //3.定义sql
            String sql = "select * from emp";
            //4.获取执行sql的对象
            stmt = conn.createStatement();
            //5.执行sql
            rs = stmt.executeQuery(sql);
            //6.遍历结果集，封装对象，装载集合
            Emp emp = null;
            list = new ArrayList<Emp>();
            while(rs.next()){
                //获取数据
                int id = rs.getInt("id");
                String ename = rs.getString("ename");
                int job_id = rs.getInt("job_id");
                int mgr = rs.getInt("mgr");
                Date joindate = rs.getDate("joindate");
                double salary = rs.getDouble("salary");
                double bonus = rs.getDouble("bonus");
                int dept_id = rs.getInt("dept_id");
                // 创建emp对象,并赋值
                emp = new Emp();
                emp.setId(id);
                emp.setEname(ename);
                emp.setJob_id(job_id);
                emp.setMgr(mgr);
                emp.setJoindate(joindate);
                emp.setSalary(salary);
                emp.setBonus(bonus);
                emp.setDept_id(dept_id);

                //装载集合
                list.add(emp);
            }

        } catch (SQLException | ClassNotFoundException e) {
            e.printStackTrace();
        }finally {
            if(rs != null){
                try {
                    rs.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }

            if(stmt != null){
                try {
                    stmt.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }

            if(conn != null){
                try {
                    conn.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }

            //JDBCUtils.close(rs,stmt,conn);
        }
        return list;
    }*/

}
```

### 14jdbc工具类

* 目的：简化书写
* 分析：
	1. 注册驱动也抽取
	2. 抽取一个方法获取连接对象
		* 需求：不想传递参数（麻烦），还得保证工具类的通用性。
		* 解决：配置文件
			jdbc.properties
				url=
				user=
				password=

```sql
url=jdbc:mysql:///mysql
user=root
password=123456
driver=com.mysql.jdbc.Driver
```

```java
package cn.itcast.util;

import java.io.FileReader;
import java.io.IOException;
import java.net.URL;
import java.sql.*;
import java.util.Properties;

/**
 * JDBC工具类
 */
public class JDBCUtils {

    private static String url;
    private static String user;
    private static String password;
    private static String driver;
    /**
     *文件的读取只需要读取一次即可拿到这些值。使用静态代码块
     */
    static {
        //读取资源文件，获取值


        try {
            //1.创建Properties集合类
            Properties pro = new Properties();

            //获取src路径下的文件的方式--->ClassLoader类加载器
            ClassLoader classLoader = JDBCUtils.class.getClassLoader();
            URL res = classLoader.getResource("jdbc.properties");
            String path = res.getPath();
            System.out.println(path);
            //2.加载文件
            //pro.load(new FileReader("src/jdbc.properties"));
            pro.load(new FileReader(path));

            //3.获取数据，赋值
            url = pro.getProperty("url");
            user = pro.getProperty("user");
            password = pro.getProperty("password");
            driver = pro.getProperty("driver");
            //4.注册驱动
            Class.forName(driver);
        } catch (IOException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
    /**
     * 获取连接
     * @return连接对象
     */
    public static Connection getConnection() throws SQLException {
        return DriverManager.getConnection(url,user,password);
    }

    /**
     * 释放资源
     * @param stmt
     * @param conn
     */
    public static void close(Statement stmt,Connection conn){
        if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException throwables) {
                    throwables.printStackTrace();
                }
            }

        if (conn != null) {
                try {
                    conn.close();
                } catch (SQLException throwables) {
                    throwables.printStackTrace();
                }
            }
    }

    public static void close(ResultSet rs,Statement stmt, Connection conn){
        if (rs != null) {
            try {
                rs.close();
            } catch (SQLException throwables) {
                throwables.printStackTrace();
            }
        }

        if (stmt != null) {
            try {
                stmt.close();
            } catch (SQLException throwables) {
                throwables.printStackTrace();
            }
        }

        if (conn != null) {
            try {
                conn.close();
            } catch (SQLException throwables) {
                throwables.printStackTrace();
            }
        }

    }
}
```

```java
package cn.itcast.jdbc;




//import cn.itcast.util.JDBCUtils;

import cn.itcast.domain.Emp;
import cn.itcast.util.JDBCUtils;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

/**
 * * 定义一个方法，查询emp表的数据将其封装为对象，然后装载集合，返回。
 */
public class JDBCDemo8 {

    public static void main(String[] args) {
        List<Emp> list = new JDBCDemo8().findAll();
        System.out.println(list);
        System.out.println(list.size());
    }
    /**
     * 演示JDBC工具类
     * @return
     */
    public List<Emp> findAll(){
        Connection conn = null;
        Statement stmt = null;
        ResultSet rs = null;
        List<Emp> list = null;
        try {
            //1.注册驱动
            //Class.forName("com.mysql.jdbc.Driver");
            //2.获取连接
            //conn = DriverManager.getConnection("jdbc:mysql:///mysql", "root", "123456");
            conn = JDBCUtils.getConnection();
            //3.定义sql
            String sql = "select * from emp";
            //4.获取执行sql的对象
            stmt = conn.createStatement();
            //5.执行sql
            rs = stmt.executeQuery(sql);
            //6.遍历结果集，封装对象，装载集合
            Emp emp = null;
            list = new ArrayList<Emp>();
            while(rs.next()){
                //获取数据
                int id = rs.getInt("id");
                String ename = rs.getString("ename");
                int job_id = rs.getInt("job_id");
                int mgr = rs.getInt("mgr");
                Date joindate = rs.getDate("joindate");
                double salary = rs.getDouble("salary");
                double bonus = rs.getDouble("bonus");
                int dept_id = rs.getInt("dept_id");
                // 创建emp对象,并赋值
                emp = new Emp();
                emp.setId(id);
                emp.setEname(ename);
                emp.setJob_id(job_id);
                emp.setMgr(mgr);
                emp.setJoindate(joindate);
                emp.setSalary(salary);
                emp.setBonus(bonus);
                emp.setDept_id(dept_id);

                //装载集合
                list.add(emp);
            }

        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
           JDBCUtils.close(rs,stmt,conn);
        }
        return list;
    }
}
```

### 15jc练习登录案例

```
* 练习：
	* 需求：
		1. 通过键盘录入用户名和密码
		2. 判断用户是否登录成功
			* select * from user where username = "" and password = "";
			* 如果这个sql有查询结果，则成功，反之，则失败
```

```java
* 步骤：
1. 创建数据库表 user
			CREATE TABLE USER(
				id INT PRIMARY KEY AUTO_INCREMENT,
				username VARCHAR(32),
				PASSWORD VARCHAR(32)
			
			);

			INSERT INTO USER VALUES(NULL,'zhangsan','123');
			INSERT INTO USER VALUES(NULL,'lisi','234');

2. 代码实现：
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Scanner;

public class JDBCDemo9 {

  public static void main(String[] args) {
    // 1.键盘录入，接受用户名和密码
    Scanner sc = new Scanner(System.in);
    System.out.println("请输入用户名：");
    String username = sc.nextLine();
    System.out.println("请输入密码：");
    String password = sc.nextLine();
    // 2.调用方法
    boolean flag = new JDBCDemo9().login(username, password);
    // 3.判断结果，输出不同语句
    if (flag) {
      // 登录成功
      System.out.println("登录成功！");
    } else {
      System.out.println("用户名或密码错误！");
    }
  }

  /** 登录方法 */
  public boolean login(String username, String password) {
    if (username == null || password == null) {
      return false;
    }
    // 连接数据库判断是否登录成功
    Connection conn = null;
    Statement stmt = null;
    ResultSet rs = null;
    // 1.获取连接
    try {
      conn = JDBCUtils.getConnection();
      // 2.定义sql
      String sql =
          "select * from user where username = '"
              + username
              + "' and password = '"
              + password
              + "' ";
      // 3.获取执行sql的对象
      stmt = conn.createStatement();
      // 4.执行查询
      rs = stmt.executeQuery(sql);
      // 5.判断
      /* if(rs.next()){//如果有下一行，则返回true
          return true;
      }else{
          return false;
      }*/
      return rs.next(); // 如果有下一行，则返回true

    } catch (SQLException e) {
      e.printStackTrace();
    } finally {
      JDBCUtils.close(rs, stmt, conn);
    }
    return false;
  }
}

```



### 16jdbc各个类详解PreparedStatement

### 17jdc管理事务概述

### 18jdc管理事务实现

```java
1. 事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。
2. 操作：
	1. 开启事务
	2. 提交事务
	3. 回滚事务
3. 使用Connection对象来管理事务
	* 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务
		* 在执行sql之前开启事务
	* 提交事务：commit() 
		* 当所有sql都执行完提交事务
	* 回滚事务：rollback() 
		* 在catch中回滚事务

4. 代码：
import java.sql.PreparedStatement;
import java.sql.SQLException;

public class JDBCDemo10 {

  public static void main(String[] args) {
    Connection conn = null;
    PreparedStatement pstmt1 = null;
    PreparedStatement pstmt2 = null;

    try {
      // 1.获取连接
      conn = JDBCUtils.getConnection();
      // 开启事务
      conn.setAutoCommit(false);

      // 2.定义sql
      // 2.1 张三 - 500
      String sql1 = "update account set balance = balance - ? where id = ?";
      // 2.2 李四 + 500
      String sql2 = "update account set balance = balance + ? where id = ?";
      // 3.获取执行sql对象
      pstmt1 = conn.prepareStatement(sql1);
      pstmt2 = conn.prepareStatement(sql2);
      // 4. 设置参数
      pstmt1.setDouble(1, 500);
      pstmt1.setInt(2, 1);

      pstmt2.setDouble(1, 500);
      pstmt2.setInt(2, 2);
      // 5.执行sql
      pstmt1.executeUpdate();
      // 手动制造异常
      int i = 3 / 0;

      pstmt2.executeUpdate();
      // 提交事务
      conn.commit();
    } catch (Exception e) {
      // 事务回滚
      try {
        if (conn != null) {
          conn.rollback();
        }
      } catch (SQLException e1) {
        e1.printStackTrace();
      }
      e.printStackTrace();
    } finally {
      JDBCUtils.close(pstmt1, conn);
      JDBCUtils.close(pstmt2, null);
    }
  }
}

```



## 06_JDBC连接池&JDBCTemplate-

### 今日内容

	1. 数据库连接池
	
	2. Spring JDBC : JDBC Template

### 数据库连接池

	1. 概念：其实就是一个容器(集合)，存放数据库连接的容器。
		    当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。
	
	2. 好处：
		1. 节约资源
		2. 用户访问高效
	
	3. 实现：
		1. 标准接口：DataSource   javax.sql包下的
			1. 方法：
				* 获取连接：getConnection()
				* 归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接
	
		2. 一般我们不去实现它，有数据库厂商来实现
			1. C3P0：数据库连接池技术
			2. Druid：数据库连接池实现技术，由阿里巴巴提供的


	4. C3P0：数据库连接池技术
		* 步骤：
			1. 导入jar包 (两个) c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar ，
				* 不要忘记导入数据库驱动jar包
			2. 定义配置文件：
				* 名称： c3p0.properties 或者 c3p0-config.xml
				* 路径：直接将文件放在src目录下即可。
	
			3. 创建核心对象 数据库连接池对象 ComboPooledDataSource
			4. 获取连接： getConnection
		* 代码：
			 //1.创建数据库连接池对象
	        DataSource ds  = new ComboPooledDataSource();
	        //2. 获取连接对象
	        Connection conn = ds.getConnection();
	5. Druid：数据库连接池实现技术，由阿里巴巴提供的
		1. 步骤：
			1. 导入jar包 druid-1.0.9.jar
			2. 定义配置文件：
				* 是properties形式的
				* 可以叫任意名称，可以放在任意目录下
			3. 加载配置文件。Properties
			4. 获取数据库连接池对象：通过工厂来来获取  DruidDataSourceFactory
			5. 获取连接：getConnection
		* 代码：
			 //3.加载配置文件
	        Properties pro = new Properties();
	        InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream("druid.properties");
	        pro.load(is);
	        //4.获取连接池对象
	        DataSource ds = DruidDataSourceFactory.createDataSource(pro);
	        //5.获取连接
	        Connection conn = ds.getConnection();
		2. 定义工具类
			1. 定义一个类 JDBCUtils
			2. 提供静态代码块加载配置文件，初始化连接池对象
			3. 提供方法
				1. 获取连接方法：通过数据库连接池获取连接
				2. 释放资源
				3. 获取连接池的方法


		* 代码：
			public class JDBCUtils {
	
			    //1.定义成员变量 DataSource
			    private static DataSource ds ;
			
			    static{
			        try {
			            //1.加载配置文件
			            Properties pro = new Properties();
			            pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream("druid.properties"));
			            //2.获取DataSource
			            ds = DruidDataSourceFactory.createDataSource(pro);
			        } catch (IOException e) {
			            e.printStackTrace();
			        } catch (Exception e) {
			            e.printStackTrace();
			        }
			    }
			
			    /**
			     * 获取连接
			     */
			    public static Connection getConnection() throws SQLException {
			        return ds.getConnection();
			    }
			
			    /**
			     * 释放资源
			     */
			    public static void close(Statement stmt,Connection conn){
			       /* if(stmt != null){
			            try {
			                stmt.close();
			            } catch (SQLException e) {
			                e.printStackTrace();
			            }
			        }
			
			        if(conn != null){
			            try {
			                conn.close();//归还连接
			            } catch (SQLException e) {
			                e.printStackTrace();
			            }
			        }*/
			
			       close(null,stmt,conn);
			    }


​			

			    public static void close(ResultSet rs , Statement stmt, Connection conn){


​			

			        if(rs != null){
			            try {
			                rs.close();
			            } catch (SQLException e) {
			                e.printStackTrace();
			            }
			        }


​			

			        if(stmt != null){
			            try {
			                stmt.close();
			            } catch (SQLException e) {
			                e.printStackTrace();
			            }
			        }
			
			        if(conn != null){
			            try {
			                conn.close();//归还连接
			            } catch (SQLException e) {
			                e.printStackTrace();
			            }
			        }
			    }
			
			    /**
			     * 获取连接池方法
			     */
			
			    public static DataSource getDataSource(){
			        return  ds;
			    }
			
			}

### Spring JDBC

	* Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发
	* 步骤：
		1. 导入jar包
		2. 创建JdbcTemplate对象。依赖于数据源DataSource
			* JdbcTemplate template = new JdbcTemplate(ds);
	
		3. 调用JdbcTemplate的方法来完成CRUD的操作
			* update():执行DML语句。增、删、改语句
			* queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合
				* 注意：这个方法查询的结果集长度只能是1
			* queryForList():查询结果将结果集封装为list集合
				* 注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中
			* query():查询结果，将结果封装为JavaBean对象
				* query的参数：RowMapper
					* 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装
					* new BeanPropertyRowMapper<类型>(类型.class)
			* queryForObject：查询结果，将结果封装为对象
				* 一般用于聚合函数的查询
	
		4. 练习：
			* 需求：
				1. 修改1号数据的 salary 为 10000
				2. 添加一条记录
				3. 删除刚才添加的记录
				4. 查询id为1的记录，将其封装为Map集合
				5. 查询所有记录，将其封装为List
				6. 查询所有记录，将其封装为Emp对象的List集合
				7. 查询总记录数
	
			* 代码：
				
				import cn.itcast.domain.Emp;
				import cn.itcast.utils.JDBCUtils;
				import org.junit.Test;
				import org.springframework.jdbc.core.BeanPropertyRowMapper;
				import org.springframework.jdbc.core.JdbcTemplate;
				import org.springframework.jdbc.core.RowMapper;
				
				import java.sql.Date;
				import java.sql.ResultSet;
				import java.sql.SQLException;
				import java.util.List;
				import java.util.Map;
				
				public class JdbcTemplateDemo2 {
				
				    //Junit单元测试，可以让方法独立执行


​				

				    //1. 获取JDBCTemplate对象
				    private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource());
				    /**
				     * 1. 修改1号数据的 salary 为 10000
				     */
				    @Test
				    public void test1(){
				
				        //2. 定义sql
				        String sql = "update emp set salary = 10000 where id = 1001";
				        //3. 执行sql
				        int count = template.update(sql);
				        System.out.println(count);
				    }
				
				    /**
				     * 2. 添加一条记录
				     */
				    @Test
				    public void test2(){
				        String sql = "insert into emp(id,ename,dept_id) values(?,?,?)";
				        int count = template.update(sql, 1015, "郭靖", 10);
				        System.out.println(count);
				
				    }
				
				    /**
				     * 3.删除刚才添加的记录
				     */
				    @Test
				    public void test3(){
				        String sql = "delete from emp where id = ?";
				        int count = template.update(sql, 1015);
				        System.out.println(count);
				    }
				
				    /**
				     * 4.查询id为1001的记录，将其封装为Map集合
				     * 注意：这个方法查询的结果集长度只能是1
				     */
				    @Test
				    public void test4(){
				        String sql = "select * from emp where id = ? or id = ?";
				        Map<String, Object> map = template.queryForMap(sql, 1001,1002);
				        System.out.println(map);
				        //{id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20}
				
				    }
				
				    /**
				     * 5. 查询所有记录，将其封装为List
				     */
				    @Test
				    public void test5(){
				        String sql = "select * from emp";
				        List<Map<String, Object>> list = template.queryForList(sql);
				
				        for (Map<String, Object> stringObjectMap : list) {
				            System.out.println(stringObjectMap);
				        }
				    }
				
				    /**
				     * 6. 查询所有记录，将其封装为Emp对象的List集合
				     */
				
				    @Test
				    public void test6(){
				        String sql = "select * from emp";
				        List<Emp> list = template.query(sql, new RowMapper<Emp>() {
				
				            @Override
				            public Emp mapRow(ResultSet rs, int i) throws SQLException {
				                Emp emp = new Emp();
				                int id = rs.getInt("id");
				                String ename = rs.getString("ename");
				                int job_id = rs.getInt("job_id");
				                int mgr = rs.getInt("mgr");
				                Date joindate = rs.getDate("joindate");
				                double salary = rs.getDouble("salary");
				                double bonus = rs.getDouble("bonus");
				                int dept_id = rs.getInt("dept_id");
				
				                emp.setId(id);
				                emp.setEname(ename);
				                emp.setJob_id(job_id);
				                emp.setMgr(mgr);
				                emp.setJoindate(joindate);
				                emp.setSalary(salary);
				                emp.setBonus(bonus);
				                emp.setDept_id(dept_id);
				
				                return emp;
				            }
				        });


​				

				        for (Emp emp : list) {
				            System.out.println(emp);
				        }
				    }
				
				    /**
				     * 6. 查询所有记录，将其封装为Emp对象的List集合
				     */
				
				    @Test
				    public void test6_2(){
				        String sql = "select * from emp";
				        List<Emp> list = template.query(sql, new BeanPropertyRowMapper<Emp>(Emp.class));
				        for (Emp emp : list) {
				            System.out.println(emp);
				        }
				    }
				
				    /**
				     * 7. 查询总记录数
				     */
				
				    @Test
				    public void test7(){
				        String sql = "select count(id) from emp";
				        Long total = template.queryForObject(sql, Long.class);
				        System.out.println(total);
				    }
				
				}

## 07_HTML

### 1概念介绍软件架构

```
JavaWeb：
	* 使用Java语言开发基于互联网的项目

* 软件架构：
	1. C/S: Client/Server 客户端/服务器端
		* 在用户本地有一个客户端程序，在远程有一个服务器端程序
		* 如：QQ，迅雷...
		* 优点：
			1. 用户体验好
		* 缺点：
			1. 开发、安装，部署，维护 麻烦
	2. B/S: Browser/Server 浏览器/服务器端
		* 只需要一个浏览器，用户通过不同的网址(URL)，客户访问不同的服务器端程序
		* 优点：
			1. 开发、安装，部署，维护 简单
		* 缺点：
			1. 如果应用过大，用户的体验可能会受到影响
			2. 对硬件要求过高
```

### 2概念介绍资源分类

```
* B/S架构详解
	* 资源分类：
		1. 静态资源：
			* 使用静态网页开发技术发布的资源。
			* 特点：
				* 所有用户访问，得到的结果是一样的。
				* 如：文本，图片，音频、视频, HTML,CSS,JavaScript
				* 如果用户请求的是静态资源，那么服务器会直接将静态资源发送给浏览器。浏览器中内置了静态资源的解析引擎，可以展示静态资源
		2. 动态资源：
			* 使用动态网页及时发布的资源。
			* 特点：
				* 所有用户访问，得到的结果可能不一样。
				* 如：jsp/servlet,php,asp...
				* 如果用户请求的是动态资源，那么服务器会执行动态资源，转换为静态资源，再发送给浏览器
```

```
* 我们要学习动态资源，必须先学习静态资源！

	* 静态资源：
		* HTML：用于搭建基础网页，展示页面的内容
		* CSS：用于美化页面，布局页面
		* JavaScript：控制页面的元素，让页面有一些动态的效果
```

### 3概念介绍

```
概念：是最基础的网页开发语言
	* Hyper Text Markup Language 超文本标记语言
		* 超文本:
			* 超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本.
		* 标记语言:
			* 由标签构成的语言。<标签名称> 如 html，xml
			* 标记语言不是编程语言
```

5HTML快速入门

```
* 语法：
		1. html文档后缀名 .html 或者 .htm
		2. 标签分为
			1. 围堵标签：有开始标签和结束标签。如 <html> </html>
			2. 自闭和标签：开始标签和结束标签在一起。如 <br/>

		3. 标签可以嵌套：
			需要正确嵌套，不能你中有我，我中有你
			错误：<a><b></a></b>
			正确：<a><b></b></a>

		4. 在开始标签中可以定义属性。属性是由键值对构成，值需要用引号(单双都可)引起来
		5. html的标签不区分大小写，但是建议使用小写。

	* 代码：
		<html>
		
			<head>
				<title>title</title>
			</head>
			
			<body>
				<FONT color='red'>Hello World</font><br/>
				
				<font color='green'>Hello World</font>
			
			</body>
	
		</html>
```

### 4标签文件标签

```
1. 文件标签：构成html最基本的标签
		* html:html文档的根标签
		* head：头标签。用于指定html文档的一些属性。引入外部的资源
		* title：标题标签。
		* body：体标签
		* <!DOCTYPE html>：html5中定义该文档是html文档
```

### 5标签文本标签

```
文本标签：和文本有关的标签
		* 注释：<!-- 注释内容 -->
		* <h1> to <h6>：标题标签
			* h1~h6:字体大小逐渐递减
		* <p>：段落标签
		* <br>：换行标签
		* <hr>：展示一条水平线
			* 属性：
				* color：颜色
				* width：宽度
				* size：高度
				* align：对其方式
					* center：居中
					* left：左对齐
					* right：右对齐
		* <b>：字体加粗
		* <i>：字体斜体
		* <font>:字体标签
		* <center>:文本居中
			* 属性：
				* color：颜色
				* size：大小
				* face：字体

		* 属性定义：
			* color：
				1. 英文单词：red,green,blue
				2. rgb(值1，值2，值3)：值的范围：0~255  如  rgb(0,0,255)
				3. #值1值2值3：值的范围：00~FF之间。如： #FF00FF
			* width：
				1. 数值：width='20' ,数值的单位，默认是 px(像素)
				2. 数值%：占比相对于父元素的比例
```

### 6标签图片标签

```
 图片标签：
		* img：展示图片
			* 属性：
				* src：指定图片的位置

		* 代码：
			 <!--展示一张图片 img-->

		    <img src="image/jingxuan_2.jpg" align="right" alt="古镇" width="500" height="500"/>
		
		    <!--
		        相对路径
		            * 以.开头的路径
		                * ./：代表当前目录  ./image/1.jpg
		                * ../:代表上一级目录
		     -->
		
		    <img src="./image/jiangwai_1.jpg">
		
		    <img src="../image/jiangwai_1.jpg">
```

### 7标签列表标签

```
列表标签：
		* 有序列表：
			* ol:
			* li:
		* 无序列表：
			* ul:
			* li:
```

### 8标签链接标签

```
链接标签：
		* a:定义一个超链接
			* 属性：
				* href：指定访问资源的URL(统一资源定位符)
				* target：指定打开资源的方式
					* _self:默认值，在当前页面打开
					* _blank：在空白页面打开

* 代码：
	<!--超链接  a-->

	<a href="http://www.itcast.cn">点我</a>
	<br>
		
	<a href="http://www.itcast.cn" target="_self">点我</a>
	<br>
	<a href="http://www.itcast.cn" target="_blank">点我</a>
	<br>
		
	<a href="./5_列表标签.html">列表标签</a><br>
	<a href="mailto:itcast@itcast.cn">联系我们</a>
		
	<br>
	<a href="http://www.itcast.cn"><img src="image/jiangwai_1.jpg">		</a>
```

### 9标签块标签

```
div和span：
  * div:每一个div占满一整行。块级标签
  * span：文本信息在一行展示，行内标签 内联标签
```

### 10标签语义化标签

```
语义化标签：html5中为了提高程序的可读性，提供了一些标签。
		1. <header>：页眉
		2. <footer>：页脚
```

### 11标签表格标签

```
表格标签：
		* table：定义表格
			* width：宽度
			* border：边框
			* cellpadding：定义内容和单元格的距离
			* cellspacing：定义单元格之间的距离。如果指定为0，则单元格的线会合为一条、
			* bgcolor：背景色
			* align：对齐方式
		* tr：定义行
			* bgcolor：背景色
			* align：对齐方式
		* td：定义单元格
			* colspan：合并列
			* rowspan：合并行
		* th：定义表头单元格
		* <caption>：表格标题
		* <thead>：表示表格的头部分
		* <tbody>：表示表格的体部分
		* <tfoot>：表示表格的脚部分
```

## 08_HTML&CSS

### 2标签表单标签概述

```
* 表单：
	* 概念：用于采集用户输入的数据的。用于和服务器进行交互。
	* form：用于定义表单的。可以定义一个范围，范围代表采集用户数据的范围
        * 属性：
            * action：指定提交数据的URL
            * method:指定提交方式
                * 分类：一共7种，2种比较常用
                   * get：
                        1. 请求参数会在地址栏中显示。会封装到请求行中(HTTP协议后讲解)。
                        2. 请求参数大小是有限制的。
                        3. 不太安全。
                   * post：
                        2. 请求参数不会再地址栏中显示。会封装在请求体中(HTTP协议后讲解)
                        2. 请求参数的大小没有限制。
                        3. 较为安全。

        * 表单项中的数据要想被提交：必须指定其name属性
```

### 3标签表单标 input签表单项

```
* 表单项标签：
	* input：可以通过type属性值，改变元素展示的样式
		* type属性：
		* text：文本输入框，默认值
				* placeholder：指定输入框的提示信息，当输入框的内容发生变化，会自动清空提示信息	
		* password：密码输入框
		* radio:单选框
		* 注意：
			1. 要想让多个单选框实现单选的效果，则多个单选框的name属性值必须一样。
			2. 一般会给每一个单选框提供value属性，指定其被选中后提交的值
			3. checked属性，可以指定默认值
		* checkbox：复选框
			* 注意：
				1. 一般会给每一个单选框提供value属性，指定其被选中后提交的值
				2. checked属性，可以指定默认值

		* file：文件选择框
		* hidden：隐藏域，用于提交一些信息。
			* 按钮：
				* submit：提交按钮。可以提交表单
				* button：普通按钮
				* image：图片提交按钮
				* src属性指定图片的路径	

		 * label：指定输入项的文字描述信息
			   * 注意：
		* label的for属性一般会和 input 的 id属性值 对应。如果对应了，则点击label区域，会让input输入框获取焦点。
```

### 5标签表单标 select签表单项&textarea

```
* select: 下拉列表
	* 子元素：option，指定列表项
* textarea：文本域
	* cols：指定列数，每一行有多少个字符
	* rows：默认多少行。
```

### 7css概述

```
1. 概念： Cascading Style Sheets 层叠样式表
	* 层叠：多个样式可以作用在同一个html的元素上，同时生效
2. 好处：
	1. 功能强大
	2. 将内容展示和样式控制分离
		* 降低耦合度。解耦
		* 让分工协作更容易
		* 提高开发效率
```

### 8css与html结合方式

```css
	1. 内联样式
		 * 在标签内使用style属性指定css代码
		 * 如：<div style="color:red;">hello css</div>
	2. 内部样式
		* 在head标签内，定义style标签，style标签的标签体内容就是css代码
		* 如：
			<style>
		        div{
		            color:blue;
		        }
		
		    </style>
			<div>hello css</div>
	3. 外部样式
		1. 定义css资源文件。
		2. 在head标签内，定义link标签，引入外部的资源文件
		* 如：
    		* a.css文件：
				div{
				    color:green;
				}
			<link rel="stylesheet" href="css/a.css">
			<div>hello css</div>
			<div>hello css</div>

	* 注意：
		* 1,2,3种方式 css作用范围越来越大
		* 1方式不常用，后期常用2,3
		* 3种格式可以写为：
			<style>
		        @import "css/a.css";
		    </style>
```

### 9css语法格式

```
 css语法：
	* 格式：
		选择器 {
			属性名1:属性值1;
			属性名2:属性值2;
			...
		}
	* 选择器:筛选具有相似特征的元素
	* 注意：
		* 每一对属性需要使用；隔开，最后一对属性可以不加；
```

### 10css选择器

```
选择器：筛选具有相似特征的元素
* 分类：
1. 基础选择器
			1. id选择器：选择具体的id属性值的元素.建议在一个html页面中id值唯一
			        * 语法：#id属性值{}
			2. 元素选择器：选择具有相同标签名称的元素
			        * 语法： 标签名称{}
			        * 注意：id选择器优先级高于元素选择器
			3. 类选择器：选择具有相同的class属性值的元素。
			        * 语法：.class属性值{}
			        * 注意：类选择器选择器优先级高于元素选择器
	        优先级：类选择器>id选择器>元素选择器
2. 扩展选择器：
			1. 选择所有元素：
					* 语法： *{}
			2. 并集选择器：
					* 选择器1,选择器2{}
				
			3. 子选择器：筛选选择器1元素下的选择器2元素
					* 语法：  选择器1 选择器2{}
			4. 父选择器：筛选选择器2的父元素选择器1
					* 语法：  选择器1 > 选择器2{}

			5. 属性选择器：选择元素名称，属性名=属性值的元素
					* 语法：  元素名称[属性名="属性值"]{}

			6. 伪类选择器：选择一些元素具有的状态
					* 语法： 元素:状态{}
					* 如： <a>
						* 状态：
							* link：初始化的状态
							* visited：被访问过的状态
							* active：正在访问状态
							* hover：鼠标悬浮状态
```

### 11css属性

```css
       1. 字体、文本
			* font-size：字体大小
			* color：文本颜色
			* text-align：对其方式
			* line-height：行高 
		2. 背景
			* background：
		3. 边框
			* border：设置边框，符合属性
		4. 尺寸
			* width：宽度
			* height：高度
		5. 盒子模型：控制布局
			* margin：外边距
			* padding：内边距
				* 默认情况下内边距会影响整个盒子的大小
				* box-sizing: border-box;  设置盒子的属性，让width和height就是最终盒子的大小

			* float：浮动
				* left
				* right
```

### 12css案例注册页面

```

```

## 09_javaScript基础-未学完

### 1 JavaScript简介

```
	* 概念：	一门客户端脚本语言
		* 运行在客户端浏览器中的。每一个浏览器都有JavaScript的解析引擎
		* 脚本语言：不需要编译，直接就可以被浏览器解析执行了

	* 功能：
		* 可以来增强用户和html页面的交互过程，可以来控制html元素，让页面有一些动态的效果，增强用户的体验。
```

### 2 JavaScript语法与html结合方式

```
	1. 内部JS：
		* 定义<script>，标签体内容就是js代码
	2. 外部JS：
		* 定义<script>，通过src属性引入外部的js文件

	* 注意：
			1. <script>可以定义在html页面的任何地方。但是定义的位置会影响执行顺序。
			2. <script>可以定义多个。 
```

3 JavaScript语法注释&数据类型

```
注释
		1. 单行注释：//注释内容
		2. 多行注释：/*注释内容*/
数据类型：
	1. 原始数据类型(基本数据类型)：
		1. number：数字。  整数/小数/NaN(not a number 一个不是数字的数字类型)
		2. string：字符串。 字符串  "abc" "a" 'abc'
		3. boolean: true和false
		4. null：一个对象为空的占位符
		5. undefined：未定义。如果一个变量没有给初始化值，则会被默认赋值为undefined			
	2. 引用数据类型：对象
```

### 4 JavaScript语法变量

```
* 变量：一小块存储数据的内存空间
		* Java语言是强类型语言，而JavaScript是弱类型语言。
		* 强类型：在开辟变量存储空间时，定义了空间将来存储的数据的数据类型。只能存储固定类型的数据
		* 弱类型：在开辟变量存储空间时，不定义空间将来的存储数据类型，可以存放任意类型的数据。
		* 语法： 
				* var 变量名 = 初始化值;
```

```javascript
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>变量</title>
    <script>
        var a = 3;
        alert(a);
        a = "abc";
        alert(a);

        //定义number类型
        var num = 1;
        var num2 = 1.2;
        var num3 = NaN;

        //输出到页面上
        document.write(num+"<br>");
        document.write(num2+"<br>");
        document.write(num3+"<br>");

        var str = "abc";
        var str2 = 'def';
        document.write(str+"<br>");
        document.write(str2+"<br>");

        //定义boolean类型
        var flag = true;
        document.write(flag+"<br>");

        //定义null,undefined
        var obj = null;
        var obj2 = undefined;
        var obj3 ;
        document.write(obj+"<br>");
        document.write(obj2+"<br>");
        document.write(obj3+"<br>");
    </script>
</head>
<body>

</body>
</html>
```

### 5 JavaScript语法变量 typeof

```
* typeof运算符：获取变量的类型。
					* 注：null运算后得到的是object
```

```javascript
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>变量</title>
    <script>
        var a = 3;
        alert(a);
        a = "abc";
        alert(a);

        //定义number类型
        var num = 1;
        var num2 = 1.2;
        var num3 = NaN;

        //输出到页面上
        document.write(num+"---"+typeof(num)+"<br>");
        document.write(num2+"---"+typeof(num2)+"<br>");
        document.write(num3+"---"+typeof(num3)+"<br>");

        var str = "abc";
        var str2 = 'def';
        document.write(str+"---"+typeof(str)+"<br>");
        document.write(str2+"---"+typeof(str2)+"<br>");

        //定义boolean类型
        var flag = true;
        document.write(flag+"---"+typeof(flag)+"<br>");

        //定义null,undefined
        var obj = null;
        var obj2 = undefined;
        var obj3 ;
        document.write(obj+"---"+typeof(obj)+"<br>");
        document.write(obj2+"---"+typeof(obj2)+"<br>");
        document.write(obj3+"---"+typeof(obj3)+"<br>");
    </script>
</head>
<body>

</body>
</html>
```

### 6 JavaScript语法一元运算符

```javascript
1. 一元运算符：只有一个运算数的运算符
			++，-- ， +(正号)  
			* ++ --: 自增(自减)
			* ++(--) 在前，先自增(自减)，再运算
			* ++(--) 在后，先运算，再自增(自减)
			* +(-)：正负号
		    * 注意：在JS中，如果运算数不是运算符所要求的类型，那么js引擎会自动的将运算数进行类型转换
            * 其他类型转number：
            * string转number：按照字面值转换。如果字面值不是数字，则转为NaN（不是数字的数字）
            * boolean转number：true转为1，false转为0
```

### 7 JavaScript语法算数&赋值&比较运算符

```javascript
	2. 算数运算符
		+ - * / % ...

	3. 赋值运算符
		= += -+....

	4. 比较运算符
		> < >= <= == ===(全等于)
		* 比较方式
	     1. 类型相同：直接比较
	       * 字符串：按照字典顺序比较。按位逐一比较，直到得出大小为止。
         2. 类型不同：先进行类型转换，再比较
           * ===：全等于。在比较之前，先判断类型，如果类型不一样，则直接返回false
```

### 8 JavaScript语法逻辑运算符

```javascript
5. 逻辑运算符
			&& || !
		* 其他类型转boolean：
	          1. number：0或NaN为假，其他为真
	          2. string：除了空字符串("")，其他都是true
	          3. null&undefined:都是false
	          4. 对象：所有对象都为true
```

### 9 JavaScript语法三元运算符

```javascript
6. 三元运算符
		? : 表达式
		var a = 3;
	    var b = 4;

	    var c = a > b ? 1:0;
		* 语法：
		* 表达式? 值1:值2;
		* 判断表达式的值，如果是true则取值1，如果是false则取值2；
```

### 10JavaScript语法特殊语法

```javascript
JS特殊语法：
		1. 语句以;结尾，如果一行只有一条语句则 ;可以省略 (不建议)
		2. 变量的定义使用var关键字，也可以不使用
           * 用： 定义的变量是局部变量
	       * 不用：定义的变量是全局变量(不建议)
 注意：放在方法内，不用var，虽然是全局变量,但是如果不调用方法,也不能使用里面的变量.
```

### 11 JavaScript_语法流程控制语句

```javascript
流程控制语句：
		1. if...else...
		2. switch:
			* 在java中，switch语句可以接受的数据类型： byte int shor char,枚举(1.5) ,String(1.7)
			* switch(变量):
					case 值:
			* 在JS中,switch语句可以接受任意的原始数据类型
		3. while
		4. do...while
		5. for
```

```javascript
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>switch语句</title>
    <script>

        //var a = 1;
        //var a = "abc";
        var a = true;
        switch (a) {
            case 1:
                alert("number");
                break;
            case "abc":
                alert("string");
                break;
            case true:
                alert("true");
                break;
            case null:
                alert("null");
                break;
            case undefined:
                alert("undefined");
                break;
        }
    </script>
</head>
<body>

</body>
</html>
```

```javascript
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>while语句</title>
    <script>
        <!--1-100的和-->

        var sum = 0;
        var num = 1;

        while (num <= 100) {
            sum += num;
            num++;
        }
        alert(sum);
        
    </script>
</head>
<body>

</body>
</html>
```

```javascript
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>for语句</title>
    <script>
        <!--1-100求和-->
        var sum=0;
        for(var i = 1;i <= 100;i++){
            sum +=i;
        }
        alert(sum);
    </script>
</head>
<body>

</body>
</html>
```

### 12 JavaScript语法练习99乘法表

```javascript
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>99乘法表</title>
    <style>
        td{
            border:1px solid;
        }
    </style>
    <script>
        document.write("<table align='center'>");

        // 1.完成基本的for循环嵌套，展示乘法表
        for (var i = 1;i <= 9;i ++){
            document.write("<tr>");
            for (var j = 1;j <= i;j ++){
                document.write("<td>");

                //输出1 * 1 = 1
                document.write(j + "*" + i + "=" + (i*j) + "&nbsp"+ "&nbsp");

                document.write("</td>");
            }
            //输出换行
            // document.write("<br>");
            document.write("</tr>");
        }
        //2.完成表格的嵌套
        document.write("</table>");
    </script>
</head>
<body>

</body>
</html>
```

### 13 JavaScript对象 Function

```javascript
1. Function：函数(方法)对象
          1. 创建：
              1. var fun = new Function(形式参数列表,方法体);  //忘掉吧
              2. 
	              function 方法名称(形式参数列表){
                      方法体
                  }

              3. 
	             var 方法名 = function(形式参数列表){
                      方法体
                 }
          2. 方法：

          3. 属性：
               length:代表形参的个数
          4. 特点：
              1. 方法定义是，形参的类型不用写,返回值类型也不写。
              2. 方法是一个对象，如果定义名称相同的方法，会覆盖
              3. 在JS中，方法的调用只与方法的名称有关，和参数列表无关
              4. 在方法声明中有一个隐藏的内置对象（数组），arguments,封装所有的实际参数
          5. 调用：
                   方法名称(实际参数列表);
```

```javascript
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Function对象</title>
    <script>
        // 1.创建方式一
        var fun1 = new Function("a","b","alert(a);");//忘掉吧
        // 调用方法
        //fun1(3,4);

        // 2.创建方式二
        /*function fun2(a , b){
            alert(a + b);
        }*/

        //fun2(3,4);

        // 3.创建方式三
        /*var fun3 = function(a , b) {
            alert(a + b);
        }*/

        //alert(fun3.length);//2

        //fun3(3,4);

        /*function fun2(a , b){
            alert(a - b);
        }*/

        //fun2(3,4);//特点：会覆盖-1

        function fun2(a , b){
            alert(a);
        }
        //方法的调用
        //fun2(1,2);//1
        //fun2(1);//参数不匹配不报错
        //fun2(1,2,3);//没传的不弹出

        //求两个数的和
        /*function add(a , b){
            return a + b;
        }*/

        //求任意个数的和
        function add(){
            var sum = 0;
            for (var i = 0; i < arguments.length;i++ ) {
                sum += arguments[i];
            }
            return sum;
        }
        var sum = add(1,2,3);
        alert(sum);
    </script>
</head>
<body>

</body>
</html>
```

### 14 JavaScript对象 Array

```javascript

```

15 JavaScript对象date
16 JavaScript对象Math
17 JavaScript对象RegExp11
18 JavaScript对象 RegExp2
19JavaScript对象 RegExp33
20 JavaScript对象 Global

## 10_javaScript高级-未学

## 11_BootStrap

### 01 BootStrap概述

```
 概念： 一个前端开发的框架，Bootstrap，来自 Twitter，是目前很受欢迎的前端框架。Bootstrap 是基于 HTML、CSS、JavaScript 的，它简洁灵活，使得 Web 开发更加快捷。
		* 框架:一个半成品软件，开发人员可以在框架基础上，在进行开发，简化编码。
		* 好处：
			1. 定义了很多的css样式和js插件。我们开发人员直接可以使用这些样式和插件得到丰富的页面效果。
			2. 响应式布局。
				* 同一套页面可以兼容不同分辨率的设备。
```

### 02 Bootstrap快速入门

1. 下载Bootstrap
		2. 在项目中将这三个文件夹复制
		3. 创建html页面，引入必要的资源文件

```css
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ -->
    <title>Bootstrap Hello World</title>

    <!-- Bootstrap -->
    <link href="css/bootstrap.min.css" rel="stylesheet">

    <!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) -->
    <script src="js/jquery.min.js"></script>
    <!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 -->
    <script src="js/bootstrap.min.js"></script>

</head>
<body>
<h1>你好，世界！</h1>

</body>
</html>
```

### 03 Bootstrap栅格系统入门

```
响应式布局
	* 同一套页面可以兼容不同分辨率的设备。
	* 实现：依赖于栅格系统：将一行平均分成12个格子，可以指定元素占几个格子
	* 步骤：
		1. 定义容器。相当于之前的table、
			* 容器分类：
				1. container：两边留白
				2. container-fluid：每一种设备都是100%宽度
		2. 定义行。相当于之前的tr   样式：row
		3. 定义元素。指定该元素在不同的设备上，所占的格子数目。样式：col-设备代号-格子数目
			* 设备代号：
				1. xs：超小屏幕 手机 (<768px)：col-xs-12
				2. sm：小屏幕 平板 (≥768px)
				3. md：中等屏幕 桌面显示器 (≥992px)
				4. lg：大屏幕 大桌面显示器 (≥1200px)

		* 注意：
			1. 一行中如果格子数目超过12，则超出部分自动换行。
			2. 栅格类属性可以向上兼容。栅格类适用于与屏幕宽度大于或等于分界点大小的设备。
			3. 如果真实设备宽度小于了设置栅格类属性的设备代码的最小值，会一个元素沾满一整行。
```

### 04 Bootstrap栅格系统注意事项

```
 注意：
			1. 一行中如果格子数目超过12，则超出部分自动换行。
			2. 栅格类属性可以向上兼容。栅格类适用于与屏幕宽度大于或等于分界点大小的设备。
			3. 如果真实设备宽度小于了设置栅格类属性的设备代码的最小值，会一个元素沾满一整行。
```

### 05 Bootstrap_全局Css样式按钮&图片

```
 CSS样式和JS插件
	1. 全局CSS样式：
		* 按钮：class="btn btn-default"
		* 图片：
			*  class="img-responsive"：图片在任意尺寸都占100%
			*  图片形状
				*  <img src="..." alt="..." class="img-rounded">：方形
				*  <img src="..." alt="..." class="img-circle"> ： 圆形
				*  <img src="..." alt="..." class="img-thumbnail"> ：相框
```



### 06 Bootstrap_全局ss样式2表格&表单

```
* 表格
			* table
			* table-bordered
			* table-hover
		* 表单
			* 给表单项添加：class="form-control" 
```

### 07 Bootstrap_组件_导航条&分页条

```
组件：
		* 导航条
		* 分页条
```

### 08 Bootstrap插件轮播图

```
 插件：
		* 轮播图
```

### 09 案例**旅游网

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ -->
    <title>Bootstrap Hello World</title>

    <!-- Bootstrap -->
    <link href="css/bootstrap.min.css" rel="stylesheet">

    <!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) -->
    <script src="js/jquery-3.2.1.min.js"></script>
    <!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 -->
    <script src="js/bootstrap.min.js"></script>

    <style>
        .paddtop{
            padding-top: 10px;
        }
        .search-input{
            float: left;
            border: 2px solid #ffc900;
            width : 400px;
            height :35px;
            padding-left: 5px;
            margin-top: 15px;
        }
        .search-btn{
            float: left;
            border :1px solid #ffc900;
            width :90px;
            height :35px;
            background: #ffc900;
            text-align: center;
            line-height: 35px;
            margin-top: 15px;
        }

        .jx{
            border-bottom: 2px solid #ffc900;
            padding: 5px;
        }

        .company{
            height: 40px;
            background-color : #ffc900;
            text-align: center;
            line-height: 40px;
            font-size: 8px;
        }
    </style>
</head>
<body>
<!--1.页眉部分-->
<header class="container-fluid">
    <div class="row">
        <img src="img/top_banner.jpg" class="img-responsive">
    </div>
    <div class="row paddtop" >
        <div class="col-sm-3">
            <img src="img/logo.jpg" class="img-responsive">
        </div>
        <div class="col-sm-5">
            <input class="search-input" placeholder="请输入线路名称">
            <a class="search-btn" href="#">搜索</a>
        </div>
        <div class="col-sm-4">
            <img src="img/hotel_tel.png" class="img-responsive">
        </div>
    </div>
    <div class="row">
        <nav class="navbar navbar-default">
            <div class="container-fluid">
                <!-- Brand and toggle get grouped for better mobile display -->
                <div class="navbar-header">
                    <!--定义汉堡按钮-->
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="#">首页</a>
                </div>

                <!-- Collect the nav links, forms, and other content for toggling -->
                <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                    <ul class="nav navbar-nav">
                        <li class="active"><a href="#">Link <span class="sr-only">(current)</span></a></li>
                        <li><a href="#">Link</a></li>
                        <li><a href="#">Link</a></li>
                        <li><a href="#">Link</a></li>
                        <li><a href="#">Link</a></li>
                        <li><a href="#">Link</a></li>
                        <li><a href="#">Link</a></li>
                    </ul>
                </div><!-- /.navbar-collapse -->
            </div><!-- /.container-fluid -->
        </nav>
    </div>
    <!--轮播图-->
    <div class="row">
        <div id="carousel-example-generic" class="carousel slide" data-ride="carousel">
            <!-- Indicators -->
            <ol class="carousel-indicators">
                <li data-target="#carousel-example-generic" data-slide-to="0" class="active"></li>
                <li data-target="#carousel-example-generic" data-slide-to="1"></li>
                <li data-target="#carousel-example-generic" data-slide-to="2"></li>
            </ol>

            <!-- Wrapper for slides -->
            <div class="carousel-inner" role="listbox">
                <div class="item active">
                    <img src="img/banner_1.jpg" alt="...">
                </div>
                <div class="item">
                    <img src="img/banner_2.jpg" alt="...">
                </div>
                <div class="item">
                    <img src="img/banner_3.jpg" alt="...">
                </div>

            </div>

            <!-- Controls -->
            <a class="left carousel-control" href="#carousel-example-generic" role="button" data-slide="prev">
                <span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>
                <span class="sr-only">Previous</span>
            </a>
            <a class="right carousel-control" href="#carousel-example-generic" role="button" data-slide="next">
                <span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span>
                <span class="sr-only">Next</span>
            </a>
        </div>
    </div>
</header>
<!--2.主体部分-->
<div class="container">
    <!--导航栏-->
    <div class="row jx" >
        <img src="img/icon_5.jpg">
        <span>黑马精选</span>
    </div>

    <div class="row paddtop">
        <div class="col-lg-3">
            <div class="thumbnail">
                <img src="img/jiangxuan_3.jpg" alt="">
                <p>上海飞三亚五天四晚自由行（春节销售+亲子+蜜月+自由行+豪华酒店任选+接送机）</p>
                <font color="red">￥699</font>
            </div>
        </div>
        <div class="col-lg-3">
            <div class="thumbnail">
                <img src="img/jiangxuan_3.jpg" alt="">
                <p>上海飞三亚五天四晚自由行（春节销售+亲子+蜜月+自由行+豪华酒店任选+接送机）</p>
                <font color="red">￥699</font>
            </div>
        </div>
        <div class="col-lg-3">
            <div class="thumbnail">
                <img src="img/jiangxuan_3.jpg" alt="">
                <p>上海飞三亚五天四晚自由行（春节销售+亲子+蜜月+自由行+豪华酒店任选+接送机）</p>
                <font color="red">￥699</font>
            </div>
        </div>
        <div class="col-lg-3">
            <div class="thumbnail">
                <img src="img/jiangxuan_3.jpg" alt="">
                <p>上海飞三亚五天四晚自由行（春节销售+亲子+蜜月+自由行+豪华酒店任选+接送机）</p>
                <font color="red">￥699</font>
            </div>
        </div>
    </div>

    <div class="row jx" >
        <img src="img/icon_6.jpg">
        <span>国内游</span>
    </div>

    <div class="row paddtop">
        <div class="col-lg-4">
            <img src="img/guonei_1.jpg">
        </div>
        <div class="col-lg-8">
            <div class="row">
                <div class="col-lg-4">
                    <div class="thumbnail">
                        <img src="img/jiangxuan_3.jpg" alt="">
                        <p>上海飞三亚五天四晚自由行（春节销售+亲子+蜜月+自由行+豪华酒店任选+接送机）</p>
                        <font color="red">￥699</font>
                    </div>
                </div>
                <div class="col-lg-4">
                    <div class="thumbnail">
                        <img src="img/jiangxuan_3.jpg" alt="">
                        <p>上海飞三亚五天四晚自由行（春节销售+亲子+蜜月+自由行+豪华酒店任选+接送机）</p>
                        <font color="red">￥699</font>
                    </div>
                </div>
                <div class="col-lg-4">
                    <div class="thumbnail">
                        <img src="img/jiangxuan_3.jpg" alt="">
                        <p>上海飞三亚五天四晚自由行（春节销售+亲子+蜜月+自由行+豪华酒店任选+接送机）</p>
                        <font color="red">￥699</font>
                    </div>
                </div>
            </div>
            <div class="row">
                <div class="col-lg-4">
                    <div class="thumbnail">
                        <img src="img/jiangxuan_3.jpg" alt="">
                        <p>上海飞三亚五天四晚自由行（春节销售+亲子+蜜月+自由行+豪华酒店任选+接送机）</p>
                        <font color="red">￥699</font>
                    </div>
                </div>
                <div class="col-lg-4">
                    <div class="thumbnail">
                        <img src="img/jiangxuan_3.jpg" alt="">
                        <p>上海飞三亚五天四晚自由行（春节销售+亲子+蜜月+自由行+豪华酒店任选+接送机）</p>
                        <font color="red">￥699</font>
                    </div>
                </div>
                <div class="col-lg-4">
                    <div class="thumbnail">
                        <img src="img/jiangxuan_3.jpg" alt="">
                        <p>上海飞三亚五天四晚自由行（春节销售+亲子+蜜月+自由行+豪华酒店任选+接送机）</p>
                        <font color="red">￥699</font>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<!--3.页脚部分-->
<footer class="container-fluid">
    <div class="row">
        <img src="img/footer_service.png" class="img-responsive">
    </div>
    <div class="row company">
        <p>江苏传智播客教育科技股份有限公司 版权所有Copyright 2006-2018, All Rights Reserved 苏ICP备16007882</p>
    </div>
</footer>
</body>
</html>
```

## 12_Xml-

### 内容

	1. XML
		1. 概念
		2. 语法
		3. 解析


### XML：

	1. 概念：Extensible Markup Language 可扩展标记语言
		* 可扩展：标签都是自定义的。 <user>  <student>
	
		* 功能
			* 存储数据
				1. 配置文件
				2. 在网络中传输
		* xml与html的区别
			1. xml标签都是自定义的，html标签是预定义。
			2. xml的语法严格，html语法松散
			3. xml是存储数据的，html是展示数据
	
		* w3c:万维网联盟
	
	2. 语法：
		* 基本语法：
			1. xml文档的后缀名 .xml
			2. xml第一行必须定义为文档声明
			3. xml文档中有且仅有一个根标签
			4. 属性值必须使用引号(单双都可)引起来
			5. 标签必须正确关闭
			6. xml标签名称区分大小写
		* 快速入门：
			<?xml version='1.0' ?>
			<users>
				<user id='1'>
					<name>zhangsan</name>
					<age>23</age>
					<gender>male</gender>
					<br/>
				</user>
				
				<user id='2'>
					<name>lisi</name>
					<age>24</age>
					<gender>female</gender>
				</user>
			</users>
			
		* 组成部分：
			1. 文档声明
				1. 格式：<?xml 属性列表 ?>
				2. 属性列表：
					* version：版本号，必须的属性
					* encoding：编码方式。告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1
					* standalone：是否独立
						* 取值：
							* yes：不依赖其他文件
							* no：依赖其他文件
			2. 指令(了解)：结合css的
				* <?xml-stylesheet type="text/css" href="a.css" ?>
			3. 标签：标签名称自定义的
				* 规则：
					* 名称可以包含字母、数字以及其他的字符 
					* 名称不能以数字或者标点符号开始 
					* 名称不能以字母 xml（或者 XML、Xml 等等）开始 
					* 名称不能包含空格 
	
			4. 属性：
				id属性值唯一
			5. 文本：
				* CDATA区：在该区域中的数据会被原样展示
					* 格式：  <![CDATA[ 数据 ]]>


​	

		* 约束：规定xml文档的书写规则
			* 作为框架的使用者(程序员)：
				1. 能够在xml中引入约束文档
				2. 能够简单的读懂约束文档
			
			* 分类：
				1. DTD:一种简单的约束技术
				2. Schema:一种复杂的约束技术


			* DTD：
				* 引入dtd文档到xml文档中
					* 内部dtd：将约束规则定义在xml文档中
					* 外部dtd：将约束的规则定义在外部的dtd文件中
						* 本地：<!DOCTYPE 根标签名 SYSTEM "dtd文件的位置">
						* 网络：<!DOCTYPE 根标签名 PUBLIC "dtd文件名字" "dtd文件的位置URL">


			* Schema:
				* 引入：
					1.填写xml文档的根元素
					2.引入xsi前缀.  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
					3.引入xsd文件命名空间.  xsi:schemaLocation="http://www.itcast.cn/xml  student.xsd"
					4.为每一个xsd约束声明一个前缀,作为标识  xmlns="http://www.itcast.cn/xml" 
	
				<students   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
					xmlns="http://www.itcast.cn/xml"
					xsi:schemaLocation="http://www.itcast.cn/xml  student.xsd">


​	

	3. 解析：操作xml文档，将文档中的数据读取到内存中
		* 操作xml文档
			1. 解析(读取)：将文档中的数据读取到内存中
			2. 写入：将内存中的数据保存到xml文档中。持久化的存储
	
		* 解析xml的方式：
			1. DOM：将标记语言文档一次性加载进内存，在内存中形成一颗dom树
				* 优点：操作方便，可以对文档进行CRUD的所有操作
				* 缺点：占内存
			2. SAX：逐行读取，基于事件驱动的。
				* 优点：不占内存。
				* 缺点：只能读取，不能增删改


​		

		* xml常见的解析器：
			1. JAXP：sun公司提供的解析器，支持dom和sax两种思想
			2. DOM4J：一款非常优秀的解析器
			3. Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。
			4. PULL：Android操作系统内置的解析器，sax方式的。


		* Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。
			* 快速入门：
				* 步骤：
					1. 导入jar包
					2. 获取Document对象
					3. 获取对应的标签Element对象
					4. 获取数据
	
			* 代码：
				 //2.1获取student.xml的path
		        String path = JsoupDemo1.class.getClassLoader().getResource("student.xml").getPath();
		        //2.2解析xml文档，加载文档进内存，获取dom树--->Document
		        Document document = Jsoup.parse(new File(path), "utf-8");
		        //3.获取元素对象 Element
		        Elements elements = document.getElementsByTag("name");
		
		        System.out.println(elements.size());
		        //3.1获取第一个name的Element对象
		        Element element = elements.get(0);
		        //3.2获取数据
		        String name = element.text();
		        System.out.println(name);
	
		* 对象的使用：
			1. Jsoup：工具类，可以解析html或xml文档，返回Document
				* parse：解析html或xml文档，返回Document
					* parse​(File in, String charsetName)：解析xml或html文件的。
					* parse​(String html)：解析xml或html字符串
					* parse​(URL url, int timeoutMillis)：通过网络路径获取指定的html或xml的文档对象
			2. Document：文档对象。代表内存中的dom树
				* 获取Element对象
					* getElementById​(String id)：根据id属性值获取唯一的element对象
					* getElementsByTag​(String tagName)：根据标签名称获取元素对象集合
					* getElementsByAttribute​(String key)：根据属性名称获取元素对象集合
					* getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合
			3. Elements：元素Element对象的集合。可以当做 ArrayList<Element>来使用
			4. Element：元素对象
				1. 获取子元素对象
					* getElementById​(String id)：根据id属性值获取唯一的element对象
					* getElementsByTag​(String tagName)：根据标签名称获取元素对象集合
					* getElementsByAttribute​(String key)：根据属性名称获取元素对象集合
					* getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合
	
				2. 获取属性值
					* String attr(String key)：根据属性名称获取属性值
				3. 获取文本内容
					* String text():获取文本内容
					* String html():获取标签体的所有内容(包括字标签的字符串内容)
			5. Node：节点对象
				* 是Document和Element的父类


​			

		* 快捷查询方式：
			1. selector:选择器
				* 使用的方法：Elements	select​(String cssQuery)
					* 语法：参考Selector类中定义的语法
			2. XPath：XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言
				* 使用Jsoup的Xpath需要额外导入jar包。
				* 查询w3cshool参考手册，使用xpath的语法完成查询
				* 代码：
					//1.获取student.xml的path
			        String path = JsoupDemo6.class.getClassLoader().getResource("student.xml").getPath();
			        //2.获取Document对象
			        Document document = Jsoup.parse(new File(path), "utf-8");
			
			        //3.根据document对象，创建JXDocument对象
			        JXDocument jxDocument = new JXDocument(document);
			
			        //4.结合xpath语法查询
			        //4.1查询所有student标签
			        List<JXNode> jxNodes = jxDocument.selN("//student");
			        for (JXNode jxNode : jxNodes) {
			            System.out.println(jxNode);
			        }
			
			        System.out.println("--------------------");
			
			        //4.2查询所有student标签下的name标签
			        List<JXNode> jxNodes2 = jxDocument.selN("//student/name");
			        for (JXNode jxNode : jxNodes2) {
			            System.out.println(jxNode);
			        }
			
			        System.out.println("--------------------");
			
			        //4.3查询student标签下带有id属性的name标签
			        List<JXNode> jxNodes3 = jxDocument.selN("//student/name[@id]");
			        for (JXNode jxNode : jxNodes3) {
			            System.out.println(jxNode);
			        }
			        System.out.println("--------------------");
			        //4.4查询student标签下带有id属性的name标签 并且id属性值为itcast
			
			        List<JXNode> jxNodes4 = jxDocument.selN("//student/name[@id='itcast']");
			        for (JXNode jxNode : jxNodes4) {
			            System.out.println(jxNode);
			        }

## 13_Tomcat&Servlet-要学透

### 02web相关概念回顾

```
1. 软件架构
		1. C/S：客户端/服务器端
		2. B/S：浏览器/服务器端

	2. 资源分类
		1. 静态资源：所有用户访问后，得到的结果都是一样的，称为静态资源.静态资源可以直接被浏览器解析
			* 如： html,css,JavaScript
		2. 动态资源:每个用户访问相同资源后，得到的结果可能不一样。称为动态资源。动态资源被访问后，需要先转换为静态资源，在返回给浏览器
			* 如：servlet/jsp,php,asp....
			

	3. 网络通信三要素
		1. IP：电子设备(计算机)在网络中的唯一标识。
		2. 端口：应用程序在计算机中的唯一标识。 0~65536
		3. 传输协议：规定了数据传输的规则
			1. 基础协议：
				1. tcp:安全协议，三次握手。 速度稍慢
				2. udp：不安全协议。 速度快
```

### 03web服务器软件概述

```
web服务器软件：
	* 服务器：安装了服务器软件的计算机
	* 服务器软件：接收用户的请求，处理请求，做出响应
	* web服务器软件：接收用户的请求，处理请求，做出响应。
		* 在web服务器软件中，可以部署web项目，让用户通过浏览器来访问这些项目
		* web容器


	* 常见的java相关的web服务器软件：
		* webLogic：oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。
		* webSphere：IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。
		* JBOSS：JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。
		* Tomcat：Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servlet/jsp。开源的，免费的。


	* JavaEE：Java语言在企业级开发中使用的技术规范的总和，一共规定了13项大的规范
```

### 04 tomcat安装&卸载&启动

```
Tomcat：web服务器软件
		1. 下载：http://tomcat.apache.org/
		2. 安装：解压压缩包即可。
			* 注意：安装目录建议不要有中文和空格
		3. 卸载：删除目录就行了
		4. 启动：
			* bin/startup.bat ,双击运行该文件即可
			* 访问：浏览器输入：http://localhost:8080 回车访问自己
							  http://别人的ip:8080 访问别人
目录结构：
bin可执行文件
conf配置文件
lib依赖jar包
logs日志文件
temp临时文件
webapps存放web项目
work存放一些运行时的数据
```

### 05 tomcat启动问题分析

```
可能遇到的问题：
				1. 黑窗口一闪而过：
					* 原因： 没有正确配置JAVA_HOME环境变量
					* 解决方案：正确配置JAVA_HOME环境变量

				2. 启动报错：
					1. 暴力：找到占用的端口号，并且找到对应的进程，杀死该进程
						* netstat -ano
					2. 温柔：修改自身的端口号
						* conf/server.xml
						* <Connector port="8888" protocol="HTTP/1.1"
			               connectionTimeout="20000"
			               redirectPort="8445" />
						* 一般会将tomcat的默认端口号修改为80。80端口号是http协议的默认端口号。 
							* 好处：在访问时，就不用输入端口号
```

### 06 tomcat关闭

```
关闭：
			1. 正常关闭：
				* bin/shutdown.bat
				* ctrl+c
			2. 强制关闭：
				* 点击启动窗口的×
```

### 07 tomcat部署项目的方式

```
部署项目的方式： 
				1. 直接将项目放到webapps目录下即可。
					* /hello：项目的访问路径-->虚拟目录
					* 简化部署：将项目打成一个war包，再将war包放置到webapps目录下。
						* war包会自动解压缩
						缺点:需要拷贝到webapps目录下

				2. 配置conf/server.xml文件
					在<Host>标签体中配置
					<Context docBase="D:\hello" path="/hehe" />
					* docBase:项目存放的路径
					* path：虚拟目录
					缺点:可能影响 整个tomcat项目

				3. 在conf\Catalina\localhost创建任意名称的xml文件。在文件中编写
					<Context docBase="D:\hello" />
					* 虚拟目录：xml文件的名称
					一种热部署方式
```

### 08 tomcat动态java项目的目录结构

```
静态项目和动态项目：
				* 目录结构
					* java动态项目的目录结构：
						-- 项目的根目录
							-- WEB-INF目录：
								-- web.xml：web项目的核心配置文件
								-- classes目录：放置字节码文件的目录
								-- lib目录：放置依赖的jar包
```

### 09 tomcat与idea集成&创建web项目

```
遇到的坑：
Tomcat部署时war和war exploded有区别

是选择war还是war exploded 这里首先看一下他们两个的区别：

war模式：将WEB工程以包的形式上传到服务器 ；
war exploded模式：将WEB工程以当前文件夹的位置关系上传到服务器；
1
2
（1）war模式这种可以称之为是发布模式，看名字也知道，这是先打成war包，再发布；

（2）war exploded模式是直接把文件夹、jsp页面 、classes等等移到Tomcat 部署文件夹里面，进行加载部署。因此这种方式支持热部署，一般在开发的时候也是用这种方式。

（3）在平时开发的时候，使用热部署的话，应该对Tomcat进行相应的设置，这样的话修改的jsp界面什么的东西才可以及时的显示出来。
```

### 10 Servlet概述

```
Servlet：  server applet
	* 概念：运行在服务器端的小程序
		* Servlet就是一个接口，定义了Java类被浏览器访问到(tomcat识别)的规则。
		* 将来我们自定义一个类，实现Servlet接口，复写方法。
```

### 11 Servlet快速入门

```
快速入门：
		1. 创建JavaEE项目
		2. 定义一个类，实现Servlet接口
			* public class ServletDemo1 implements Servlet
		3. 实现接口中的抽象方法
		4. 配置Servlet
			 在web.xml中配置：
		    <!--配置Servlet -->
		    <servlet>
		        <servlet-name>demo1</servlet-name>
		        <servlet-class>cn.itcast.web.servlet.ServletDemo1</servlet-class>
		    </servlet>
		
		    <servlet-mapping>
		        <servlet-name>demo1</servlet-name>
		        <url-pattern>/demo1</url-pattern>
		    </servlet-mapping>
```

### 12 Servlet执行原理

![](C:/Users/Murphy/Pictures/Servlet.bmp)

```
执行原理：
		1. 当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径
		2. 查找web.xml文件，是否有对应的<url-pattern>标签体内容。
		3. 如果有，则在找到对应的<servlet-class>全类名
		4. tomcat会将字节码文件加载进内存，并且创建其对象
		5. 调用其方法
```

### 13 Servlet生命周期方法

```java
package cn.itcast.web.servlet;

import javax.servlet.*;
import java.io.IOException;

public class ServletDemo2 implements Servlet{
    /**
     * 初始化方法
     * 在Servlet被创建时，执行。只会执行一次
     * @param servletConfig
     * @throws ServletException
     */
    @Override
    public void init(ServletConfig servletConfig) throws ServletException {
        System.out.println("init...");
    }

    /**
     * 获取ServletConfig对象
     * ServletConfig：Servlet的配置对象
     * @return
     */
    @Override
    public ServletConfig getServletConfig() {
        return null;
    }

    /**
     * 提供服务的方法
     * 每一次Servlet被访问时，执行。执行多次
     * @param servletRequest
     * @param servletResponse
     * @throws ServletException
     * @throws IOException
     */
    @Override
    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
        System.out.println("service...");
    }

    /**
     * 获取Servlet的一些信息，版本，作者等等
     * @return
     */
    @Override
    public String getServletInfo() {
        return null;
    }

    /**
     * 销毁方法
     * 在服务器正常关闭时，执行。执行一次。
     */
    @Override
    public void destroy() {
        System.out.println("destroy ...");
    }
}

```

```
 Servlet中的生命周期方法：
	1. 被创建：执行init方法，只执行一次
		* Servlet什么时候被创建？
				* 默认情况下，第一次被访问时，Servlet被创建
				* 可以配置执行Servlet的创建时机。
					* 在<servlet>标签下配置
						1. 第一次被访问时，创建
	                		* <load-on-startup>的值为负数
			            2. 在服务器启动时，创建
			                * <load-on-startup>的值为0或正整数


		* Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的
		* 多个用户同时访问时，可能存在线程安全问题。
		* 解决：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要对修改值

	2. 提供服务：执行service方法，执行多次
		* 每次访问Servlet时，Service方法都会被调用一次。
	3. 被销毁：执行destroy方法，只执行一次
		* Servlet被销毁时执行。服务器关闭时，Servlet被销毁
		* 只有服务器正常关闭时，才会执行destroy方法。
		* destroy方法在Servlet被销毁之前执行，一般用于释放资源
```

### 14 Servlet生命周期详解

```
    <servlet>
        <servlet-name>demo1</servlet-name>
        <servlet-class>cn.itcast.web.servlet.ServletDemo1</servlet-class>
        <!--指定Servlet的创建时机
            1.第一次被访问时，创建
                <load-on-startup>的值为负数
            2.在服务器启动时，创建
                <load-on-startup>的值为0或正整数
        -->

        <load-on-startup>5</load-on-startup>
    </servlet>
```

### 15 Servlet3.0注解配置

```
Servlet3.0：
		* 好处：
			* 支持注解配置。可以不需要web.xml了。

		* 步骤：
			1. 创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xml
			2. 定义一个类，实现Servlet接口
			3. 复写方法
			4. 在类上使用@WebServlet注解，进行配置
				* @WebServlet("资源路径")


				@Target({ElementType.TYPE})
				@Retention(RetentionPolicy.RUNTIME)
				@Documented
				public @interface WebServlet {
				    String name() default "";//相当于<Servlet-name>
				
				    String[] value() default {};//代表urlPatterns()属性配置
				
				    String[] urlPatterns() default {};//相当于<url-pattern>
				
				    int loadOnStartup() default -1;//相当于<load-on-startup>
				
				    WebInitParam[] initParams() default {};
				
				    boolean asyncSupported() default false;
				
				    String smallIcon() default "";
				
				    String largeIcon() default "";
				
				    String description() default "";
				
				    String displayName() default "";
				}

```

### 16DEA与 tomcat相关配置

```
1. IDEA会为每一个tomcat部署的项目单独建立一份配置文件
		* 查看控制台的log：Using CATALINA_BASE:   "C:\Users\fqy\.IntelliJIdea2018.1\system\tomcat\_itcast"

	2. 工作空间项目    和     tomcat部署的web项目
		* tomcat真正访问的是“tomcat部署的web项目”，"tomcat部署的web项目"对应着"工作空间项目" 的web目录下的所有资源
		* WEB-INF目录下的资源不能被浏览器直接访问。
	3. 断点调试：使用"小虫子"启动 dubug 启动
```

## 14_Servlet&HTTP&Request

### 01 Servlet体系结构

```
1. 概念
	2. 步骤
	3. 执行原理
	4. 生命周期
	5. Servlet3.0 注解配置
	6. Servlet的体系结构	
		Servlet -- 接口
			|
		GenericServlet -- 抽象类
			|
		HttpServlet  -- 抽象类

		* GenericServlet：将Servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象
			* 将来定义Servlet类时，可以继承GenericServlet，实现service()方法即可

		* HttpServlet：对http协议的一种封装，简化操作
			1. 定义类继承HttpServlet
			2. 复写doGet/doPost方法
```

```java
package cn.itcast.web.servlet;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebServlet("/demo3")
public class ServletDemo3 extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("doGet....");
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("doPost...");
    }
}
```

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    <form action="/demo3" method="post">
        <input name="username">
        <input type="submit" value="提交">
    </form>
</body>
</html>
```

![HttpServlet](C:/Users/Murphy/Desktop/Picture/HttpServlet.bmp)

### 02 Servlet urlpartten配置

```
Servlet相关配置
		1. urlpartten:Servlet访问路径
			1. 一个Servlet可以定义多个访问路径 ： @WebServlet({"/d4","/dd4","/ddd4"})
			2. 路径定义规则：
				1. /xxx：路径匹配
				2. /xxx/xxx:多层路径，目录结构
				3. *.do：扩展名匹配
				带.do才能访问   http://localhost/demo3.do 输出demo4
				不带只能输出类demo3的内容
```

### 03HTTP概述

```
概念：Hyper Text Transfer Protocol 超文本传输协议
		* 传输协议：定义了，客户端和服务器端通信时，发送数据的格式
	 	* 特点：
			1. 基于TCP/IP的高级协议
			2. 默认端口号:80
			3. 基于请求/响应模型的:一次请求对应一次响应
			4. 无状态的：每次请求之间相互独立，不能交互数据

		* 历史版本：
			* 1.0：每一次请求响应都会建立新的连接
			* 1.1：复用连接 
```

![HTTP协议](C:/Users/Murphy/Desktop/Picture/HTTP协议.bmp)

### 04 HTTP 请求消息请求行

```http
1. 请求行
			请求方式 请求url 请求协议/版本
			GET /login.html	HTTP/1.1

			* 请求方式：
				* HTTP协议有7中请求方式，常用的有2种
					* GET：
						1. 请求参数在请求行中，在url后。
						2. 请求的url长度有限制的
						3. 不太安全
					* POST：
						1. 请求参数在请求体中
						2. 请求的url长度没有限制的
						3. 相对安全
```

### 05 HTTP. 请求消息请求头&请求体

```http
2. 请求头：客户端浏览器告诉服务器一些信息
			请求头名称: 请求头值
			* 常见的请求头：
				1. User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本信息
					* 可以在服务器端获取该头的信息，解决浏览器的兼容性问题

				2. Referer：http://localhost/login.html
					* 告诉服务器，我(当前请求)从哪里来？
						* 作用：
							1. 防盗链：
							2. 统计工作：
3. 请求空行
			空行，就是用于分割POST请求的请求头，和请求体的。
4. 请求体(正文)：
			* 封装POST请求消息的请求参数的

		* 字符串格式：
		 	POST /login.html	HTTP/1.1
	  	    主机
            Host: localhost
    		浏览器版本信息
    		User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0
 			浏览器可（解析）接收响应的信息格式
 			Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
 			浏览器可支持的语言环境
			Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2
			浏览器可接收的压缩格式
			Accept-Encoding: gzip, deflate
			告诉服务器，我(当前请求)从哪里来？
			Referer: http://localhost/login.html
			连接
			Connection: keep-alive
			升级信息
			Upgrade-Insecure-Requests: 1
			
			username=zhangsan	


	* 响应消息数据格式
```

![Referer请求头](C:/Users/Murphy/Desktop/Picture/Referer请求头.bmp)

### 06 Request原理

```
Request：
	1. request对象和response对象的原理
		1. request和response对象是由服务器创建的。我们来使用它们
		2. request对象是来获取请求消息，response对象是来设置响应消息
```

![image-20210406205444473](C:/Users/Murphy/Pictures/image-20210406205444473.png)

### 07 Request继承体系

```
2. request对象继承体系结构：	
		ServletRequest		--	接口
			|	继承
		HttpServletRequest	-- 接口
			|	实现
		org.apache.catalina.connector.RequestFacade 类(tomcat)  
```

### 08 Request获取请求行数据方法介绍

```java
 @Inherited：允许子类继承父类的注解，仅限于类注解有用，对于方法和属性无效。
```

```java
3. request功能：
		1. 获取请求消息数据
			1. 获取请求行数据（带*，重点掌握，常用）
				* GET /day14/demo1?name=zhangsan HTTP/1.1
				* 方法：
			1. 获取请求方式 ：GET
						* String getMethod()  
			2. (*)获取虚拟目录：/day14
						* String getContextPath()
			3. 获取Servlet路径: /demo1
						* String getServletPath()
			4. 获取get方式请求参数：name=zhangsan
						* String getQueryString()
			5. (*)获取请求URI：/day14/demo1
						* String getRequestURI():		/day14/demo1
						* StringBuffer getRequestURL()  :http://localhost/day14/demo1

		* URL:统一资源定位符 ： http://localhost/day14/demo1	中华人民共和国
		* URI：统一资源标识符 : /day14/demo1					共和国
					
			6. 获取协议及版本：HTTP/1.1
						* String getProtocol()

			7. 获取客户机的IP地址：
						* String getRemoteAddr()
```

### 09 Request获取请求行数据代码演示

```java
package cn.itcast.web.request;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 * 演示Request对象获取请求行数据
 */

@WebServlet("/RequestDemo1")
public class RequestDemo1 extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        /*
            1. 获取请求方式 ：GET
						* String getMethod()
			2. (*)获取虚拟目录：/day14
						* String getContextPath()
			3. 获取Servlet路径: /demo1
						* String getServletPath()
			4. 获取get方式请求参数：name=zhangsan
						* String getQueryString()
			5. (*)获取请求URI：/day14/demo1
						* String getRequestURI():		/day14/demo1
						* StringBuffer getRequestURL()  :http://localhost/day14/demo1
			6. 获取协议及版本：HTTP/1.1
						* String getProtocol()

			7. 获取客户机的IP地址：
						* String getRemoteAddr()
         */
        //1. 获取请求方式 ：GET
        String method = request.getMethod();
        System.out.println(method);
        //2. 获取虚拟目录：/day14
        String contextPath = request.getContextPath();
        System.out.println(contextPath);
        //3. 获取Servlet路径: /demo1
        String servletPath = request.getServletPath();
        System.out.println(servletPath);
        //4. 获取get方式请求参数：name=zhangsan
        String queryString = request.getQueryString();
        System.out.println(queryString);
        //5. 获取请求URI：/day14/demo1
        String requestURI = request.getRequestURI();
        System.out.println(requestURI);
        StringBuffer requestURL = request.getRequestURL();
        System.out.println(requestURL);
        //6. 获取协议及版本：HTTP/1.1
        String protocol = request.getProtocol();
        System.out.println(protocol);
        //7. 获取客户机的IP地址：
        String remoteAddr = request.getRemoteAddr();
        System.out.println(remoteAddr);
    }
}
```

### 10 Request获取请求头数据

```java
2. 获取请求头数据
	* 方法：
		* (*)String getHeader(String name):通过请求头的名称获取请求头的值
		* Enumeration<String> getHeaderNames():获取所有的请求头名称
```

```java
package cn.itcast.web.request;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.Enumeration;

@WebServlet("/RequestDemo2")
public class RequestDemo2 extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //演示获取请求头数据

        //1.获取所有请求头名称
        Enumeration<String> headerNames = request.getHeaderNames();
        //2.遍历
        while (headerNames.hasMoreElements()) {
            String name = headerNames.nextElement();
            //根据名称获取请求头的值
            String value = request.getHeader(name);
            System.out.println(name+"---"+value);
        }
    }
}

```

演示请求头数据:user-agent

```java
package cn.itcast.web.request;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebServlet("/RequestDemo3")
public class RequestDemo3 extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //演示请求头数据:user-agent
        String header = request.getHeader("user-agent");
        System.out.println(header);

        String agent = request.getHeader("user-agent");
        //判断agent的浏览器版本
        if (agent.contains("Chrome")) {
            //谷歌
            System.out.println("谷歌来了...");
        } else if (agent.contains("Firefox")) {
            //火狐
            System.out.println("火狐来了...");
        }
    }
}
```

演示请求头数据:referer

```java
package cn.itcast.web.request;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebServlet("/RequestDemo4")
public class RequestDemo4 extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //演示请求头数据:referer
        String referer = request.getHeader("referer");
        System.out.println(referer);//null
        //http://localhost/day14/login.html
        //防盗链操作
        if (referer != null) {
            if (referer.contains("/day14")){
                //正常访问
                //System.out.println("播放电影");
                response.setContentType("text/html;charset=utf-8");
                response.getWriter().write("播放电影...");
            }else {
                //盗链
                response.setContentType("text/html;charset=utf-8");
                System.out.println("想看电影吗，来优酷吧");
            }
        }
    }
}
```

### 11 Request获取请求体数据

```
3. 获取请求体数据:
				* 请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数
				* 步骤：
					1. 获取流对象
						*  BufferedReader getReader()：获取字符输入流，只能操作字符数据
						*  ServletInputStream getInputStream()：获取字节输入流，可以操作所有类型数据
							* 在文件上传知识点后讲解

					2. 再从流对象中拿数据
```

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>注册页面</title>
</head>
<body>
    <form action="/day14/RequestDemo5" method="post">
        <input type="text" placeholder="请输入用户名" name="username"><br>
        <input type="text" placeholder="请输入密码" name="password"><br>
        <input type="submit" value="注册">
    </form>
</body>
</html>
```

```java
package cn.itcast.web.request;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.BufferedReader;
import java.io.IOException;

@WebServlet("/RequestDemo5")
public class RequestDemo5 extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //获取请求消息体--请求参数

        //1.获取字符流
        BufferedReader br = request.getReader();
        //2.读取数据
        String line = null;
        while ((line = br.readLine()) != null){
            System.out.println(line);//username=zhangsan&password=123456
        }
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

    }
}

```

### 12 Request获取请求参数通用方式介绍

```
2. 其他功能：
	一. 获取请求参数通用方式：不论get还是post请求方式都可以使用下列方法来获取请求参数
		1. String getParameter(String name):根据参数名称获取参数值    username=zs&password=123
		2. String[] getParameterValues(String name):根据参数名称获取参数值的数组  hobby=study&hobby=game
		3. Enumeration<String> getParameterNames():获取所有请求的参数名称
		4. Map<String,String[]> getParameterMap():获取所有参数的map集合
		
第1个以及第4个方法常用
```

### 13 Request获取请求参数通用方式演示

```java
package cn.itcast.web.request;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.Enumeration;
import java.util.Map;
import java.util.Set;

@WebServlet("/RequestDemo6")
public class RequestDemo6 extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //post 获取请求参数

        //根据参数名称获取参数值
        String username = request.getParameter("username");
        /*System.out.println("post");//修改regist2 method="post"  post
        System.out.println(username);//zhangsan*/

        //根据参数名称获取参数值的数组

        String[] hobbies = request.getParameterValues("hobby");
        for (String hobby : hobbies) {
            System.out.println(hobby);//game  study
        }

        //获取所有请求的参数名称

        Enumeration<String> parameterNames = request.getParameterNames();
        while (parameterNames.hasMoreElements()){
            String name = parameterNames.nextElement();
            System.out.println(name);
            String value = request.getParameter(name);
            System.out.println(value);
            System.out.println("------------------");
        }

        //获取所有参数的map集合
        Map<String, String[]> parameterMap = request.getParameterMap();
        //遍历
        Set<String> keySet = parameterMap.keySet();

        for (String name : keySet) {
            //根据键获取值
            String[] values = parameterMap.get(name);
            System.out.println(name);
            for (String value : values) {
                System.out.println(value);
            }

            System.out.println("----------");
        }
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //get 获取请求参数

        //根据参数名称获取参数值
        /*String username = request.getParameter("username");
        System.out.println("get");//修改regist2 method="get"  get
        System.out.println(username);//zhangsan*/

        this.doPost(request, response);
    }
}

```

### 14 Request获取请求参数中文乱码问题处理

```
* 中文乱码问题：
			* get方式：tomcat 8 已经将get方式乱码问题解决了
			* post方式：会乱码
				* 解决：在获取参数前，设置request的编码request.setCharacterEncoding("utf-8");
```

```java
package cn.itcast.web.request;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebServlet("/RequestDemo7")
public class RequestDemo7 extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //设置流的编码
        request.setCharacterEncoding("utf-8");
        //获取请求参数username
        String username = request.getParameter("username");
        System.out.println(username );

    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

        this.doPost(request, response);
    }
}

```

15 Request请求转发

![Request请求转发&域对象](C:/Users/Murphy/Pictures/Request请求转发&域对象.bmp)

```
二. 请求转发：一种在服务器内部的资源跳转方式
			1. 步骤：
		       1. 通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path)
				2. 使用RequestDispatcher对象来进行转发：forward(ServletRequest request, ServletResponse response) 

	        2. 特点：
			   1. 浏览器地址栏路径不发生变化
			   2. 只能转发到当前服务器内部资源中。
			   3. 转发是一次请求
```

### 16 Request共享数据（域对象）

```
三. 共享数据：
				* 域对象：一个有作用范围的对象，可以在范围内共享数据
				* request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据
				* 方法：
					1. void setAttribute(String name,Object obj):存储数据
					2. Object getAttitude(String name):通过键获取值
					3. void removeAttribute(String name):通过键移除键值对
```

```java
package cn.itcast.web.request;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebServlet("/RequestDemo8")
public class RequestDemo8 extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        System.out.println("demo8888被访问了");

        //转发到demo9资源
        /*RequestDispatcher requestDispatcher = request.getRequestDispatcher("/RequestDemo9");
        requestDispatcher.forward(request, response);*/

        //存储数据到request域中
        request.setAttribute("msg","Hello");


        request.getRequestDispatcher("/RequestDemo9").forward(request, response);
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

        this.doPost(request, response);
    }
}

```

```java
package cn.itcast.web.request;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebServlet("/RequestDemo9")
public class RequestDemo9 extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //获取数据
        Object msg = request.getAttribute("msg");
        System.out.println(msg);

        System.out.println("demo9999被访问了");
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

        this.doPost(request, response);
    }
}
```



### 17 Request获取 ServletContext

```
四. 获取ServletContext：
				* ServletContext getServletContext()
```

### 18登录案例需求

```
 案例：用户登录
	* 用户登录案例需求：
		1.编写login.html登录页面
			username & password 两个输入框
		2.使用Druid数据库连接池技术,操作mysql，day14数据库中user表
		3.使用JdbcTemplate技术封装JDBC
		4.登录成功跳转到SuccessServlet展示：登录成功！用户名,欢迎您
		5.登录失败跳转到FailServlet展示：登录失败，用户名或密码错误
```

### 19登录案例分析

### ![登录案例分析](C:/Users/Murphy/Pictures/登录案例分析.bmp)20登录案例代码实现

```java
 开发步骤
		1. 创建项目，导入html页面，配置文件，jar包
		2. 创建数据库环境
			CREATE DATABASE day14;
			USE day14;
			CREATE TABLE USER(
			
				id INT PRIMARY KEY AUTO_INCREMENT,
				username VARCHAR(32) UNIQUE NOT NULL,
				PASSWORD VARCHAR(32) NOT NULL
			);

		3. 创建包cn.itcast.domain,创建类User
			package cn.itcast.domain;
			/**
			 * 用户的实体类
			 */
			public class User {
			
			    private int id;
			    private String username;
			    private String password;
			
			
			    public int getId() {
			        return id;
			    }
			
			    public void setId(int id) {
			        this.id = id;
			    }
			
			    public String getUsername() {
			        return username;
			    }
			
			    public void setUsername(String username) {
			        this.username = username;
			    }
			
			    public String getPassword() {
			        return password;
			    }
			
			    public void setPassword(String password) {
			        this.password = password;
			    }
			
			    @Override
			    public String toString() {
			        return "User{" +
			                "id=" + id +
			                ", username='" + username + '\'' +
			                ", password='" + password + '\'' +
			                '}';
			    }
			}
		4. 创建包cn.itcast.util,编写工具类JDBCUtils
			package cn.itcast.util;

			import com.alibaba.druid.pool.DruidDataSourceFactory;
			
			import javax.sql.DataSource;
			import javax.xml.crypto.Data;
			import java.io.IOException;
			import java.io.InputStream;
			import java.sql.Connection;
			import java.sql.SQLException;
			import java.util.Properties;
			
			/**
			 * JDBC工具类 使用Durid连接池
			 */
			public class JDBCUtils {
			
			    private static DataSource ds ;
			
			    static {
			
			        try {
			            //1.加载配置文件
			            Properties pro = new Properties();
			            //使用ClassLoader加载配置文件，获取字节输入流
			            InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream("druid.properties");
			            pro.load(is);
			
			            //2.初始化连接池对象
			            ds = DruidDataSourceFactory.createDataSource(pro);
			
			        } catch (IOException e) {
			            e.printStackTrace();
			        } catch (Exception e) {
			            e.printStackTrace();
			        }
			    }
			
			    /**
			     * 获取连接池对象
			     */
			    public static DataSource getDataSource(){
			        return ds;
			    }
			
			
			    /**
			     * 获取连接Connection对象
			     */
			    public static Connection getConnection() throws SQLException {
			        return  ds.getConnection();
			    }
			}
		5. 创建包cn.itcast.dao,创建类UserDao,提供login方法
			
			package cn.itcast.dao;

			import cn.itcast.domain.User;
			import cn.itcast.util.JDBCUtils;
			import org.springframework.dao.DataAccessException;
			import org.springframework.jdbc.core.BeanPropertyRowMapper;
			import org.springframework.jdbc.core.JdbcTemplate;
			
			/**
			 * 操作数据库中User表的类
			 */
			public class UserDao {
			
			    //声明JDBCTemplate对象共用
			    private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource());
			
			    /**
			     * 登录方法
			     * @param loginUser 只有用户名和密码
			     * @return user包含用户全部数据,没有查询到，返回null
			     */
			    public User login(User loginUser){
			        try {
			            //1.编写sql
			            String sql = "select * from user where username = ? and password = ?";
			            //2.调用query方法
			            User user = template.queryForObject(sql,
			                    new BeanPropertyRowMapper<User>(User.class),
			                    loginUser.getUsername(), loginUser.getPassword());
			
			
			            return user;
			        } catch (DataAccessException e) {
			            e.printStackTrace();//记录日志
			            return null;
			        }
			    }
			}
		
		6. 编写cn.itcast.web.servlet.LoginServlet类
			package cn.itcast.web.servlet;

			import cn.itcast.dao.UserDao;
			import cn.itcast.domain.User;
			
			import javax.servlet.ServletException;
			import javax.servlet.annotation.WebServlet;
			import javax.servlet.http.HttpServlet;
			import javax.servlet.http.HttpServletRequest;
			import javax.servlet.http.HttpServletResponse;
			import java.io.IOException;
			
			
			@WebServlet("/loginServlet")
			public class LoginServlet extends HttpServlet {
			
			
			    @Override
			    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
			        //1.设置编码
			        req.setCharacterEncoding("utf-8");
			        //2.获取请求参数
			        String username = req.getParameter("username");
			        String password = req.getParameter("password");
			        //3.封装user对象
			        User loginUser = new User();
			        loginUser.setUsername(username);
			        loginUser.setPassword(password);
			
			        //4.调用UserDao的login方法
			        UserDao dao = new UserDao();
			        User user = dao.login(loginUser);
			
			        //5.判断user
			        if(user == null){
			            //登录失败
			            req.getRequestDispatcher("/failServlet").forward(req,resp);
			        }else{
			            //登录成功
			            //存储数据
			            req.setAttribute("user",user);
			            //转发
			            req.getRequestDispatcher("/successServlet").forward(req,resp);
			        }
			
			    }
			
			    @Override
			    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
			        this.doGet(req,resp);
			    }
			}

		7. 编写FailServlet和SuccessServlet类
			@WebServlet("/successServlet")
			public class SuccessServlet extends HttpServlet {
			    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
			        //获取request域中共享的user对象
			        User user = (User) request.getAttribute("user");
			
			        if(user != null){
			            //给页面写一句话
			
			            //设置编码
			            response.setContentType("text/html;charset=utf-8");
			            //输出
			            response.getWriter().write("登录成功！"+user.getUsername()+",欢迎您");
			        }
			
			
			    }		


			@WebServlet("/failServlet")
			public class FailServlet extends HttpServlet {
			    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
			        //给页面写一句话
			
			        //设置编码
			        response.setContentType("text/html;charset=utf-8");
			        //输出
			        response.getWriter().write("登录失败，用户名或密码错误");
			
			    }
			
			    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
			        this.doPost(request,response);
			    }
			}



		8. login.html中form表单的action路径的写法
			* 虚拟目录+Servlet的资源路径
```

### 21登录 BeanUtils案例基本使用

```java
package cn.itcast.web.servlet;

import cn.itcast.dao.UserDao;
import cn.itcast.domain.User;
import org.apache.commons.beanutils.BeanUtils;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.util.Map;

@WebServlet("/loginServlet")
public class LoginServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //1.设置编码
        req.setCharacterEncoding("utf-8");
        /*//2.获取请求参数
        String username = req.getParameter("username");
        String password = req.getParameter("password");
        //3.封装user对象
        User loginuser = new User();
        loginuser.setUsername(username);
        loginuser.setPassword(password);*/
        //2.获取所有请求参数
        Map<String, String[]> map = req.getParameterMap();
        //3.创建User对象
        User loginUser = new User();
        //3.2使用BeanUtils封装
        try {
            BeanUtils.populate(loginUser, map);
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        }

        //4.调用UserDao的login方法
        UserDao dao = new UserDao();
        User user = dao.login(loginUser);

        //5.判断user
        if (user == null) {
            //登录失败
            req.getRequestDispatcher("/failServlet").forward(req, resp);
        }else {
             //登录成功
            //存储数据
            req.setAttribute("user",user);
            req.getRequestDispatcher("/successServlet").forward(req, resp);

        }
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        this.doGet(req, resp);
    }
}

```

### 22登录 BeanUtils案例介绍

```
9. BeanUtils工具类，简化数据封装
			* 用于封装JavaBean的
			1. JavaBean：标准的Java类
				1. 要求：
					1. 类必须被public修饰
					2. 必须提供空参的构造器
					3. 成员变量必须使用private修饰
					4. 提供公共setter和getter方法
				2. 功能：封装数据


			2. 概念：
				成员变量：
				属性：setter和getter方法截取后的产物
					例如：getUsername() --> Username--> username
					
			gender操作的是属性

			3. 方法：
				1. setProperty()            了解
				2. getProperty()            了解
				3. populate(Object obj , Map map):将map集合的键值对信息，封装到对应的JavaBean对象中                          掌握
				
```

## 15_Response

### 01 HTTP响应消息响应行状态码

```
HTTP协议：
	1. 请求消息：客户端发送给服务器端的数据
		* 数据格式：
			1. 请求行
			2. 请求头
			3. 请求空行
			4. 请求体
	2. 响应消息：服务器端发送给客户端的数据
		* 数据格式：
			1. 响应行
				1. 组成：协议/版本 响应状态码 状态码描述
				2. 响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态。
					1. 状态码都是3位数字 
					2. 分类：
						1. 1xx：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码
						2. 2xx：成功。代表：200
						3. 3xx：重定向。代表：302(重定向)，304(访问缓存)
						4. 4xx：客户端错误。
							* 代表：
								* 404（请求路径没有对应的资源） 
								* 405：请求方式没有对应的doXxx方法
						5. 5xx：服务器端错误。代表：500(服务器内部出现异常)
							
* 响应字符串格式
			HTTP/1.1 200 OK
			Content-Type: text/html;charset=UTF-8
			Content-Length: 101
			Date: Wed, 06 Jun 2018 07:08:42 GMT
	
			<html>
			  <head>
			    <title>$Title$</title>
			  </head>
			  <body>
			  hello , response
			  </body>
			</html>
					
```

![重定向](C:/Users/Murphy/Pictures/重定向.bmp)

访问缓存

![image-20210525154601415](C:/Users/Murphy/Pictures/image-20210525154601415.png)

### 02 HTTP响应消息响应头

```
2. 响应头：
				1. 格式：头名称： 值
				2. 常见的响应头：
					1. Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式
					2. Content-disposition：服务器告诉客户端以什么格式打开响应体数据
						* 值：
							* in-line:默认值,在当前页面内打开
							* attachment;filename=xxx：以附件形式打开响应体。文件下载
```

### 03 Response功能介绍

![request&response对象原理](C:/Users/Murphy/Pictures/request&response对象原理-1621950762908.bmp)

```
* 功能：设置响应消息
		1. 设置响应行
			1. 格式：HTTP/1.1 200 ok
			2. 设置状态码：setStatus(int sc) 
		2. 设置响应头：setHeader(String name, String value) 
			
		3. 设置响应体：
			* 使用步骤：
				1. 获取输出流
					* 字符输出流：PrintWriter getWriter()

					* 字节输出流：ServletOutputStream getOutputStream()

				2. 使用输出流，将数据输出到客户端浏览器

```

### 04 Response案例1重定向代码实现

```
案例：
		1. 完成重定向
			* 重定向：资源跳转的方式
			* 代码实现：
				//1. 设置状态码为302
		        response.setStatus(302);
		        //2.设置响应头location
		        response.setHeader("location","/day15/responseDemo2");

		        //简单的重定向方法
		        response.sendRedirect("/day15/responseDemo2");
```

```java
package cn.itcast.web.servlet;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 * 重定向
 */
@WebServlet("/responseDemo1")
public class ResponseDemo1 extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        System.out.println("demo1......");

        //访问、responseDemo1，会自动跳转到/responseDemo2资源
        /*//1.设置状态码为302
        response.setStatus(302);//状态码不能错，固定值
        //2.设置响应头location
        response.setHeader("location","/day15/responseDemo2");*/

        response.sendRedirect("/day15/responseDemo2");
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        this.doPost(request, response);
    }
}

```

### 05 Response案例1重定向特点

```
* 重定向的特点:redirect
				1. 地址栏发生变化
				2. 重定向可以访问其他站点(服务器)的资源
				3. 重定向是两次请求。不能使用request对象来共享数据
			* 转发的特点：forward
				1. 转发地址栏路径不变
				2. 转发只能访问当前服务器下的资源
				3. 转发是一次请求，可以使用request对象来共享数据
			
			* 面试题：forward 和  redirect 区别
```

### 06 Response案例1路径相对和绝对路径

```
* 路径写法：
				1. 路径分类
					1. 相对路径：通过相对路径不可以确定唯一资源
						* 如：./index.html
						* 不以/开头，以.开头路径

						* 规则：找到当前资源和目标资源之间的相对位置关系
							* ./：当前目录
							* ../:后退一级目录
					2. 绝对路径：通过绝对路径可以确定唯一资源
						* 如：http://localhost/day15/responseDemo2		/day15/responseDemo2
						* 以/开头的路径

						* 规则：判断定义的路径是给谁用的？判断请求将来从哪儿发出
							* 给客户端浏览器使用：需要加虚拟目录(项目的访问路径)
								* 建议虚拟目录动态获取：request.getContextPath()
								* <a> , <form> 重定向...
							* 给服务器使用：不需要加虚拟目录
								* 转发路径
```

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    <h1>找到当前资源之间的相对位置关系</h1>
    <p>
        当前资源：location.html
        http://localhost/day15/location.html
    </p>
    <p>
        目标资源：
        http://localhost/day15/responseDemo2
    </p>
    <a href="./responseDemo2">
        resopnseDemo2
    </a>
    <a href="responseDemo2">
        resopnseDemo2
    </a>

    <h1>绝对路径</h1>

    <a href="/day15/responseDemo2">
        responseDemo2
    </a>
</body>
</html>
```

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    <h1>找到当前资源之间的相对位置关系</h1>
    <p>
        当前资源：location.html
        http://localhost/day15/htmls/location2.html
    </p>
    <p>
        目标资源：
        http://localhost/day15/responseDemo2
    </p>
    <a href="../responseDemo2">
        resopnseDemo2
    </a>
</body>
</html>
```

```java
package cn.itcast.web.servlet;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 * 重定向
 */
@WebServlet("/responseDemo1")
public class ResponseDemo1 extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        System.out.println("demo1......");

        //访问、responseDemo1，会自动跳转到/responseDemo2资源
        /*//1.设置状态码为302
        response.setStatus(302);//状态码不能错，固定值
        //2.设置响应头location
        response.setHeader("location","/day15/responseDemo2");*/

        request.setAttribute("mas","response");

        String contextPath = request.getContextPath();

        response.sendRedirect(contextPath + "/responseDemo2");
//        response.sendRedirect("http://www.baidu.com");
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        this.doPost(request, response);
    }
}

```

### 07 Response案例2输出字符数据

```
服务器输出字符数据到浏览器
			* 步骤：
				1. 获取字符输出流
				2. 输出数据

			* 注意：
				* 乱码问题：
					1. PrintWriter pw = response.getWriter();获取的流的默认编码是ISO-8859-1
					2. 设置该流的默认编码
					3. 告诉浏览器响应体使用的编码

					//简单的形式，设置编码，是在获取流之前设置
        			response.setContentType("text/html;charset=utf-8");
```

![response乱码](C:/Users/Murphy/Pictures/response乱码.bmp)

```java
package cn.itcast.web.servlet;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintWriter;

@WebServlet("/responseDemo4")
public class ResponseDemo4 extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //获取流对象之前，设置流的默认编码：ISO-8850-1 设置为：GBK
        //response.setCharacterEncoding("GBK");

        //告诉浏览器，服务器发送的消息体数据的编码。建议浏览器使用该编码解码
        //response.setHeader("content-type","text/html;charset=utf-8");

        //简单的形式，设置编码
        response.setContentType("text/html;charset=utf-8");

        //1.获取字符输出流
        PrintWriter pw = response.getWriter();
        //2.输出数据
        //pw.println("<h1>hello response</h1>");
        pw.println("你好啊啊啊啊 response");
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        this.doPost(request, response);
    }
}

```

### 08 Response_案例3输出字节数据

```
3. 服务器输出字节数据到浏览器
			* 步骤：
				1. 获取字节输出流
				2. 输出数据
```

```java
package cn.itcast.web.servlet;

import javax.servlet.ServletException;
import javax.servlet.ServletOutputStream;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebServlet("/responseDemo5")
public class ResponseDemo5 extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        response.setContentType("text/html;charset=utf-8");

        //1.获取字节输出流
        ServletOutputStream sos = response.getOutputStream();
        //2.输出数据
        sos.write("你好".getBytes("utf-8"));
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        this.doPost(request, response);
    }
}

```

### 09 Response案例4验证码分析

```
4. 验证码
			1. 本质：图片
			2. 目的：防止恶意表单注册
```

![image-20210530154006153](C:/Users/Murphy/Pictures/image-20210530154006153.png)

### 10 Response案例4验证码代码实现

```java
package cn.itcast.web.servlet;

import javax.imageio.ImageIO;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.Random;

@WebServlet("/CheckCodeServlet")
public class CheckCodeServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

        int width = 100;
        int height = 50;

        //1.创建一个对象，在内存代表图片(验证码图片对象)
        BufferedImage image = new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB);
        //2.美化图片
        //2.1填充背景色
        Graphics2D g = image.createGraphics();//画笔对象
        g.setColor(Color.pink);//设置画笔颜色
        g.fillRect(0,0,width, height);

        //2.2画边框
        g.setColor(Color.blue);
        g.drawRect(0,0,width - 1, height - 1);

        String str = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
        //生成随机角标
        Random ran = new Random();


        //2.3写验证码
        for (int i = 1; i <= 4; i++) {
            int index = ran.nextInt(str.length());
            //获取字符
            char ch = str.charAt(index);//随机字符
            g.drawString(ch+"",width/5*i,height/2);
        }

        //2.4画干扰线
        g.setColor(Color.green);

        //随机生成坐标点
        for (int i = 0; i < 10; i++) {
            int x1 = ran.nextInt(width);
            int x2 = ran.nextInt(width);

            int y1 = ran.nextInt(height);
            int y2 = ran.nextInt(height);

            g.drawLine(x1,y1,x2,y2);
        }

        //3.将图片输出到页面展示
        ImageIO.write(image, "jpg",response.getOutputStream());
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        this.doPost(request, response);
    }
}

```

### 11 Response案例4验证码点击切换

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>

    <script>
        /*
            分析：
                点击超链接或者图片，需要换一张
                1.给超链接和图片绑定单击事件

                2.重新设置图片的src属性值
         */
        window.onload = function () {
            //1.获取图片对象
            var img = document.getElementById("checkCode");
            img.onclick = function () {
                //加时间戳
                var date = new Date().getTime();
                img.src = "/day15/checkCodeServlet?"+date;//?不能省略
            }
        }
    </script>
</head>
<body>
    <img id="checkCode" src="/day15/checkCodeServlet" />

    <a id="change" href="">看不清换一张？</a>
</body>
</html>
```

### 12 ServletContext概念&获取

```java
 1. 概念：代表整个web应用，可以和程序的容器(服务器)来通信
 2. 获取：
		1. 通过request对象获取
			request.getServletContext();
		2. 通过HttpServlet获取
			this.getServletContext();
 3. 功能：
		1. 获取MIME类型：
			* MIME类型:在互联网通信过程中定义的一种文件数据类型
				* 格式： 大类型/小类型   text/html		image/jpeg

			* 获取：String getMimeType(String file)  
		2. 域对象：共享数据
			1. setAttribute(String name,Object value)
			2. getAttribute(String name)
			3. removeAttribute(String name)

			* ServletContext对象范围：所有用户所有请求的数据
		3. 获取文件的真实(服务器)路径
			1. 方法：String getRealPath(String path)  
				 String b = context.getRealPath("/b.txt");//web目录下资源访问
		         System.out.println(b);
		
		        String c = context.getRealPath("/WEB-INF/c.txt");//WEB-INF目录下的资源访问
		        System.out.println(c);
		
		        String a = context.getRealPath("/WEB-INF/classes/a.txt");//src目录下的资源访问
		        System.out.println(a);
```

### 13 ServletContext功能-获取MME类型

```java
package cn.itcast.web.servletcontext;

import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebServlet("/servletContextDemo2")
public class ServletContextDemo2 extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        /**ServletContext对象的获取
         * 1. 获取MIME类型：
         * 			* MIME类型:在互联网通信过程中定义的一种文件数据类型
         * 				* 格式： 大类型/小类型   text/html		image/jpeg
         *
         * 			* 获取：String getMimeType(String file)
         * */

        //2. 通过HttpServlet获取
        ServletContext context = this.getServletContext();

        //3.定义文件名称
        String filname = "a.jpg";//image/jpeg

        //4.获取MIME类型
        String mimeType = context.getMimeType(filname);
        System.out.println(mimeType);
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        this.doPost(request, response);
    }
}

```

### 14 ServletContext功能-域对象

```java
package cn.itcast.web.servletcontext;

import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebServlet("/servletContextDemo2")
public class ServletContextDemo2 extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        /**ServletContext对象的获取
         * 1. 获取MIME类型：
         * 			* MIME类型:在互联网通信过程中定义的一种文件数据类型
         * 				* 格式： 大类型/小类型   text/html		image/jpeg
         *
         * 			* 获取：String getMimeType(String file)
         * */

        //2. 通过HttpServlet获取
        ServletContext context = this.getServletContext();

        //3.定义文件名称
        String filname = "a.jpg";//image/jpeg

        //4.获取MIME类型
        String mimeType = context.getMimeType(filname);
        System.out.println(mimeType);
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        this.doPost(request, response);
    }
}

```

### 15 ServletContext功能-获取文件服务器路径

```java
package cn.itcast.web.servletcontext;

import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebServlet("/servletContextDemo5")
public class ServletContextDemo5 extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        /**ServletContext对象的获取
         * 3. 获取文件真实路径
         * */

        //通过HttpServlet获取
        ServletContext context = this.getServletContext();

        //获取文件真实路径
        String realPath = context.getRealPath("/b.txt");//web目录下资源访问
        System.out.println(realPath);
        //File file = new File(realPath);
        String c = context.getRealPath("/WEB-INF/c.txt");//WEB-INF目录下的资源访问
        System.out.println(c);

        String a = context.getRealPath("/WEB-INF/classes/a.txt");//src目录下的资源访问
        System.out.println(a);
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        this.doPost(request, response);
    }
}

```

### 16 案例文件下载分析

```
* 文件下载需求：
		1. 页面显示超链接
		2. 点击超链接后弹出下载提示框
		3. 完成图片文件下载


	* 分析：
		1. 超链接指向的资源如果能够被浏览器解析，则在浏览器中展示，如果不能解析，则弹出下载提示框。不满足需求
		2. 任何资源都必须弹出下载提示框
		3. 使用响应头设置资源的打开方式：
			* content-disposition:attachment;filename=xxx
步骤：
		1. 定义页面，编辑超链接href属性，指向Servlet，传递资源名称filename
		2. 定义Servlet
			1. 获取文件名称
			2. 使用字节输入流加载文件进内存
			3. 指定response的响应头： content-disposition:attachment;filename=xxx
			4. 将数据写出到response输出流
```

### 17 案例文件下载代码实现

```java
package cn.itcast.web.download;

import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.ServletOutputStream;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.FileInputStream;
import java.io.IOException;

@WebServlet("/downloadServlet")
public class DownloadServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //1.获取请求参数，文件名称
        String filename = request.getParameter("filename");
        //2.使用字节输入流加载文件进内存
        //2.1找到服务器路径
        ServletContext servletContext = this.getServletContext();
        String realPath = servletContext.getRealPath("/img/" + filename);
        //2.2用字节流关联
        FileInputStream fis = new FileInputStream(realPath);

        //3.设置response的响应头
        //3.1设置响应头类型：content-type
        String mimeType = servletContext.getMimeType(filename);//获取文件的mime类型
        response.setHeader("content-type",mimeType);
        //3.2设置响应头打开方式：content-disposition
        response.setHeader("content-disposition","attachment;fielname="+filename);

        //4.将输入流的数据写入到输出流中
        ServletOutputStream sos = response.getOutputStream();
        byte[] buff = new byte[1024 * 8];
        int len = 0;
        while ((len = fis.read(buff)) != -1){
            sos.write(buff, 0, len);
        }

        fis.close();
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        this.doPost(request, response);
    }
}

```

### 18 案例文件下载中文文件名问题

```
 问题：
		* 中文文件问题
			* 解决思路：
				1. 获取客户端使用的浏览器版本信息
				2. 根据不同的版本信息，设置filename的编码方式不同
				
注意sun.misc.BASE64Encoder   jdk1.8之后已经停用
```

```java
package cn.itcast.web.utils;

import sun.misc.BASE64Encoder;

import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;


public class DownLoadUtils {

    public static String getFileName(String agent, String filename) throws UnsupportedEncodingException {
        if (agent.contains("MSIE")) {
            // IE浏览器
            filename = URLEncoder.encode(filename, "utf-8");
            filename = filename.replace("+", " ");
        } else if (agent.contains("Firefox")) {
            // 火狐浏览器
            BASE64Encoder base64Encoder = new BASE64Encoder();
            filename = "=?utf-8?B?" + base64Encoder.encode(filename.getBytes("utf-8")) + "?=";
        } else {
            // 其它浏览器
            filename = URLEncoder.encode(filename, "utf-8");
        }
        return filename;
    }
}

```

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

    <a href="/day15/img/1.jpg">图片1</a>
    <a href="/day15/img/1.avi">视频</a>
    <hr>

    <a href="/day15/downloadServlet?filename=九尾.jpg">图片1</a>

    <a href="/day15/downloadServlet?filename=1.avi">视频</a>
</body>
</html>
```

```java
package cn.itcast.web.download;

import cn.itcast.web.utils.DownLoadUtils;

import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.ServletOutputStream;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.FileInputStream;
import java.io.IOException;

@WebServlet("/downloadServlet")
public class DownloadServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //1.获取请求参数，文件名称
        String filename = request.getParameter("filename");
        //2.使用字节输入流加载文件进内存
        //2.1找到文件服务器路径
        ServletContext servletContext = this.getServletContext();
        String realPath = servletContext.getRealPath("/img/" + filename);
        //2.2用字节流关联
        FileInputStream fis = new FileInputStream(realPath);

        //3.设置response的响应头
        //3.1设置响应头类型：content-type
        String mimeType = servletContext.getMimeType(filename);//获取文件的mime类型
        response.setHeader("content-type",mimeType);
        //3.2设置响应头打开方式:content-disposition

        //解决中文文件名问题
        //1.获取user-agent请求头、
        String agent = request.getHeader("user-agent");
        //2.使用工具类方法编码文件名即可
        filename = DownLoadUtils.getFileName(agent, filename);

        response.setHeader("content-disposition","attachment;filename="+filename);
        //4.将输入流的数据写出到输出流中
        ServletOutputStream sos = response.getOutputStream();
        byte[] buff = new byte[1024 * 8];
        int len = 0;
        while((len = fis.read(buff)) != -1){
            sos.write(buff,0,len);
        }

        fis.close();


    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        this.doPost(request,response);
    }
}

```

## 16_Cookie&Session

### 01会话技术概述

```
	1. 会话：一次会话中包含多次请求和响应。
		* 一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止
	2. 功能：在一次会话的范围内的多次请求间，共享数据
	3. 方式：
		1. 客户端会话技术：Cookie
		2. 服务器端会话技术：Session
```

### 02会话技术Cookie快速入门

```java
package cn.itcast.cookie;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 * cookie快速入门
 */
@WebServlet("/cookieDemo1")
public class CookieDemo1 extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //1.创建cookie对象
        Cookie c = new Cookie("msg", "hello");
        //2.发送cookie
        response.addCookie(c);
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        this.doPost(request, response);
    }
}

```

```java
package cn.itcast.cookie;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 * cookie快速入门
 */
@WebServlet("/cookieDemo2")
public class CookieDemo2 extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //3.获取cookie
        Cookie[] cs = request.getCookies();
        //获取数据，遍历Cookies
        if (cs != null) {//此处易写错!=
            for (Cookie c : cs) {
                String name = c.getName();
                String value = c.getValue();
                System.out.println(name+":"+value);
            }
        }
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        this.doPost(request, response);
    }
}

```

### 03会话技术Cookie原理分析

```
* 基于响应头set-cookie和请求头cookie实现
```

![Cookie原理](C:/Users/Murphy/Pictures/Cookie原理.bmp)

### 04会话技术Cookie细节1发送多个Cookie

```
cookie的细节
		1. 一次可不可以发送多个cookie?
			* 可以
			* 可以创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可。
		2. cookie在浏览器中保存多长时间？
			1. 默认情况下，当浏览器关闭后，Cookie数据被销毁
			2. 持久化存储：
				* setMaxAge(int seconds)
					1. 正数：将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效
					2. 负数：默认值
					3. 零：删除cookie信息
		3. cookie能不能存中文？
			* 在tomcat 8 之前 cookie中不能直接存储中文数据。
				* 需要将中文数据转码---一般采用URL编码(%E3)
			* 在tomcat 8 之后，cookie支持中文数据。
			注意：特殊字符还是不支持，建议使用URL编码存储，URL解码解析
		4. cookie共享问题？
			1. 假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享？
				* 默认情况下cookie不能共享

				* setPath(String path):设置cookie的获取范围。默认情况下，设置当前的虚拟目录
					* 如果要共享，则可以将path设置为"/"

			
			2. 不同的tomcat服务器间cookie共享问题？
				* setDomain(String path):如果设置一级域名相同，那么多个服务器之间cookie可以共享
					* setDomain(".baidu.com"),那么tieba.baidu.com和news.baidu.com中cookie可以共享
```

```java
package cn.itcast.cookie;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 * cookie快速入门
 */
@WebServlet("/cookieDemo3")
public class CookieDemo3 extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //1.创建cookie对象
        Cookie c1 = new Cookie("msg", "hello");
        Cookie c2 = new Cookie("name", "zhangsan");
        //2.发送cookie
        response.addCookie(c1);
        response.addCookie(c2);
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        this.doPost(request, response);
    }
}

```



### 05会话技术Cookie细节2Cookie存活时间

```java
package cn.itcast.cookie;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 * cookie快速入门
 */
@WebServlet("/cookieDemo4")
public class CookieDemo4 extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //1.创建cookie对象
        Cookie c1 = new Cookie("msg", "setMaxAge");
        //c1.setMaxAge(30);//将cookie持久化到硬盘，30秒后会自动删除cookie文件;
        //c1.setMaxAge(-1);
        //c1.setMaxAge(300);
        c1.setMaxAge(0);
        //2.发送cookie
        response.addCookie(c1);
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        this.doPost(request, response);
    }
}

```

### 06会话技术Cookie细节3Cookie存储中文

```
Cookie c1 = new Cookie("msg", "你好");
```

### 07会话技术Cookie细节4Cookie共享

```java
package cn.itcast.cookie;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 * cookie快速入门
 */
@WebServlet("/cookieDemo5")
public class CookieDemo5 extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //1.创建cookie对象
        Cookie c1 = new Cookie("msg", "你好");
        //c1.setPath("/day16");
        //设置path，让当前服务器下部署的所有项共享cookie信息
        c1.setPath("/");//扩大共享cookie的范围，代表当前项目根路径     msg:你好  测试项目为day15下的cookieDemo
     
        //3.发送cookie
        response.addCookie(c1);
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        this.doPost(request, response);
    }
}

```

### 08会话技术Cookie特点&作用

```
 Cookie的特点和作用
		1. cookie存储数据在客户端浏览器
		2. 浏览器对于单个cookie 的大小有限制(4kb) 以及 对同一个域名下的总cookie数量也有限制(20个)

		* 作用：
			1. cookie一般用于存出少量的不太敏感的数据
			2. 在不登录的情况下，完成服务器对客户端的身份识别
```

### 09会话技术Cookie案例分析

```
案例：记住上一次访问时间
		1. 需求：
			1. 访问一个Servlet，如果是第一次访问，则提示：您好，欢迎您首次访问。
			2. 如果不是第一次访问，则提示：欢迎回来，您上次访问时间为:显示时间字符串

		2. 分析：
			1. 可以采用Cookie来完成
			2. 在服务器中的Servlet判断是否有一个名为lastTime的cookie
				1. 有：不是第一次访问
					1. 响应数据：欢迎回来，您上次访问时间为:2018年6月10日11:50:20
					2. 写回Cookie：lastTime=2018年6月10日11:50:01
				2. 没有：是第一次访问
					1. 响应数据：您好，欢迎您首次访问
					2. 写回Cookie：lastTime=2018年6月10日11:50:01
```

![Cookie案例_记住上次访问时间](C:/Users/Murphy/Pictures/Cookie案例_记住上次访问时间.bmp)

### 10会话技术Cookie案例代码实现

```java
//java.lang.IllegalArgumentException: An invalid character [32] was present in the Cookie value
package cn.itcast.cookie;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
   在服务器中的Servlet判断是否有一个名为lastTime的cookie
  				1. 有：不是第一次访问
  					1. 响应数据：欢迎回来，您上次访问时间为:2018年6月10日11:50:20
  					2. 写回Cookie：lastTime=2018年6月10日11:50:01
  				2. 没有：是第一次访问
 					1. 响应数据：您好，欢迎您首次访问
  					2. 写回Cookie：lastTime=2018年6月10日11:50:01
 */

@WebServlet("/cookieTest")
public class CookieTest extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //设置响应的消息体的数据格式以及编码
        response.setContentType("text/heml;charset=utf-8");
        //1.获取所有的cookie
        Cookie[] cookies = request.getCookies();
        boolean flag = false;//没有cookie为lastTime
        //2.遍历cookie数组
        if (cookies != null && cookies.length > 0) {
            for (Cookie cookie : cookies) {
                //3.获取cookie的名称
                String name = cookie.getName();
                //4.判断名称是否是lastTime
                if ("lastTime".equals(name)){
                    //有该cookie，不是第一次访问
                    flag = true;//有lastTime的cookie

                    //设置cookie的value
                    //获取当前时间的字符串，重新设置cookie的值，重新发送cookie
                    Date date = new Date();
                    SimpleDateFormat sdf = new SimpleDateFormat("yyyy年mm月dd hh:mm:ss");
                    String str_date = sdf.format(date);
                    System.out.println("编码前"+str_date);
                    //URL编码
                    str_date = URLEncoder.encode(str_date, "UTF-8");
                    System.out.println("编码后"+str_date);
                    cookie.setValue(str_date);
                    //设置cookie的存活时间30天
                    cookie.setMaxAge(60 * 60 * 24 * 30);

                    response.addCookie(cookie);

                    //响应数据
                    //获取cookie的value，时间
                    String value = cookie.getValue();
                    //URL解码：
                    System.out.println("解码前：" + value);
                    value = URLDecoder.decode(value, "UTF-8");
                    System.out.println("解码后：" + value);
                    response.getWriter().print("<h1>欢迎回来，您上次访问时间为:"+value+"</h1>");

                    break;
                }
            }
        }

        if(cookies ==null || cookies.length == 0 || flag == false){
            //没有，第一次访问
            Date date = new Date();
            SimpleDateFormat sdf = new SimpleDateFormat("yyyy年mm月dd hh:mm:ss");
            String str_date = sdf.format(date);
            System.out.println("编码前"+str_date);
            //URL编码
            str_date = URLEncoder.encode(str_date, "UTF-8");
            System.out.println("编码后"+str_date);
            Cookie cookie = new Cookie("lastTime", str_date);
            //设置cookie的存活时间30天
            cookie.setMaxAge(60 * 60 * 24 * 30);
            response.addCookie(cookie);


            response.getWriter().print("<h1>您好，欢迎您首次访问</h1>");
        }
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        this.doPost(request, response);
    }
}

```

### 11JSP概念

```
1. 概念：
		* Java Server Pages： java服务器端页面
			* 可以理解为：一个特殊的页面，其中既可以指定定义html标签，又可以定义java代码
			* 用于简化书写！！！
```

### 12JSP原理

```
* JSP本质上就是一个Servlet
```

![JSP原理](C:/Users/Murphy/Pictures/JSP原理.bmp)

### 13JSP脚本

```
 JSP的脚本：JSP定义Java代码的方式
		1. <%  代码 %>：定义的java代码，在service方法中。
		service方法中可以定义什么，该脚本中就可以定义什么。
		2. <%! 代码 %>：定义的java代码，在jsp转换后的java类的成员位置。
		3. <%= 代码 %>：定义的java代码，会输出到页面上。输出语句中可以定义什么，该脚本中就可以定义什么。
```

```jsp
<%--
  Created by IntelliJ IDEA.
  User: Murphy
  Date: 2021-06-06
  Time: 10:56
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
  <head>
    <title>$Title$</title>
  </head>
  <body>
      <%
        System.out.println("hello jsp");
        int i = 5;
      %>

      <%! int i =3; %>

      <%= "hello" %>

      System.out.println("hello jsp");
      <h1>hi ~jsp!</h1>

  </body>
</html>

```

### 14JSP入门学习

```
JSP的内置对象：
		* 在jsp页面中不需要获取和创建，可以直接使用的对象
		* jsp一共有9个内置对象。
		* 今天学习3个：
			* request
			* response
			* out：字符输出流对象。可以将数据输出到页面上。和response.getWriter()类似
				* response.getWriter()和out.write()的区别：
					* 在tomcat服务器真正给客户端做出响应之前，会先找response缓冲区数据，再找out缓冲区数据。
					* response.getWriter()数据输出永远在out.write()之前
```

![image-20210616165512762](C:/Users/Murphy/Pictures/image-20210616165512762.png)

### 15JSP案例改造Cookie案例

```jsp
<%@ page import="java.util.Date" %>
<%@ page import="java.text.SimpleDateFormat" %>
<%@ page import="java.net.URLEncoder" %>
<%@ page import="java.net.URLDecoder" %>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>itcast</title>
</head>
<body>

<%

    //1.获取所有Cookie
    Cookie[] cookies = request.getCookies();
    boolean flag = false;//没有cookie为lastTime
    //2.遍历cookie数组
    if(cookies != null && cookies.length > 0){
        for (Cookie cookie : cookies) {
            //3.获取cookie的名称
            String name = cookie.getName();
            //4.判断名称是否是：lastTime
            if("lastTime".equals(name)){
                //有该Cookie，不是第一次访问

                flag = true;//有lastTime的cookie

                //设置Cookie的value
                //获取当前时间的字符串，重新设置Cookie的值，重新发送cookie
                Date date  = new Date();
                SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss");
                String str_date = sdf.format(date);
                System.out.println("编码前："+str_date);
                //URL编码
                str_date = URLEncoder.encode(str_date,"utf-8");
                System.out.println("编码后："+str_date);
                cookie.setValue(str_date);
                //设置cookie的存活时间
                cookie.setMaxAge(60 * 60 * 24 * 30);//一个月
                response.addCookie(cookie);

                //响应数据
                //获取Cookie的value，时间
                String value = cookie.getValue();
                System.out.println("解码前："+value);
                //URL解码：
                value = URLDecoder.decode(value,"utf-8");
                System.out.println("解码后："+value);
%>
<h1>欢迎回来，您上次访问时间为:<%=value%></h1>
<input>

<%

                break;

            }
        }
    }


    if(cookies == null || cookies.length == 0 || flag == false){
        //没有，第一次访问

        //设置Cookie的value
        //获取当前时间的字符串，重新设置Cookie的值，重新发送cookie
        Date date  = new Date();
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss");
        String str_date = sdf.format(date);
        System.out.println("编码前："+str_date);
        //URL编码
        str_date = URLEncoder.encode(str_date,"utf-8");
        System.out.println("编码后："+str_date);

        Cookie cookie = new Cookie("lastTime",str_date);
        //设置cookie的存活时间
        cookie.setMaxAge(60 * 60 * 24 * 30);//一个月
        response.addCookie(cookie);

%>

<h1>您好，欢迎您首次访问</h1>
<span></span>

<%
    }

%>

<input>

</body>
</html>

```

### 16会话技术Session快速入门

```
 概念：服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession
 快速入门：
		1. 获取HttpSession对象：
			HttpSession session = request.getSession();
		2. 使用HttpSession对象：
			Object getAttribute(String name)  
			void setAttribute(String name, Object value)
			void removeAttribute(String name)  
```

```java
package cn.itcast.session;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;

@WebServlet("/sessionDemo1")
public class SessionDemo1 extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //使用session共享数据

        //1.获取session
        HttpSession session = request.getSession();
        //2.存储数据
        session.setAttribute("msg","hello session");
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        this.doPost(request, response);
    }
}

```

```java
package cn.itcast.session;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;

@WebServlet("/sessionDemo2")
public class SessionDemo2 extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //使用session共享数据

        //1.获取session
        HttpSession session = request.getSession();
        //2.获取数据
        Object msg = session.getAttribute("msg");
        System.out.println(msg);
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        this.doPost(request, response);
    }
}

```

### 17会话技术Session原理分析

```
原理
		* Session的实现是依赖于Cookie的。
```

![Session原理](C:/Users/Murphy/Pictures/Session原理.bmp)

### 18会话技术Session细节1

```java
细节：
		1. 当客户端关闭后，服务器不关闭，两次获取session是否为同一个？
			* 默认情况下。不是。
			* 如果需要相同，则可以创建Cookie,键为JSESSIONID，设置最大存活时间，让cookie持久化保存。
				 Cookie c = new Cookie("JSESSIONID",session.getId());
		         c.setMaxAge(60*60);
		         response.addCookie(c);

		2. 客户端不关闭，服务器关闭后，两次获取的session是同一个吗？
			* 不是同一个，但是要确保数据不丢失。tomcat自动完成以下工作
				* session的钝化：
					* 在服务器正常关闭之前，将session对象序列化到硬盘上
				* session的活化：
					* 在服务器启动后，将session文件转化为内存中的session对象即可。
            注意：idea中的tomcat重启时会删除work目录重建所以获取不到
				
		3. session什么时候被销毁？
			1. 服务器关闭
			2. session对象调用invalidate() 。
			3. session默认失效时间 30分钟
				选择性配置修改	
				<session-config>
			        <session-timeout>30</session-timeout>
			    </session-config>
```

```java
package cn.itcast.session;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.*;
import java.io.IOException;

@WebServlet("/sessionDemo3")
public class SessionDemo3 extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //使用session共享数据

        //1.获取session
        HttpSession session = request.getSession();
        System.out.println(session);

        //期望客户端关闭后，session也能相同
        Cookie c = new Cookie("JSESSIONID",session.getId());//必须为JSESSIONID。不能写错
        c.setMaxAge(60*60);
        response.addCookie(c);

    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        this.doPost(request, response);
    }
}

```

### 19会话技术Session细节2

```
org.apache.catalina.session.StandardSessionFacade@f5f28c7
```

### 20会话技术Session细节3session销毁

```
D:\apache-tomcat-8.5.31\conf
```

### 21会话技术Session特点

```
session的特点
		 1. session用于存储一次会话的多次请求的数据，存在服务器端
		 2. session可以存储任意类型，任意大小的数据

		* session与Cookie的区别：
			1. session存储数据在服务器端，Cookie在客户端
			2. session没有数据大小限制，Cookie有
			3. session数据安全，Cookie相对于不安全
```

### 22案例验证码需求&分析

```
 案例：验证码
	1. 案例需求：
		1. 访问带有验证码的登录页面login.jsp
		2. 用户输入用户名，密码以及验证码。
			* 如果用户名和密码输入有误，跳转登录页面，提示:用户名或密码错误
			* 如果验证码输入有误，跳转登录页面，提示：验证码错误
			* 如果全部输入正确，则跳转到主页success.jsp，显示：用户名,欢迎您
```

![登录案例](C:/Users/Murphy/Pictures/登录案例-1623930101603.bmp)

### 23案例验证码代码实现

```java
package cn.itcast.Servlet;

import javax.imageio.ImageIO;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.Random;

@WebServlet("/checkCodeServlet")
public class CheckCodeServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

        int width = 100;
        int height = 50;

        //1.创建一个对象，在内存代表图片(验证码图片对象)
        BufferedImage image = new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB);
        //2.美化图片
        //2.1填充背景色
        Graphics2D g = image.createGraphics();//画笔对象
        g.setColor(Color.pink);//设置画笔颜色
        g.fillRect(0,0,width, height);

        //2.2画边框
        g.setColor(Color.blue);
        g.drawRect(0,0,width - 1, height - 1);

        String str = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
        //生成随机角标
        Random ran = new Random();
        StringBuilder sb = new StringBuilder();

        //2.3写验证码
        for (int i = 1; i <= 4; i++) {
            int index = ran.nextInt(str.length());
            //获取字符
            char ch = str.charAt(index);//随机字符
            sb.append(ch);
            g.drawString(ch+"",width/5*i,height/2);
        }
        String checkCode_session = sb.toString();
        //将验证码存入session
        request.getSession().setAttribute("checkCode_session",checkCode_session);

        //2.4画干扰线
        g.setColor(Color.green);

        //随机生成坐标点
        for (int i = 0; i < 10; i++) {
            int x1 = ran.nextInt(width);
            int x2 = ran.nextInt(width);

            int y1 = ran.nextInt(height);
            int y2 = ran.nextInt(height);

            g.drawLine(x1,y1,x2,y2);
        }

        //3.将图片输出到页面展示
        ImageIO.write(image, "jpg",response.getOutputStream());
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        this.doPost(request, response);
    }
}

```

```java
package cn.itcast.Servlet;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;

@WebServlet("/loginServlet")
public class LoginServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //1.设置request编码
        request.setCharacterEncoding("UTF-8");
        //2.获取参数(实际应该获取 request.getParameterMap())
        String username = request.getParameter("username");
        String password = request.getParameter("password");//password易出错
        String checkCode = request.getParameter("checkCode");

        //3.先获取生成的验证码
        HttpSession session = request.getSession();
        String checkCode_session = (String)session.getAttribute("checkCode_session");
        //3.先判断验证码是否正确
        if(checkCode_session.equalsIgnoreCase(checkCode)){
            //忽略大小写比较
            //判断用户名和密码是否一致
            if ("zhangsan".equals(username) && "123".equals(password)){//需要用UserDao查询数据库
                //登陆成功
                //存储信息，用户信息
                session.setAttribute("user",username);
                //重定向到success.jsp
                response.sendRedirect(request.getContextPath()+"/success.jsp");
            }else {
                //登陆失败
                //存储信息，用户信息
                request.setAttribute("login_error", "用户名或密码错误");
                //转发到登录页面
                request.getRequestDispatcher("/login.jsp").forward(request, response);
            }

        }else {
            //验证码不一致
            //存储提示信息到request
            request.setAttribute("cc_error","验证码错误");
            //转发到登录页面
            request.getRequestDispatcher("/login.jsp").forward(request,response);
        }
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        this.doPost(request, response);
    }
}

```

```jsp
<%--
  Created by IntelliJ IDEA.
  User: Murphy
  Date: 2021-06-17
  Time: 20:04
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Login</title>
    <script>
        window.onload = function () {
            document.getElementById("img").onclick = function () {
                this.src = "/day16/checkCodeServlet?time=" + new Date().getTime();
            }
        }
    </script>
    <style>
        div{
            color: red;
        }
    </style>
</head>
<body>
<form action="/day16/loginServlet" method="post">
    <table>
        <tr>
        <tr>
            <td>用户名</td>
            <td><input type="text" name="username"></td>
        </tr>
        <tr>
            <td>密码</td>
            <td><input type="password" name="password"></td>
        </tr>
        <tr>
            <td>验证码</td>
            <td><input type="text" name="checkCode"></td>
        </tr>
        <tr>
            <td colspan="2"><img id="img" src="/day16/checkCodeServlet"></td>
        </tr>
        <tr>
            <td colspan="2"><input type="submit" value="登录"></td>
        </tr>
    </table>
</form>

<div>
    <%=request.getAttribute("cc_error")%></div>
<div>
    <%=request.getAttribute("login_error")%></div>
</body>
</html>

```

```jsp
<%--
  Created by IntelliJ IDEA.
  User: Murphy
  Date: 2021-06-17
  Time: 20:58
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    <h1><%=request.getSession().getAttribute("user") %>,欢迎您</h1>
</body>
</html>

```

### 24案例验证码细节处理

第一个是处理返回上一步验证码依然能用的情况，判空

第二个是处理未收到错误信息的时候显示内容，三元表达式

```java
package cn.itcast.Servlet;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;

@WebServlet("/loginServlet")
public class LoginServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //1.设置request编码
        request.setCharacterEncoding("UTF-8");
        //2.获取参数(实际应该获取 request.getParameterMap())
        String username = request.getParameter("username");
        String password = request.getParameter("password");//password易出错
        String checkCode = request.getParameter("checkCode");

        //3.先获取生成的验证码
        HttpSession session = request.getSession();
        String checkCode_session = (String)session.getAttribute("checkCode_session");
        //删除session中存储的验证码
        session.removeAttribute("checkCode_session");
        //3.先判断验证码是否正确
        if(checkCode_session!= null && checkCode_session.equalsIgnoreCase(checkCode)){
            //忽略大小写比较
            //判断用户名和密码是否一致
            if ("zhangsan".equals(username) && "123".equals(password)){//需要用UserDao查询数据库
                //登陆成功
                //存储信息，用户信息
                session.setAttribute("user",username);
                //重定向到success.jsp
                response.sendRedirect(request.getContextPath()+"/success.jsp");
            }else {
                //登陆失败
                //存储信息，用户信息
                request.setAttribute("login_error", "用户名或密码错误");
                //转发到登录页面
                request.getRequestDispatcher("/login.jsp").forward(request, response);
            }

        }else {
            //验证码不一致
            //存储提示信息到request
            request.setAttribute("cc_error","验证码错误");
            //转发到登录页面
            request.getRequestDispatcher("/login.jsp").forward(request,response);
        }
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        this.doPost(request, response);
    }
}

```

```jsp
<%--
  Created by IntelliJ IDEA.
  User: Murphy
  Date: 2021-06-17
  Time: 20:04
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Login</title>
    <script>
        window.onload = function () {
            document.getElementById("img").onclick = function () {
                this.src = "/day16/checkCodeServlet?time=" + new Date().getTime();
            }
        }
    </script>
    <style>
        div{
            color: red;
        }
    </style>
</head>
<body>
<form action="/day16/loginServlet" method="post">
    <table>
        <tr>
        <tr>
            <td>用户名</td>
            <td><input type="text" name="username"></td>
        </tr>
        <tr>
            <td>密码</td>
            <td><input type="password" name="password"></td>
        </tr>
        <tr>
            <td>验证码</td>
            <td><input type="text" name="checkCode"></td>
        </tr>
        <tr>
            <td colspan="2"><img id="img" src="/day16/checkCodeServlet"></td>
        </tr>
        <tr>
            <td colspan="2"><input type="submit" value="登录"></td>
        </tr>
    </table>
</form>

<div>
    <%=request.getAttribute("cc_error") == null ?"" :request.getAttribute("cc_error")%></div>
<div>
    <%=request.getAttribute("login_error") == null ?"" :request.getAttribute("login_error")%></div>
</body>
</html>

```

## 17_EL&JSTL

### 02JSP指令概述

```
1. 指令
		* 作用：用于配置JSP页面，导入资源文件
		* 格式：
			<%@ 指令名称 属性名1=属性值1 属性名2=属性值2 ... %>
		* 分类：
			1. page		： 配置JSP页面的
				* contentType：等同于response.setContentType()
					1. 设置响应体的mime类型以及字符集
					2. 设置当前jsp页面的编码（只能是高级的IDE才能生效，如果使用低级工具，则需要设置pageEncoding属性设置当前页面的字符集）
				* import：导包
				* errorPage：当前页面发生异常后，会自动跳转到指定的错误页面
				* isErrorPage：标识当前也是是否是错误页面。
					* true：是，可以使用内置对象exception
					* false：否。默认值。不可以使用内置对象exception


			
```

### 03JSP_指令_page指令

```jsp
<%--
  Created by IntelliJ IDEA.
  User: Murphy
  Date: 2021-06-18
  Time: 18:21
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" isErrorPage="true" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
<h1>服务器正忙...</h1>
<%
    String message = exception.getMessage();
    out.print(message);
%>
</body>
</html>
```

### 04JSP_指令include&taglib指令

```
2. include	： 页面包含的。导入页面的资源文件
				* <%@include file="top.jsp"%>
3. taglib	： 导入资源
				* <%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
					* prefix：前缀，自定义的
```

### 05JSP注释

```
注释:
		1. html注释：
			<!-- -->:只能注释html代码片段
		2. jsp注释：推荐使用
			<%-- --%>：可以注释所有
```

### 06JSP_内置对象

```
内置对象
		* 在jsp页面中不需要创建，直接使用的对象
		* 一共有9个：
				变量名					真实类型						作用
			* pageContext				PageContext		当前页面共享数据，还可以获取其他八个内置对象
			* request					HttpServletRequest			一次请求访问的多个资源(转发)
			* session					HttpSession					一次会话的多个请求间
			* application				ServletContext				所有用户间共享数据
			* response					HttpServletResponse			响应对象
			* page						Object						当前页面(Servlet)的对象  this
			* out						JspWriter					输出对象，数据输出到页面上
			* config					ServletConfig				Servlet的配置对象
			* exception					Throwable					异常对象
```

### 07MVCjsp演变历史

```
MVC：开发模式	
1. jsp演变历史
		1. 早期只有servlet，只能使用response输出标签数据，非常麻烦
		2. 后来又jsp，简化了Servlet的开发，如果过度使用jsp，在jsp中即写大量的java代码，又写html表，造成难以维护，难于分以协作
		3. 再后来，java的web开发，借鉴mvc开发模式，使得程序的设计更加合理性
```

### 08MVC详解

```
2. MVC：
		1. M：Model，模型。JavaBean
			* 完成具体的业务操作，如：查询数据库，封装对象
		2. V：View，视图。JSP
			* 展示数据
		3. C：Controller，控制器。Servlet
			* 获取用户的输入
			* 调用模型
			* 将数据交给视图进行展示


		* 优缺点：
			1. 优点：
				1. 耦合性低，方便维护，可以利于分工协作
				2. 重用性高

			2. 缺点：
				1. 使得项目架构变得复杂，对开发人员要求高
```

![MVC开发模式](C:/Users/Murphy/Pictures/MVC开发模式.bmp)

### 09EL_概述

```
EL表达式
	1. 概念：Expression Language 表达式语言
	2. 作用：替换和简化jsp页面中java代码的编写
	3. 语法：${表达式}
	4. 注意：
		* jsp默认支持el表达式的。如果要忽略el表达式
			1. 设置jsp中page指令中：isELIgnored="true" 忽略当前jsp页面中所有的el表达式
			2. \${表达式} ：忽略当前这个el表达式
```

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    ${3 > 4}
    \${3 > 4}
</body>
</html>

```

### 10EL运算符

```
1. 运算：
			* 运算符：
				1. 算数运算符： + - * /(div) %(mod)
				2. 比较运算符： > < >= <= == !=
				3. 逻辑运算符： &&(and) ||(or) !(not)
				4. 空运算符： empty
					* 功能：用于判断字符串、集合、数组对象是否为null或者长度是否为0
					* ${empty list}:判断字符串、集合、数组对象是否为null或者长度为0
					* ${not empty str}:表示判断字符串、集合、数组对象是否不为null 并且 长度>0
```

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    ${3 > 4}
    \${3 > 4}
<hr>

<h3>算数运算符</h3>
    ${3 + 4}<br>
    ${3 / 4}<br>
    ${3 div 4}<br>
    ${3 % 4}<br>
    ${3 mod 4}<br>

<h3>比较运算符</h3>
    ${3 == 4}<br>

<h3>逻辑运算符</h3>
    ${3 > 4 && 3 <4}<br>
    ${3 > 4 and 3 <4}<br>

</body>
</html>

```

### 11EL获取域中存储的值

```
2. 获取值
			1. el表达式只能从域对象中获取值
			2. 语法：
				1. ${域名称.键名}：从指定域中获取指定键的值
					* 域名称：
						1. pageScope		--> pageContext
						2. requestScope 	--> request
						3. sessionScope 	--> session
						4. applicationScope --> application（ServletContext）
					* 举例：在request域中存储了name=张三
					* 获取：${requestScope.name}

				2. ${键名}：表示依次从最小的域中查找是否有该键对应的值，直到找到为止。
				3. 获取对象、List集合、Map集合的值
					1. 对象：${域名称.键名.属性名}
						* 本质上会去调用对象的getter方法

					2. List集合：${域名称.键名[索引]}

					3. Map集合：
						* ${域名称.键名.key名称}
						* ${域名称.键名["key名称"]}
```

优化day16 login.jsp中的代码

```
优化前 <%=request.getAttribute("cc_error") == null ?"" :request.getAttribute("cc_error")%></div>
优化后 ${requestScope.cc_error}
```

```jsp
<%--
  Created by IntelliJ IDEA.
  User: Murphy
  Date: 2021-06-22
  Time: 15:55
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>获取域中的数据</title>
</head>
<body>
    <%
        //在域中存储数据
        session.setAttribute("name","李四");
        request.setAttribute("name","张三");
        session.setAttribute("age","23");
    %>
<h3>el取值</h3>
${requestScope.name}
${sessionScope.age}
${sessionScope.haha}

${name}
</body>
</html>

```

### 12EL获取域中存储的值对象值

```java
package cn.itcast.domain;

import java.text.SimpleDateFormat;
import java.util.Date;

public class User {
    private String name;
    private int age;
    private Date birthday;

    /**
     * 逻辑视图
     * @return
     */
    public String getBirStr(){

        if (birthday != null) {
            //1.格式化日期对象
            SimpleDateFormat sdf = new SimpleDateFormat("yyyy-mm-dd hh:mm:ss");
            //2.返回字符串即可
            return sdf.format(birthday);
        }else {
            return "";
        }
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public Date getBirthday() {
        return birthday;
    }

    public void setBirthday(Date birthday) {
        this.birthday = birthday;
    }
}

```

```jsp
<%@ page import="cn.itcast.domain.User" %>
<%@ page import="java.util.Date" %><%--
  Created by IntelliJ IDEA.
  User: Murphy
  Date: 2021-06-22
  Time: 16:19
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>获取数据</title>
</head>
<body>
    <%
        User user = new User();
        user.setName("张三");
        user.setAge(23);
        user.setBirthday(new Date());

        request.setAttribute("u",user);
    %>

<h3>获取对象中的值</h3>
${requestScope.u}

<%--
    通过的是对象的属性来获取
    setter或getter方法，去掉set或get再将剩余部分，首字母变为小写。
    setName -->Name --> name
--%>
    ${requestScope.u.name}
    ${u.age}
    ${u.birthday}<br>
    ${u.birthday.month}<br>

    ${u.birStr}<br>
</body>
</html>

```

### 13EL_获取域中存储的值_ist集合&Map集合值

```jsp
<%@ page import="cn.itcast.domain.User" %>
<%@ page import="java.util.*" %><%--
  Created by IntelliJ IDEA.
  User: Murphy
  Date: 2021-06-22
  Time: 16:19
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>获取数据</title>
</head>
<body>
    <%
        User user = new User();
        user.setName("张三");
        user.setAge(23);
        user.setBirthday(new Date());

        request.setAttribute("u",user);

        List list = new ArrayList();
        list.add("aaa");
        list.add("bbb");
        list.add(user);

        request.setAttribute("list",list);

        Map map = new HashMap();
        map.put("sname","李四");
        map.put("gender","男");
        map.put("user",user);

        request.setAttribute("map",map);
    %>

<h3>获取对象中的值</h3>
${requestScope.u}

<%--
    通过的是对象的属性来获取
    setter或getter方法，去掉set或get再将剩余部分，首字母变为小写。
    setName -->Name --> name
--%>
    ${requestScope.u.name}
    ${u.age}
    ${u.birthday}<br>
    ${u.birthday.month}<br>

    ${u.birStr}<br>

<h3>获取List的值</h3>
    ${list}<br>
    ${list[0]}<br>
    ${list[1]}<br>
    ${list[10]}<br><%--角标越界不会显示--%>

    ${list[2].name}<%--张三--%>

    <h3>获取map的值</h3>
    ${map.gender}<br><%--第一种写法 男--%>
    ${map["gender"]}<br><%--第二种写法，单引号双引号都可以 男--%>
    ${map.user.name}<br><%--张三--%>
    ${map["user"].name}<br><%--张三--%>
</body>
</html>

```

### 14EL_empty运算符&隐式对象pageContext

```
空运算符： empty
					* 功能：用于判断字符串、集合、数组对象是否为null或者长度是否为0
					* ${empty list}:判断字符串、集合、数组对象是否为null或者长度为0
					* ${not empty str}:表示判断字符串、集合、数组对象是否不为null 并且 长度>0
3. 隐式对象：
			* el表达式中有11个隐式对象
			* pageContext：
				* 获取jsp其他八个内置对象
					* ${pageContext.request.contextPath}：动态获取虚拟目录
```

![image-20210624164502510](C:/Users/Murphy/Pictures/image-20210624164502510.png)

### 15JSTL_概述

```
1. 概念：JavaServer Pages Tag Library  JSP标准标签库
		* 是由Apache组织提供的开源的免费的jsp标签		<标签>
2. 作用：用于简化和替换jsp页面上的java代码		

	3. 使用步骤：
		1. 导入jstl相关jar包
		2. 引入标签库：taglib指令：  <%@ taglib %>
		3. 使用标签
```

### 16JSTL_常用标签if_

```jsp
1. if:相当于java代码的if语句
			1. 属性：
	            * test 必须属性，接受boolean表达式
	                * 如果表达式为true，则显示if标签体内容，如果为false，则不显示标签体内容
	                * 一般情况下，test属性值会结合el表达式一起使用
       		 2. 注意：
	       		 * c:if标签没有else情况，想要else情况，则可以在定义一个c:if标签
2. choose:相当于java代码的switch语句
			1. 使用choose标签声明         			相当于switch声明
            2. 使用when标签做判断         			相当于case
            3. 使用otherwise标签做其他情况的声明    	相当于default

3. foreach:相当于java代码的for语句
```

```java
<%@ page import="java.util.ArrayList" %>
<%@ page import="java.util.List" %><%--
  Created by IntelliJ IDEA.
  User: Murphy
  Date: 2021-06-26
  Time: 14:49
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<html>
<head>
    <title>if标签</title>
</head>
<body>
    <%--
    c:if标签
        1.属性：
            test 必须属性，接收boolean表达式
            *如果为true，则显示if标签内容，如果为false，则不显示标签体内容

            *一般情况下，test属性值会结合el表达式一起使用

        2.注意：c：if标签没有else情况，想要else情况，则可以再定义一个c:if标签
    --%>
    <c:if test="true">
        <h1>我是真</h1>
    </c:if>
    <br>

    <%
        //判断request域中的一个list集合是否为空，如果不为null则显示遍历集合
        List list = new ArrayList();
        list.add("aaa");
        request.setAttribute("list",list);

        request.setAttribute("number",4);
    %>

    <c:if test="${not empty list}">
        遍历集合。。。
    </c:if>
    <br>
    <c:if test="${number%2 ==0}">
        ${number}为偶数
    </c:if>
</body>
</html>

```

### 17JSTL常用标签choose

```java
<%--
  Created by IntelliJ IDEA.
  User: Murphy
  Date: 2021-06-26
  Time: 15:09
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<html>
<head>
    <title>choose标签</title>
</head>
<body>
    <%--
    完成数字编号对应星期几案例
        1.域中存储-数字
        2.使用choose标签取出数字          相当于switch
        3.使用when标签做数字判断          相当于case
        4.otherwise标签做其他情况的声明   相当于default
    --%>

    <%
        request.setAttribute("number",5);
    %>

    <c:choose>
        <c:when test="${number == 1}">星期一</c:when>
        <c:when test="${number == 2}">星期二</c:when>
        <c:when test="${number == 3}">星期三</c:when>
        <c:when test="${number == 4}">星期四</c:when>
        <c:when test="${number == 5}">星期五</c:when>
        <c:when test="${number == 6}">星期六</c:when>
        <c:when test="${number == 7}">星期天</c:when>

        <c:otherwise>数字输入有误</c:otherwise>
    </c:choose>
</body>
</html>

```

### 18JSTL常用标签foreach

```java
<%@ page import="java.util.List" %>
<%@ page import="java.util.ArrayList" %><%--
  Created by IntelliJ IDEA.
  User: Murphy
  Date: 2021-06-26
  Time: 15:35
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<html>
<head>
    <title>foreach标签</title>
</head>
<body>
    <%--
        foreach相当于java代码的for语句
            1.完成重复的操作
                for(int i = 0;i < 10;i ++){

                }
                *属性：
                    begin：开始值
                    end：结束值
                    var：临时变量
                    step：步长
                    varStatus:循环状态对象
                        index:容器中元素的索引从0开始（用于遍历容器）
                        count:循环次数
            2.遍历容器
                List<User> list;
                for{User user: list}{

                }
                *属性：
                    items：容器对象
                    var：容器中元素的临时变量
                    varStatus:循环状态对象
                        index:容器中元素的索引从0开始（用于遍历容器）
                        count:循环次数
    --%>
    <c:forEach begin="1" end="10" var="i" step="2" varStatus="s">
        ${i}
        <h3>${s.index}</h3>
        <h4>${s.count}</h4><br>
    </c:forEach>

    <hr>
    <%
        List list = new ArrayList();
        list.add("aaa");
        list.add("bbb");
        list.add("ccc");

        request.setAttribute("list",list);
    %>

    <c:forEach items="${list}" var="str" varStatus="s">
        ${s.index} ${s.count}${str}<br>
    </c:forEach>
</body>
</html>

```

### 19JSTL练习

```
5. 练习：
		* 需求：在request域中有一个存有User对象的List集合。需要使用jstl+el将list集合数据展示到jsp页面的表格table中

```

```java
package cn.itcast.domain;

import java.text.SimpleDateFormat;
import java.util.Date;

public class User {
    private String name;
    private int age;
    private Date birthday;

    public User(String name, int age, Date birthday) {
        this.name = name;
        this.age = age;
        this.birthday = birthday;
    }

    public User() {
    }

    /**
     * 逻辑视图
     * @return
     */
    public String getBirStr(){

        if (birthday != null) {
            //1.格式化日期对象
            SimpleDateFormat sdf = new SimpleDateFormat("yyyy-mm-dd hh:mm:ss");
            //2.返回字符串即可
            return sdf.format(birthday);
        }else {
            return "";
        }
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public Date getBirthday() {
        return birthday;
    }

    public void setBirthday(Date birthday) {
        this.birthday = birthday;
    }
}

```

```jsp
<%@ page import="java.util.ArrayList" %>
<%@ page import="java.util.List" %>
<%@ page import="cn.itcast.domain.User" %>
<%@ page import="java.util.Date" %><%--
  Created by IntelliJ IDEA.
  User: Murphy
  Date: 2021-06-26
  Time: 17:45
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<html>
<head>
    <title>test</title>
</head>
<body>
<%
    List list = new ArrayList();
    list.add(new User("张三", 23, new Date()));
    list.add(new User("李四", 24, new Date()));
    list.add(new User("王五", 25, new Date()));
    request.setAttribute("list", list);
%>

<table border="1" width="500" align="center">
    <tr>
        <th>编号</th>
        <th>姓名</th>
        <th>年龄</th>
        <th>生日</th>
    </tr>
    <%--数据行--%>
    <c:forEach items="${list}" var="user" varStatus="s">
        <c:if test="${s.count%2 != 0}">
            <tr>
                <td>${s.count}</td>
                <td>${user.name}</td>
                <td>${user.age}</td>
                <td>${user.birStr}</td>
            </tr>
        </c:if>
        <c:if test="${s.count%2 == 0}">
            <tr bgcolor="#f0f8ff">
                <td>${s.count}</td>
                <td>${user.name}</td>
                <td>${user.age}</td>
                <td>${user.birStr}</td>
            </tr>
        </c:if>
    </c:forEach>
</table>
</body>
</html>

```

### 20三层架构

```
三层架构：软件设计架构
	1. 界面层(表示层)：用户看的得界面。用户可以通过界面上的组件和服务器进行交互
	2. 业务逻辑层：处理业务逻辑的。
	3. 数据访问层：操作数据存储文件。
```

![三层架构](C:/Users/Murphy/Pictures/三层架构.bmp)

### 21案例需求分析&设计

```java
用户信息列表展示
	1. 需求：用户信息的增删改查操作
	2. 设计：
		1. 技术选型：Servlet+JSP+MySQL+JDBCTempleat+Duird+BeanUtilS+tomcat
		2. 数据库设计：
			create database day17; -- 创建数据库
			use day17; 			   -- 使用数据库
			create table user(   -- 创建表
				id int primary key auto_increment,
				name varchar(20) not null,
				gender varchar(5),
				age int,
				address varchar(32),
				qq	varchar(20),
				email varchar(50)
			);

	3. 开发：
		1. 环境搭建
			1. 创建数据库环境
			2. 创建项目，导入需要的jar包

		2. 编码
	

	4. 测试
	5. 部署运维
```

22案例环境搭建

```

```

23案例_列表查询_分析

```

```

![列表查询分析](C:/Users/Murphy/Pictures/列表查询分析.bmp)

24案例_列表查询_代码实现

```
 案例day17_case 报错，The origin server did not find a current representation for the target resource or is not willing to disclose that one exists.
 已解决
 原因，不是路径错误
 是servelet依赖错误
 理论上应该只依赖tomcat，不必添加java EE6依赖，实际修改，添加jar包在lib目录，关掉tomcat依赖和java ee6依赖，源代码见总和练习
 
```

![image-20210629113503369](C:/Users/Murphy/Pictures/image-20210629113503369.png)

## 18_综合练习

### 01今日内容

```
 今日内容
	1. 综合练习
		1. 简单功能
			1. 列表查询
			2. 登录
			3. 添加
			4. 删除
			5. 修改
			
		2. 复杂功能
			1. 删除选中
			2. 分页查询
				* 好处：
					1. 减轻服务器内存的开销
					2. 提升用户体验
			3. 复杂条件查询




## 2. 登录
	1. 调整页面，加入验证码功能
	2. 代码实现
```

### 02_页面调整



### 03登录功能验证码显示

### 04登录功能代码实现

### 05添加功能分析

![3.添加功能](C:/Users/Murphy/Pictures/3.添加功能.bmp)

### 06添加功能实现



### 07_删除功能分析

![4.删除功能](C:/Users/Murphy/Pictures/4.删除功能-1625320136230.bmp)

### 08删除功能代码实现



### 09修改功能分析

![5.修改功能](C:/Users/Murphy/Pictures/5.修改功能.bmp)

### 10_修改功能_代码实现1用户信息回显

### 11_修改功能代码实现2用户修改

### 12删除选中功能分析

![6.删除选中功能](C:/Users/Murphy/Pictures/6.删除选中功能.bmp)

### 13删除选中功能代码实现获取选中条目id

### 14删除选中功能代码实现删除选中服务器代码编写

### 15删除选中功能代码实现删除选中细节处理

```
完善了没有选中的时候点，删除选中的时候的500问题，后来Service进行数组判空
```

### 16分页查询功能分析

![7.分页查询功能](C:/Users/Murphy/Pictures/7.分页查询功能.bmp)

### 17_分页查询功能代码实现分析具体步骤

![7_2.分页查询功能2](C:/Users/Murphy/Pictures/7_2.分页查询功能2.bmp)

### 18分页查询功能代码实现后台代码实现

### 19分页查询功能代码实现前台代码实现

### 20复杂条件查询功能分析

![复杂条件分页查询](C:/Users/Murphy/Pictures/复杂条件分页查询.bmp)

### 21_复杂条件查询功能代码实现1_总记录数统计

### 22复杂条件查询功能代码实现2每页数据条件查询

```
&name=${condition.name[0]}&address=${condition.address[0]}&email=$[condition.email[0]
把复杂查询条件也拼接到链接上
```



## 19_Filter&Listener

1今日内容

```
java web三大组件
1. Filter：过滤器（重点掌握）
2. Listener：监听器（了解）
3. Servlet 容器
```

### 2_Filter _概述

```
Filter：过滤器
	1. 概念：
		* 生活中的过滤器：净水器,空气净化器，土匪、
		* web中的过滤器：当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能。
		* 过滤器的作用：
			* 一般用于完成通用的操作。如：登录验证、统一编码处理、敏感字符过滤...
```

![1.Filter过滤器](C:/Users/Murphy/Pictures/1.Filter过滤器.bmp)

### 3_Filter_快速入门

```java
2. 快速入门：
		1. 步骤：
			1. 定义一个类，实现接口Filter
			2. 复写方法
			3. 配置拦截路径
				1. web.xml
				2. 注解
		2. 代码：
			@WebFilter("/*")//访问所有资源之前，都会执行该过滤器
			public class FilterDemo1 implements Filter {
			    @Override
			    public void init(FilterConfig filterConfig) throws ServletException {
			
			    }
			
			    @Override
			    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
			        System.out.println("filterDemo1被执行了....");
			
			
			        //放行
			        filterChain.doFilter(servletRequest,servletResponse);
			
			    }
			
			    @Override
			    public void destroy() {
			
			    }
			}
```

### 4_Filter细节_web.xml配置方式

```java
3. 过滤器细节：
		1. web.xml配置	
			<filter>
		        <filter-name>demo1</filter-name>
		        <filter-class>cn.itcast.web.filter.FilterDemo1</filter-class>
		    </filter>
		    <filter-mapping>
		        <filter-name>demo1</filter-name>
				<!-- 拦截路径 -->
		        <url-pattern>/*</url-pattern>
		    </filter-mapping>
```

### 5_Filter_细节_执行流程&生命周期

```
2. 过滤器执行流程
			1. 执行过滤器
			2. 执行放行后的资源
			3. 回来执行过滤器放行代码下边的代码
		3. 过滤器生命周期方法
			1. init:在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次。用于加载资源
			2. doFilter:每一次请求被拦截资源时，会执行。执行多次
			3. destroy:在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次。用于释放资源
```



```java
package cn.ircast.filter;

import javax.servlet.*;
import javax.servlet.annotation.WebFilter;
import java.io.IOException;

@WebFilter("/*")
public class FilterDemo3 implements Filter {
    /**
     * 每一次请求被拦截资源时，被执行，执行多次
     * @param req
     * @param resp
     * @param chain
     * @throws ServletException
     * @throws IOException
     */
    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException {
        System.out.println("doFilter...");
        chain.doFilter(req, resp);
    }

    /**
     * 在服务器启动后，就会创建Filter对象，然后调用init方法。只执行一次。用于加载资源
     * @param config
     * @throws ServletException
     */
    public void init(FilterConfig config) throws ServletException {
        System.out.println("init...");
    }

    /**
     * 在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次。用于释放资源
     */
    public void destroy() {
        System.out.printf("destory...");
    }

}

```

### 6Filter细节过津器拦截路径配置

```java
4. 过滤器配置详解
			* 拦截路径配置：
				1. 具体资源路径： /index.jsp   只有访问index.jsp资源时，过滤器才会被执行
				2. 拦截目录： /user/*	访问/user下的所有资源时，过滤器都会被执行
				3. 后缀名拦截： *.jsp		访问所有后缀名为jsp资源时，过滤器都会被执行
				4. 拦截所有资源：/*		访问所有资源时，过滤器都会被执行
                
```

```
package cn.ircast.filter;

import javax.servlet.*;
import java.io.IOException;

//@WebFilter("/index.jsp")
//@WebFilter("/user/*")
//@WebFilter("*.jsp")
public class FilterDemo4 implements Filter {

    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException {
        System.out.println("FilterDemo4...");
        chain.doFilter(req, resp);
    }

    public void init(FilterConfig config) throws ServletException {

    }

    public void destroy() {

    }

}

```

### 7_Filter_细节过滤器拦截方式配置

```
* 拦截方式配置：资源被访问的方式
				* 注解配置：
					* 设置dispatcherTypes属性
						1. REQUEST：默认值。浏览器直接请求资源
						2. FORWARD：转发访问资源
						3. INCLUDE：包含访问资源   了解
						4. ERROR：错误跳转资源   了解
						5. ASYNC：异步访问资源   了解，SYNC同步
				* web.xml配置
					* 设置<dispatcher></dispatcher>标签即可
```

转发访问

```java
package cn.ircast.servlet;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebServlet("/user/updateServlet")
public class ServletDemo2 extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        System.out.println("updateServlet...");

        //转发到index.jsp
        request.getRequestDispatcher("/index.jsp").forward(request, response);
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        this.doPost(request, response);
    }
}

```

注解配置

```java
package cn.ircast.filter;

import javax.servlet.*;
import javax.servlet.annotation.WebFilter;
import java.io.IOException;
//浏览器直接请求index.jsp资源时，改过滤器会被执行
//@WebFilter(value = "/index.jsp",dispatcherTypes = DispatcherType.REQUEST)
//只有转发访问index.jsp时，该过滤器才会被执行
//@WebFilter(value = "/index.jsp",dispatcherTypes = DispatcherType.FORWARD)

//浏览器直接发送请求index,jsp或者转发访问index.jsp时，该过滤器才会被执行
@WebFilter(value = "/index.jsp",dispatcherTypes = {DispatcherType.FORWARD,DispatcherType.REQUEST})
public class FilterDemo5 implements Filter {

    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException {
        System.out.println("filterDemo5");
        chain.doFilter(req, resp);
    }

    public void init(FilterConfig config) throws ServletException {

    }

    public void destroy() {

    }

}
```

web.xml配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"
         version="3.1">
    
        <filter>
            <filter-name>demo1</filter-name>
            <filter-class>cn.ircast.filter.filterDemo1</filter-class>
        </filter>
        <filter-mapping>
            <filter-name>demo1</filter-name>
            <url-pattern>/*</url-pattern>
            <dispatcher>REQUEST</dispatcher>
        </filter-mapping>
   
</web-app>
```

### 8_Filter_细节过滤器链（多个过滤器）

```java
5. 过滤器链(配置多个过滤器)
			* 执行顺序：如果有两个过滤器：过滤器1和过滤器2
				1. 过滤器1
				2. 过滤器2
				3. 资源执行
				4. 过滤器2
				5. 过滤器1 

			* 过滤器先后顺序问题：
				1. 注解配置：按照类名的字符串比较规则比较，值小的先执行
					* 如： AFilter 和 BFilter，AFilter就先执行了。
				2. web.xml配置： <filter-mapping>谁定义在上边，谁先执行
```



### 9 Filter案例1登录验证_分析

```
案例：
		1. 案例1_登录验证
			* 需求：
				1. 访问day17_case案例的资源。验证其是否登录
				2. 如果登录了，则直接放行。
				3. 如果没有登录，则跳转到登录页面，提示"您尚未登录，请先登录"。
 		
```

![  ](C:/Users/Murphy/Pictures/2.案例1_登录验证.bmp)

### 10 Filter案例1登录验证代码实现 

```

```



### 11_Filter_案例2过滤敏感词汇分析

```
2. 案例2_敏感词汇过滤
			* 需求：
				1. 对day17_case案例录入的数据进行敏感词汇过滤
				2. 敏感词汇参考《敏感词汇.txt》
				3. 如果是敏感词汇，替换为 *** 
				
				原理：在Filter和Servlet里的request对象是同一个 req

			

```

![3.过滤敏感词汇](C:/Users/Murphy/Pictures/3.过滤敏感词汇-1626768510362.bmp)



### 12动态代理1_基本实现步骤

```
* 分析：
				1. 对request对象进行增强。增强获取参数相关方法
				2. 放行。传递代理对象
* 增强对象的功能：
				* 设计模式：一些通用的解决固定问题的方式
				1. 装饰模式     （相比代理模式更加笨重）
				2. 代理模式
					* 概念：
						1. 真实对象：被代理的对象
						2. 代理对象： 
						3. 代理模式：代理对象代理真实对象，达到增强真实对象功能的目的
				 	* 实现方式：
					 	1. 静态代理：有一个类文件描述代理模式
					 	2. 动态代理：在内存中形成代理类
					 	* 实现步骤：
								1. 代理对象和真实对象实现相同的接口
								2. 代理对象 = Proxy.newProxyInstance();
								3. 使用代理对象调用方法。
								4. 增强方法
```

![4.代理](C:/Users/Murphy/Pictures/4.代理.bmp)

新建接口

```java
package cn.itcast.proxy;

public interface SaleComputer {
    public String sale(double money);

    public void show();
}

```

继承接口

```java
package cn.itcast.proxy;

/**
 * 真实类
 */
public class Lenovo implements SaleComputer{
    @Override
    public String sale(double money) {
        System.out.println("花了"+money+"元买了一台联想电脑");
        return "联想电脑";
    }

    @Override
    public void show() {
        System.out.println("展示电脑...");
    }
}

```

动态增强实现

```java
package cn.itcast.proxy;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class ProxyTest {
    public static void main(String[] args) {
        //1.创建真实对象
        Lenovo lenovo = new Lenovo();

        //2.动态代理增强lenovo对象
        /*
            三个参数：
            1.类加载器：真实对象.getClass().getClassLoader()
            2.接口数组：真实对象.getClass().getInterfaces()
            3.处理器：new InvocationHandler()
         */
        SaleComputer  proxy_lenovo =(SaleComputer) Proxy.newProxyInstance(lenovo.getClass().getClassLoader(), lenovo.getClass().getInterfaces(), new InvocationHandler() {
            /*代理逻辑编写的方法：代理对象调用的所有方法都会触发改方法执行
                参数:
                    1.proxy:代理对象
                    2.method：代理对象调用的方法，被封装为的对象
                    3.args：代理对象调用的方法执行史，传递的实际参数
             */
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                System.out.println("该方法执行了....");
                System.out.println(method.getName());
                System.out.println(args[0]);
                return null;
            }
        });
        //3.调用方法
        String copmuter = proxy_lenovo.sale(8000);
        System.out.println(copmuter);

        //proxy_lenovo.show();
    }
}

```

### 13动态代理2增强方法

```
* 增强方式：
	1. 增强参数列表
	2. 增强返回值类型
	3. 增强方法体执行逻辑
```

动态增强实现

```java
package cn.itcast.proxy;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class ProxyTest {

    public static void main(String[] args) {
        //1.创建真实对象
        Lenovo lenovo = new Lenovo();

        //2.动态代理增强lenovo对象
        /*
            三个参数：
                1. 类加载器：真实对象.getClass().getClassLoader()
                2. 接口数组：真实对象.getClass().getInterfaces()
                3. 处理器：new InvocationHandler()
         */
        SaleComputer proxy_lenovo = (SaleComputer) Proxy.newProxyInstance(lenovo.getClass().getClassLoader(), lenovo.getClass().getInterfaces(), new InvocationHandler() {

            /*
                代理逻辑编写的方法：代理对象调用的所有方法都会触发该方法执行
                    参数：
                        1. proxy:代理对象
                        2. method：代理对象调用的方法，被封装为的对象
                        3. args:代理对象调用的方法时，传递的实际参数
             */
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                /*System.out.println("该方法执行了....");
                System.out.println(method.getName());
                System.out.println(args[0]);


*/
                //判断是否是sale方法
                if(method.getName().equals("sale")){
                    //1.增强参数
                    double money = (double) args[0];
                    money = money * 0.85;
                    System.out.println("专车接你....");
                    //使用真实对象调用该方法
                    String obj = (String) method.invoke(lenovo, money);
                    System.out.println("免费送货...");
                    //2.增强返回值
                    return obj+"_鼠标垫";
                }else{
                    Object obj = method.invoke(lenovo, args);
                    return obj;
                }

            }
        });

        //3.调用方法

        String computer = proxy_lenovo.sale(8000);
        System.out.println(computer);

/*
        proxy_lenovo.show();
*/
    }
}

```

### 14 Fiter案例2过滤敏感词汇实现

```
分析：
				1. 对request对象进行增强。增强获取参数相关方法
				2. 放行。传递代理对象
```

```java
package cn.itcast.web.filter;

import javax.servlet.*;
import javax.servlet.annotation.WebFilter;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.util.ArrayList;
import java.util.List;

/**
 * 敏感词汇过滤器
 */
@WebFilter("/*")
public class SensitiveWordsFilter implements Filter {


    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException {
        //1.创建代理对象，增强getParameter方法

        ServletRequest proxy_req = (ServletRequest) Proxy.newProxyInstance(req.getClass().getClassLoader(), req.getClass().getInterfaces(), new InvocationHandler() {
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                //增强getParameter方法
                //判断是否是getParameter方法
                if(method.getName().equals("getParameter")){
                    //增强返回值
                    //获取返回值
                    String value = (String) method.invoke(req,args);
                    if(value != null){
                        for (String str : list) {
                            if(value.contains(str)){
                                value = value.replaceAll(str,"***");
                            }
                        }
                    }
                    
                    return  value;
                }

                //判断方法名是否是 getParameterMap

                //判断方法名是否是 getParameterValue

                return method.invoke(req,args);
            }
        });

        //2.放行
        chain.doFilter(proxy_req, resp);
    }
    private List<String> list = new ArrayList<String>();//敏感词汇集合
    public void init(FilterConfig config) throws ServletException {

        try{
            //1.获取文件真实路径
            ServletContext servletContext = config.getServletContext();
            String realPath = servletContext.getRealPath("/WEB-INF/classes/敏感词汇.txt");
            //2.读取文件
            BufferedReader br = new BufferedReader(new FileReader(realPath));
            //3.将文件的每一行数据添加到list中
            String line = null;
            while((line = br.readLine())!=null){
                list.add(line);
            }

            br.close();

            System.out.println(list);

        }catch (Exception e){
            e.printStackTrace();
        }

    }

    public void destroy() {
    }

}

```

测试

```java
package cn.itcast.web.servlet;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebServlet("/testServlet")
public class TestServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String name = request.getParameter("name");
        String msg = request.getParameter("msg");

        System.out.println(name+":"+msg);
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        this.doPost(request, response);
    }
}

```

### 15_Listener_概述

```
Listener：监听器
	* 概念：web的三大组件之一。
		* 事件监听机制
			* 事件	：一件事情
			* 事件源 ：事件发生的地方
			* 监听器 ：一个对象
			* 注册监听：将事件、事件源、监听器绑定在一起。 当事件源上发生某个事件后，执行监听器代码
```

### 16_Listener_ ServletContextListener使用

```java
* ServletContextListener:监听ServletContext对象的创建和销毁
		* 方法：
			* void contextDestroyed(ServletContextEvent sce) ：ServletContext对象被销毁之前会调用该方法
			* void contextInitialized(ServletContextEvent sce) ：ServletContext对象创建后会调用该方法
		* 步骤：
			1. 定义一个类，实现ServletContextListener接口
			2. 复写方法
			3. 配置
				1. web.xml
						<listener>
     					 <listener-class>cn.itcast.web.listener.ContextLoaderListener</listener-class>
   						</listener>

						* 指定初始化参数<context-param>
				2. 注解：
					* @WebListener

```

详见day19_Filter&Listener

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"
         version="3.1">
    <!-- <filter>
         <filter-name>demo1</filter-name>
         <filter-class>cn.itcast.web.filter.FilterDemo1</filter-class>
     </filter>
     <filter-mapping>
         <filter-name>demo1</filter-name>
         <url-pattern>/*</url-pattern>

     </filter-mapping>-->

    <!--
       配置监听器
    -->
    <!--<listener>
       <listener-class>cn.itcast.web.listener.ContextLoaderListener</listener-class>
    </listener>-->

    <!-- 指定初始化参数 -->
    <context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>/WEB-INF/classes/applicationContext.xml</param-value>
    </context-param>

</web-app>

```

```java
package cn.itcast.web.listener;

import javax.servlet.ServletContext;
import javax.servlet.ServletContextEvent;
import javax.servlet.ServletContextListener;
import javax.servlet.annotation.WebListener;
import java.io.FileInputStream;


@WebListener
public class ContextLoaderListener implements ServletContextListener {

    /**
     * 监听ServletContext对象创建的。ServletContext对象服务器启动后自动创建。
     *
     * 在服务器启动后自动调用
     * @param servletContextEvent
     */
    @Override
    public void contextInitialized(ServletContextEvent servletContextEvent) {
        //加载资源文件
        //1.获取ServletContext对象
        ServletContext servletContext = servletContextEvent.getServletContext();

        //2.加载资源文件
        String contextConfigLocation = servletContext.getInitParameter("contextConfigLocation");

        //3.获取真实路径
        String realPath = servletContext.getRealPath(contextConfigLocation);

        //4.加载进内存
        try{
            FileInputStream fis = new FileInputStream(realPath);
            System.out.println(fis);
        }catch (Exception e){
            e.printStackTrace();
        }
        System.out.println("ServletContext对象被创建了。。。");
    }

    /**
     * 在服务器关闭后，ServletContext对象被销毁。当服务器正常关闭后该方法被调用
     * @param servletContextEvent
     */
    @Override
    public void contextDestroyed(ServletContextEvent servletContextEvent) {
        System.out.println("ServletContext对象被销毁了。。。");
    }
}

```

## 20_JQuery基础-

### 内容

	1. JQuery 基础：
		1. 概念
		2. 快速入门
		3. JQuery对象和JS对象区别与转换
		4. 选择器
		5. DOM操作
		6. 案例




### JQuery 基础：

	1. 概念： 一个JavaScript框架。简化JS开发
		* jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨	是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优	化HTML文档操作、事件处理、动画设计和Ajax交互。
	
		* JavaScript框架：本质上就是一些js文件，封装了js的原生代码而已
	2. 快速入门
		1. 步骤：
			1. 下载JQuery
				* 目前jQuery有三个大版本：
					1.x：兼容ie678,使用最为广泛的，官方只做BUG维护，
						 功能不再新增。因此一般项目来说，使用1.x版本就可以了，
						 最终版本：1.12.4 (2016年5月20日)
					2.x：不兼容ie678，很少有人使用，官方只做BUG维护，
						 功能不再新增。如果不考虑兼容低版本的浏览器可以使用2.x，
						 最终版本：2.2.4 (2016年5月20日)
					3.x：不兼容ie678，只支持最新的浏览器。除非特殊要求，
						 一般不会使用3.x版本的，很多老的jQuery插件不支持这个版本。
						 目前该版本是官方主要更新维护的版本。最新版本：3.2.1（2017年3月20日）
				* jquery-xxx.js 与 jquery-xxx.min.js区别：
					1. jquery-xxx.js：开发版本。给程序员看的，有良好的缩进和注释。体积大一些
					2. jquery-xxx.min.js：生产版本。程序中使用，没有缩进。体积小一些。程序加载更快
	
			2. 导入JQuery的js文件：导入min.js文件
			3. 使用
				var div1 = $("#div1");
				alert(div1.html());


	3. JQuery对象和JS对象区别与转换
		1. JQuery对象在操作时，更加方便。
	    2. JQuery对象和js对象方法不通用的.
	    3. 两者相互转换
	        * jq -- > js : jq对象[索引] 或者 jq对象.get(索引)
	        * js -- > jq : $(js对象)


	4. 选择器：筛选具有相似特征的元素(标签)
	
		1. 基本操作学习：
			1. 事件绑定
				//1.获取b1按钮
	            $("#b1").click(function(){
	                alert("abc");
	            });
			2. 入口函数
				 $(function () {
		           
	   			 });
				 window.onload  和 $(function) 区别
	                 * window.onload 只能定义一次,如果定义多次，后边的会将前边的覆盖掉
	                 * $(function)可以定义多次的。
			3. 样式控制：css方法
				 // $("#div1").css("background-color","red");
	      		$("#div1").css("backgroundColor","pink");


		2. 分类
			1. 基本选择器
				1. 标签选择器（元素选择器）
					* 语法： $("html标签名") 获得所有匹配标签名称的元素
				2. id选择器 
					* 语法： $("#id的属性值") 获得与指定id属性值匹配的元素
				3. 类选择器
					* 语法： $(".class的属性值") 获得与指定的class属性值匹配的元素
				4. 并集选择器：
					* 语法： $("选择器1,选择器2....") 获取多个选择器选中的所有元素
			2. 层级选择器
				1. 后代选择器
					* 语法： $("A B ") 选择A元素内部的所有B元素		
				2. 子选择器
					* 语法： $("A > B") 选择A元素内部的所有B子元素
			3. 属性选择器
				1. 属性名称选择器 
					* 语法： $("A[属性名]") 包含指定属性的选择器
				2. 属性选择器
					* 语法： $("A[属性名='值']") 包含指定属性等于指定值的选择器
				3. 复合属性选择器
					* 语法： $("A[属性名='值'][]...") 包含多个属性条件的选择器
			4. 过滤选择器
				1. 首元素选择器 
					* 语法： :first 获得选择的元素中的第一个元素
				2. 尾元素选择器 
					* 语法： :last 获得选择的元素中的最后一个元素
				3. 非元素选择器
					* 语法： :not(selector) 不包括指定内容的元素
				4. 偶数选择器
					* 语法： :even 偶数，从 0 开始计数
				5. 奇数选择器
					* 语法： :odd 奇数，从 0 开始计数
				6. 等于索引选择器
					* 语法： :eq(index) 指定索引元素
				7. 大于索引选择器 
					* 语法： :gt(index) 大于指定索引元素
				8. 小于索引选择器 
					* 语法： :lt(index) 小于指定索引元素
				9. 标题选择器
					* 语法： :header 获得标题（h1~h6）元素，固定写法
			5. 表单过滤选择器
				1. 可用元素选择器 
					* 语法： :enabled 获得可用元素
				2. 不可用元素选择器 
					* 语法： :disabled 获得不可用元素
				3. 选中选择器 
					* 语法： :checked 获得单选/复选框选中的元素
				4. 选中选择器 
					* 语法： :selected 获得下拉框选中的元素
	
	5. DOM操作
		1. 内容操作
			1. html(): 获取/设置元素的标签体内容   <a><font>内容</font></a>  --> <font>内容</font>
			2. text(): 获取/设置元素的标签体纯文本内容   <a><font>内容</font></a> --> 内容
			3. val()： 获取/设置元素的value属性值
		2. 属性操作
			1. 通用属性操作
				1. attr(): 获取/设置元素的属性
				2. removeAttr():删除属性
				3. prop():获取/设置元素的属性
				4. removeProp():删除属性
	
				* attr和prop区别？
					1. 如果操作的是元素的固有属性，则建议使用prop
					2. 如果操作的是元素自定义的属性，则建议使用attr
			2. 对class属性操作
				1. addClass():添加class属性值
				2. removeClass():删除class属性值
				3. toggleClass():切换class属性
					* toggleClass("one"): 
						* 判断如果元素对象上存在class="one"，则将属性值one删除掉。  如果元素对象上不存在class="one"，则添加
				4. css():
		3. CRUD操作:
			1. append():父元素将子元素追加到末尾
				* 对象1.append(对象2): 将对象2添加到对象1元素内部，并且在末尾
			2. prepend():父元素将子元素追加到开头
				* 对象1.prepend(对象2):将对象2添加到对象1元素内部，并且在开头
			3. appendTo():
				* 对象1.appendTo(对象2):将对象1添加到对象2内部，并且在末尾
			4. prependTo()：
				* 对象1.prependTo(对象2):将对象1添加到对象2内部，并且在开头


			5. after():添加元素到元素后边
				* 对象1.after(对象2)： 将对象2添加到对象1后边。对象1和对象2是兄弟关系
			6. before():添加元素到元素前边
				* 对象1.before(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系
			7. insertAfter()
				* 对象1.insertAfter(对象2)：将对象2添加到对象1后边。对象1和对象2是兄弟关系
			8. insertBefore()
				* 对象1.insertBefore(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系
	
			9. remove():移除元素
				* 对象.remove():将对象删除掉
			10. empty():清空元素的所有后代元素。
				* 对象.empty():将对象的后代元素全部清空，但是保留当前对象以及其属性节点


	6. 案例

## 21_JQuery高级-

### 内容：

	1. JQuery 高级
		1. 动画
		2. 遍历
		3. 事件绑定
		4. 案例
		5. 插件

### JQuery 高级

	1. 动画
		1. 三种方式显示和隐藏元素
			1. 默认显示和隐藏方式
				1. show([speed,[easing],[fn]])
					1. 参数：
						1. speed：动画的速度。三个预定义的值("slow","normal", "fast")或表示动画时长的毫秒数值(如：1000)
						2. easing：用来指定切换效果，默认是"swing"，可用参数"linear"
							* swing：动画执行时效果是 先慢，中间快，最后又慢
							* linear：动画执行时速度是匀速的
						3. fn：在动画完成时执行的函数，每个元素执行一次。
	
				2. hide([speed,[easing],[fn]])
				3. toggle([speed],[easing],[fn])
			
			2. 滑动显示和隐藏方式
				1. slideDown([speed],[easing],[fn])
				2. slideUp([speed,[easing],[fn]])
				3. slideToggle([speed],[easing],[fn])
	
			3. 淡入淡出显示和隐藏方式
				1. fadeIn([speed],[easing],[fn])
				2. fadeOut([speed],[easing],[fn])
				3. fadeToggle([speed,[easing],[fn]])
	
	2. 遍历
		1. js的遍历方式
			* for(初始化值;循环结束条件;步长)
		2. jq的遍历方式
			1. jq对象.each(callback)
				1. 语法：
					jquery对象.each(function(index,element){});
						* index:就是元素在集合中的索引
						* element：就是集合中的每一个元素对象
	
						* this：集合中的每一个元素对象
				2. 回调函数返回值：
					* true:如果当前function返回为false，则结束循环(break)。
					* false:如果当前function返回为true，则结束本次循环，继续下次循环(continue)
			2. $.each(object, [callback])
			3. for..of: jquery 3.0 版本之后提供的方式
				for(元素对象 of 容器对象)
		
	3. 事件绑定
		1. jquery标准的绑定方式
			* jq对象.事件方法(回调函数)；
			* 注：如果调用事件方法，不传递回调函数，则会触发浏览器默认行为。
				* 表单对象.submit();//让表单提交
		2. on绑定事件/off解除绑定
			* jq对象.on("事件名称",回调函数)
			* jq对象.off("事件名称")
				* 如果off方法不传递任何参数，则将组件上的所有事件全部解绑
		3. 事件切换：toggle
			* jq对象.toggle(fn1,fn2...)
				* 当单击jq对象对应的组件后，会执行fn1.第二次点击会执行fn2.....
				
			* 注意：1.9版本 .toggle() 方法删除,jQuery Migrate（迁移）插件可以恢复此功能。
				 <script src="../js/jquery-migrate-1.0.0.js" type="text/javascript" charset="utf-8"></script>
	
	4. 案例
		1. 广告显示和隐藏
			<!DOCTYPE html>
			<html>
			<head>
			    <meta charset="UTF-8">
			    <title>广告的自动显示与隐藏</title>
			    <style>
			        #content{width:100%;height:500px;background:#999}
			    </style>
			
			    <!--引入jquery-->
			    <script type="text/javascript" src="../js/jquery-3.3.1.min.js"></script>
			    <script>
			        /*
			            需求：
			                1. 当页面加载完，3秒后。自动显示广告
			                2. 广告显示5秒后，自动消失。
			
			            分析：
			                1. 使用定时器来完成。setTimeout (执行一次定时器)
			                2. 分析发现JQuery的显示和隐藏动画效果其实就是控制display
			                3. 使用  show/hide方法来完成广告的显示
			         */
			
			        //入口函数，在页面加载完成之后，定义定时器，调用这两个方法
			        $(function () {
			           //定义定时器，调用adShow方法 3秒后执行一次
			           setTimeout(adShow,3000);
			           //定义定时器，调用adHide方法，8秒后执行一次
			            setTimeout(adHide,8000);
			        });
			        //显示广告
			        function adShow() {
			            //获取广告div，调用显示方法
			            $("#ad").show("slow");
			        }
			        //隐藏广告
			        function adHide() {
			            //获取广告div，调用隐藏方法
			            $("#ad").hide("slow");
			        }
			        			    </script>
				</head>
				<body>
				<!-- 整体的DIV -->
				<div>
				    <!-- 广告DIV -->
				    <div id="ad" style="display: none;">
				        <img style="width:100%" src="E:/2019JAVA/2019新版JAVA/Java新版/03_javaweb/day21_JQuery高级/img/adv.jpg" />
				    </div>

			    <!-- 下方正文部分 -->
			    <div id="content">
			        正文部分
			    </div>
			</div>
			</body>
			</html>


		2. 抽奖
			<!DOCTYPE html>
			<html>
			<head>
			    <meta charset="UTF-8">
			    <title>jquery案例之抽奖</title>
			    <script type="text/javascript" src="../js/jquery-3.3.1.min.js"></script>
			
			    <script language='javascript' type='text/javascript'>
			
			        /*
			            分析：
			                1. 给开始按钮绑定单击事件
			                    1.1 定义循环定时器
			                    1.2 切换小相框的src属性
			                        * 定义数组，存放图片资源路径
			                        * 生成随机数。数组索引


			                2. 给结束按钮绑定单击事件
			                    1.1 停止定时器
			                    1.2 给大相框设置src属性
			
			         */
			        var imgs = ["../img/man00.jpg",
			                    "../img/man01.jpg",
			                    "../img/man02.jpg",
			                    "../img/man03.jpg",
			                    "../img/man04.jpg",
			                    "../img/man05.jpg",
			                    "../img/man06.jpg",
			                    ];
			        var startId;//开始定时器的id
			        var index;//随机角标
			        $(function () {
			            //处理按钮是否可以使用的效果
			            $("#startID").prop("disabled",false);
			            $("#stopID").prop("disabled",true);


			           //1. 给开始按钮绑定单击事件
			            $("#startID").click(function () {
			                // 1.1 定义循环定时器 20毫秒执行一次
			                startId = setInterval(function () {
			                    //处理按钮是否可以使用的效果
			                    $("#startID").prop("disabled",true);
			                    $("#stopID").prop("disabled",false);


			                    //1.2生成随机角标 0-6
			                    index = Math.floor(Math.random() * 7);//0.000--0.999 --> * 7 --> 0.0-----6.9999
			                    //1.3设置小相框的src属性
			                    $("#img1ID").prop("src",imgs[index]);
			
			                },20);
			            });


			            //2. 给结束按钮绑定单击事件
			            $("#stopID").click(function () {
			                //处理按钮是否可以使用的效果
			                $("#startID").prop("disabled",false);
			                $("#stopID").prop("disabled",true);


			               // 1.1 停止定时器
			                clearInterval(startId);
			               // 1.2 给大相框设置src属性
			                $("#img2ID").prop("src",imgs[index]).hide();
			                //显示1秒之后
			                $("#img2ID").show(1000);
			            });
			        });			

			</script>
			</head>
			<body>
			
			<!-- 小像框 -->
			<div style="border-style:dotted;width:160px;height:100px">
			    <img id="img1ID" src="../img/man00.jpg" style="width:160px;height:100px"/>
			</div>
			
			<!-- 大像框 -->
			<div
			        style="border-style:double;width:800px;height:500px;position:absolute;left:500px;top:10px">
			    <img id="img2ID" src="../img/man00.jpg" width="800px" height="500px"/>
			</div>
			
			<!-- 开始按钮 -->
			<input
			        id="startID"
			        type="button"
			        value="点击开始"
			        style="width:150px;height:150px;font-size:22px">
			
			<!-- 停止按钮 -->
			<input
			        id="stopID"
			        type="button"
			        value="点击停止"
			        style="width:150px;height:150px;font-size:22px">
			      </body>
			</html>


	5. 插件：增强JQuery的功能
		1. 实现方式：
			1. $.fn.extend(object) 
				* 增强通过Jquery获取的对象的功能  $("#id")
			2. $.extend(object)
				* 增强JQeury对象自身的功能  $/jQuery

## 22_Ajax-&Json

### AJAX：

	1. 概念： ASynchronous JavaScript And XML	异步的JavaScript 和 XML
		1. 异步和同步：客户端和服务器端相互通信的基础上
			* 客户端必须等待服务器端的响应。在等待的期间客户端不能做其他操作。
			* 客户端不需要等待服务器端的响应。在服务器处理请求的过程中，客户端可以进行其他的操作。
	
			Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 [1] 
			通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。
			传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。
			提升用户的体验
	
	2. 实现方式：
		1. 原生的JS实现方式（了解）
					 //1.创建核心对象
		            var xmlhttp;
		            if (window.XMLHttpRequest)
		            {// code for IE7+, Firefox, Chrome, Opera, Safari
		                xmlhttp=new XMLHttpRequest();
		            }
		            else
		            {// code for IE6, IE5
		                xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
		            }
		
		            //2. 建立连接
		            /*
		                参数：
		                    1. 请求方式：GET、POST
		                        * get方式，请求参数在URL后边拼接。send方法为空参
		                        * post方式，请求参数在send方法中定义
		                    2. 请求的URL：
		                    3. 同步或异步请求：true（异步）或 false（同步）
		
		             */
		            xmlhttp.open("GET","ajaxServlet?username=tom",true);
		
		            //3.发送请求
		            xmlhttp.send();
		
		            //4.接受并处理来自服务器的响应结果
		            //获取方式 ：xmlhttp.responseText
		            //什么时候获取？当服务器响应成功后再获取
		
		            //当xmlhttp对象的就绪状态改变时，触发事件onreadystatechange。
		            xmlhttp.onreadystatechange=function()
		            {
		                //判断readyState就绪状态是否为4，判断status响应状态码是否为200
		                if (xmlhttp.readyState==4 && xmlhttp.status==200)
		                {
		                   //获取服务器的响应结果
		                    var responseText = xmlhttp.responseText;
		                    alert(responseText);
		                }
		            }
		2. JQeury实现方式
			1. $.ajax()
				* 语法：$.ajax({键值对});
				 //使用$.ajax()发送异步请求
		            $.ajax({
		                url:"ajaxServlet1111" , // 请求路径
		                type:"POST" , //请求方式
		                //data: "username=jack&age=23",//请求参数
		                data:{"username":"jack","age":23},
		                success:function (data) {
		                    alert(data);
		                },//响应成功后的回调函数
		                error:function () {
		                    alert("出错啦...")
		                },//表示如果请求响应出现错误，会执行的回调函数
		
		                dataType:"text"//设置接受到的响应数据的格式
		            });
			2. $.get()：发送get请求
				* 语法：$.get(url, [data], [callback], [type])
					* 参数：
						* url：请求路径
						* data：请求参数
						* callback：回调函数
						* type：响应结果的类型
	
			3. $.post()：发送post请求
				* 语法：$.post(url, [data], [callback], [type])
					* 参数：
						* url：请求路径
						* data：请求参数
						* callback：回调函数
						* type：响应结果的类型

### 08JSON概念

```
JSON：
	1. 概念： JavaScript Object Notation		JavaScript对象表示法
		Person p = new Person();
		p.setName("张三");
		p.setAge(23);
		p.setGender("男");

		var p = {"name":"张三","age":23,"gender":"男"};

		* json现在多用于存储和交换文本信息的语法
		* 进行数据的传输
		* JSON 比 XML 更小、更快，更易解析。
```

### 09_JSON语法定义

```
2. 语法：
		1. 基本规则
			* 数据在名称/值对中：json数据是由键值对构成的
				* 键用引号(单双都行)引起来，也可以不使用引号
				* 值得取值类型：
					1. 数字（整数或浮点数）
					2. 字符串（在双引号中）
					3. 逻辑值（true 或 false）
					4. 数组（在方括号中）	{"persons":[{},{}]}
					5. 对象（在花括号中） {"address":{"province"："陕西"....}}
					6. null
			* 数据由逗号分隔：多个键值对由逗号分隔
			* 花括号保存对象：使用{}定义json 格式
			* 方括号保存数组：[]
```

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script>
        <!--1.定义基本格式-->
        var person = {"name": "张三", age: 23, 'gender': true};
        // alert(person);
        //2.嵌套格式    ()->[]
        var persons = {
            "persons": [{"name": "张三", "age": 23, "gender": true},
                        {"name": "李四", "age": 24, "gender": true},
                        {"name": "王五", "age": 25, "gender": false}
                        ]
                     };

        // alert(persons);

        //2.嵌套格式    []->()
        var ps = [{"name": "张三", "age": 23, "gender": true},
                {"name": "李四", "age": 24, "gender": true},
                {"name": "王五", "age": 25, "gender": false}];

        alert(ps);
    </script>
</head>
<body>

</body>
</html>
```

### 10JSON语法值的获取

```
2. 获取数据:
			1. json对象.键名      注意键名不用引号
			2. json对象["键名"]   注意键名要引号
			3. 数组对象[索引]
			4. 遍历
					 //1.定义基本格式
			        var person = {"name": "张三", age: 23, 'gender': true};
			
			        var ps = [{"name": "张三", "age": 23, "gender": true},
			            {"name": "李四", "age": 24, "gender": true},
			            {"name": "王五", "age": 25, "gender": false}];
			
			
			
			
			        //获取person对象中所有的键和值
			        //for in 循环
			       /* for(var key in person){
			            //这样的方式获取不行。因为相当于  person."name"
			            //alert(key + ":" + person.key);
			            alert(key+":"+person[key]);
			        }*/
			
			       //获取ps中的所有值
			        for (var i = 0; i < ps.length; i++) {
			            var p = ps[i];
			            for(var key in p){
			                alert(key+":"+p[key]);
			            }
			        }
```

获取数据

```java
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script>
        <!--1.定义基本格式-->
        var person = {"name": "张三", age: 23, 'gender': true};

        // alert(person);

        //获取name的值
        //json对象.键名      注意键名不用引号
        // var name = person.name;

        // json对象["键名"]   注意键名要引号
        var name = person["name"];
        // alert(name);


        //2.嵌套格式    ()->[]
        var persons = {
            "persons": [{"name": "张三", "age": 23, "gender": true},
                        {"name": "李四", "age": 24, "gender": true},
                        {"name": "王五", "age": 25, "gender": false}
                        ]
                     };

        // alert(persons);

        //数组对象[索引]
        //获取王五值   persons是一个Json对象，，这个Json对象里面有个键"persons"对应的值是数组，数组里面角标2的值是王五
        var name1 = persons.persons[2].name;
        // alert(name1);//王五

        //2.嵌套格式    []->()
        var ps = [{"name": "张三", "age": 23, "gender": true},
                {"name": "李四", "age": 24, "gender": true},
                {"name": "王五", "age": 25, "gender": false}];

        // alert(ps);

        //数组对象[索引]
        //获取李四值
        alert(ps[1].name);//李四
    </script>
</head>
<body>

</body>
</html>
```

遍历

```java
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script>
        <!--1.定义基本格式-->
        var person = {"name": "张三", age: 23, 'gender': true};


        var ps = [{"name": "张三", "age": 23, "gender": true},
            {"name": "李四", "age": 24, "gender": true},
            {"name": "王五", "age": 25, "gender": false}];


        //获取person对象中所有的键和值
        /*for (var key in person) {
            //这样的方式获取不行，因为相当于 person."name"
            //alert(key+""+person.key);
            alert(key+":"+person[key]);
        }*/

        //获取ps中的所有值
        for (let i = 0; i < ps.length; i++) {
            var p = ps[i];
            for (var key in p) {
                alert(key + ":" + p[key]);
            }
        }
    </script>
</head>
<body>

</body>
</html>
```

### 11JSON解析器Jacksonjava对象转json

```
3. JSON数据和Java对象的相互转换

		* JSON解析器：
			* 常见的解析器：Jsonlib，Gson，fastjson，jackson
		
		1. JSON转为Java对象
			1. 导入jackson的相关jar包
			2. 创建Jackson核心对象 ObjectMapper
			3. 调用ObjectMapper的相关方法进行转换
				1. readValue(json字符串数据,Class)
		2. Java对象转换JSON
			1. 使用步骤：
				1. 导入jackson的相关jar包
				2. 创建Jackson核心对象 ObjectMapper
				3. 调用ObjectMapper的相关方法进行转换
					1. 转换方法：
						* writeValue(参数1，obj):
		                    参数1：
		                        File：将obj对象转换为JSON字符串，并保存到指定的文件中
		                        Writer：将obj对象转换为JSON字符串，并将json数据填充到字符输出流中
		                        OutputStream：将obj对象转换为JSON字符串，并将json数据填充到字节输出流中
		                * writeValueAsString(obj):将对象转为json字符串

					2. 注解：
						1. @JsonIgnore：排除属性。
						2. @JsonFormat：属性值得格式化
							* @JsonFormat(pattern = "yyyy-MM-dd")

					3. 复杂java对象转换
						1. List：数组
						2. Map：对象格式一致
```

![JSON](C:/Users/Murphy/Pictures/JSON.bmp)



创建对象

```java
package cn.itcast.domain;

public class Person {
    private String name;
    private int age;
    private String gender;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getGender() {
        return gender;
    }

    public void setGender(String gender) {
        this.gender = gender;
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", gender='" + gender + '\'' +
                '}';
    }
}

```

Java对象转为JSON字符串

```java
package cn.itcast.test;

import cn.itcast.domain.Person;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.Test;

import java.io.FileWriter;

public class JacksonTest {
    //Java对象转为JSON字符串

    @Test
    public void test1() throws Exception {
        //1.创建Person对象
        Person p = new Person();
        p.setName("张三");
        p.setAge(23);
        p.setGender("男");
        //2.创建Jackson的核心对象，ObjectMapper
        ObjectMapper mapper = new ObjectMapper();
        //3.转换
        /**
                 * 转换方法：
                 *     writeValue(参数1, obj)
                 *       参数1：
                 * 		      File：将obj对象转换为JSON字符串，并保存到指定的文件中
                 * 		      Writer：将obj对象转换为JSON字符串，并将json数据填充到字符输出流中
                 * 		      OutputStream：将obj对象转换为JSON字符串，并将json数据填充到字节输出流中
                 * 		* writeValueAsString(obj):将对象转为json字符串
         */
        String json = mapper.writeValueAsString(p);
        //{"name":"张三","age":23,"gender":"男"}
        //System.out.println(json);//{"name":"张三","age":23,"gender":"男"}

        //writeValue，将数据写到d://a.txt中文件
        //mapper.writeValue(new File("d://a.txt"),p);
        
        //FileWriter将数据关联到writer中
        mapper.writeValue(new FileWriter("d://b.txt"),p);
    }

}

```

### 12JSON解析器Jacksonjava对象转json注解

```
2. 注解：
						1. @JsonIgnore：排除属性。
						2. @JsonFormat：属性值得格式化
							* @JsonFormat(pattern = "yyyy-MM-dd")
```

在对象的属性上添加注解

```java
package cn.itcast.domain;

import com.fasterxml.jackson.annotation.JsonFormat;

import java.util.Date;

public class Person {
    private String name;
    private int age;
    private String gender;

    //@JsonIgnore                             //忽略该属性   {"name":"张三","age":23,"gender":"男"}
    @JsonFormat(pattern = "yyyy-MM-dd")       //{"name":"张三","age":23,"gender":"男","birthday":"2021-07-22"}
    private Date birthday;

    public Date getBirthday() {
        return birthday;
    }

    public void setBirthday(Date birthday) {
        this.birthday = birthday;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getGender() {
        return gender;
    }

    public void setGender(String gender) {
        this.gender = gender;
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", gender='" + gender + '\'' +
                '}';
    }
}

```

```java
package cn.itcast.test;

import cn.itcast.domain.Person;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.Test;

import java.io.FileWriter;
import java.util.Date;

public class JacksonTest {
    //Java对象转为JSON字符串
        @Test
    public void  test2() throws Exception {
        //1.创建Person对象
        Person p = new Person();
        p.setName("张三");
        p.setAge(23);
        p.setGender("男");
        p.setBirthday(new Date());

        //2.转换
        ObjectMapper mapper = new ObjectMapper();
        String json = mapper.writeValueAsString(p);
        System.out.println(json);//{"name":"张三","age":23,"gender":"男","birthday":1626964528897}
    }
}

```

### 13_JSON_解析器Jacksonjava对象转json_List&Map

```
3. 复杂java对象转换
						1. List：数组
						2. Map：对象格式一致
```

```java
package cn.itcast.test;

import cn.itcast.domain.Person;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.Test;

import java.io.FileWriter;
import java.util.Date;

public class JacksonTest {
    @Test
    public void  test3() throws Exception {
        //1.创建Person对象
        Person p = new Person();
        p.setName("张三");
        p.setAge(23);
        p.setGender("男");
        p.setBirthday(new Date());

        Person p1 = new Person();
        p1.setName("张三");
        p1.setAge(23);
        p1.setGender("男");
        p1.setBirthday(new Date());

        Person p2 = new Person();
        p2.setName("张三");
        p2.setAge(23);
        p2.setGender("男");
        p2.setBirthday(new Date());

        //创建List集合
        List<Person> ps = new ArrayList<Person>();
        ps.add(p);
        ps.add(p1);
        ps.add(p2);

        //2.转换
        ObjectMapper mapper = new ObjectMapper();
        String json = mapper.writeValueAsString(ps);
        //[{},{},{}]
        System.out.println(json);//
    }

    @Test
    public void  test4() throws Exception {
        //1.创建Person对象
        Map<String, Object> map = new HashMap<>();
        map.put("name","张三");
        map.put("age",23);
        map.put("gender","男");

        //2.转换
        ObjectMapper mapper = new ObjectMapper();
        String json = mapper.writeValueAsString(map);
        System.out.println(json);//{"gender":"男","name":"张三","age":23}
    }
}
```

### 14JSON解析器Jacksonjson转Java对象

```
1. JSON转为Java对象
			1. 导入jackson的相关jar包
			2. 创建Jackson核心对象 ObjectMapper
			3. 调用ObjectMapper的相关方法进行转换
				1. readValue(json字符串数据,Class)
```

```java
//演示JSON字符串转为Java对象
    @Test
    public void  test5() throws Exception {
        //1.初始化JSON字符串
        String json = "{\"gender\":\"男\",\"name\":\"张三\",\"age\":23}";//转移符号自动将双引号转化了

        //2.创建ObjectMapper对象
        ObjectMapper mapper = new ObjectMapper();
        //3.转换为Java对象 Person对象
        Person person = mapper.readValue(json, Person.class);

        System.out.println(person);//Person{name='张三', age=23, gender='男'}
    }
```

### 15案例校验用户名是否存在

![image-20210723134330392](C:/Users/Murphy/Pictures/image-20210723134330392.png)

```
* 校验用户名是否存在
		1. 服务器响应的数据，在客户端使用时，要想当做json数据格式使用。有两种解决方案：
			1. $.get(type):将最后一个参数type指定为"json"
			2. 在服务器端设置MIME类型
				response.setContentType("application/json;charset=utf-8");
```

注册

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>注册页面</title>
    <script src="js/jquery-3.3.1.min.js"></script>


    <script>
        //在页面加载完成后
        $(function () {
            //给username绑定blur事件
            $("#username").blur(function () {
                //获取username文本输入框的值
                var username = $(this).val();
                //发送ajax请求
                //期望服务器响应回的数据格式：{"userExsit":true,"msg":"此用户名太受欢迎,请更换一个"}
                //                         {"userExsit":false,"msg":"用户名可用"}
                $.get("findUserServlet",{username:username},function (data) {
                    //判断userExsit键的值是否是true

                    // alert(data);
                    var span = $("#s_username");
                    if(data.userExsit){
                        //用户名存在
                        span.css("color","red");
                        span.html(data.msg);
                    }else{
                        //用户名不存在
                        span.css("color","green");
                        span.html(data.msg);
                    }
                },"json");

            });
        });

    </script>
</head>
<body>


<form>

    <input type="text" id="username" name="username" placeholder="请输入用户名">
    <span id="s_username"></span>
    <br>
    <input type="password" name="password" placeholder="请输入密码"><br>
    <input type="submit" value="注册"><br>

</form>

</body>
</html>
```

后台Servlet

```java
package cn.itcast.web.servlet;

import com.fasterxml.jackson.databind.ObjectMapper;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

@WebServlet("/findUserServlet")
public class FindUserServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //1.获取用户名
        String username = request.getParameter("username");

        //2.调用service层判断用户名是否存在

        //期望服务器响应回的数据格式：{"userExsit":true,"msg":"此用户名太受欢迎,请更换一个"}
        //                         {"userExsit":false,"msg":"用户名可用"}

        //设置响应的数据格式为json
        response.setContentType("application/json;charset=utf-8");
        Map<String,Object> map = new HashMap<String,Object>();

        if("tom".equals(username)){
            //存在
            map.put("userExsit",true);
            map.put("msg","此用户名太受欢迎,请更换一个");
        }else{
            //不存在
            map.put("userExsit",false);
            map.put("msg","用户名可用");
        }

        //将map转为json，并且传递给客户端
        //将map转为json
        ObjectMapper mapper = new ObjectMapper();
        //并且传递给客户端
        mapper.writeValue(response.getWriter(),map);


    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        this.doPost(request, response);
    }
}

```

## 23_redis-

### 内容

	1. redis
		1. 概念
		2. 下载安装
		3. 命令操作
			1. 数据结构
		4. 持久化操作
		5. 使用Java客户端操作redis

### Redis

	1. 概念： redis是一款高性能的NOSQL系列的非关系型数据库


		1.1.什么是NOSQL
			NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。
			随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。
	
			1.1.1.	NOSQL和关系型数据库比较
				优点：
					1）成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。
					2）查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。
					3）存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。
					4）扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。
	
				缺点：
					1）维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。
					2）不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。
					3）不提供关系型数据库对事务的处理。
	
			1.1.2.	非关系型数据库的优势：
				1）性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。
				2）可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。
	
			1.1.3.	关系型数据库的优势：
				1）复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。
				2）事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。
	
			1.1.4.	总结
				关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库，
				让NoSQL数据库对关系型数据库的不足进行弥补。
				一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据
	
		1.2.主流的NOSQL产品
			•	键值(Key-Value)存储数据库
					相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB
					典型应用： 内容缓存，主要用于处理大量数据的高访问负载。 
					数据模型： 一系列键值对
					优势： 快速查询
					劣势： 存储的数据缺少结构化
			•	列存储数据库
					相关产品：Cassandra, HBase, Riak
					典型应用：分布式的文件系统
					数据模型：以列簇式存储，将同一列数据存在一起
					优势：查找速度快，可扩展性强，更容易进行分布式扩展
					劣势：功能相对局限
			•	文档型数据库
					相关产品：CouchDB、MongoDB
					典型应用：Web应用（与Key-Value类似，Value是结构化的）
					数据模型： 一系列键值对
					优势：数据结构要求不严格
					劣势： 查询性能不高，而且缺乏统一的查询语法
			•	图形(Graph)数据库
					相关数据库：Neo4J、InfoGrid、Infinite Graph
					典型应用：社交网络
					数据模型：图结构
					优势：利用图结构相关算法。
					劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。
		1.3 什么是Redis
			Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下：
				1) 字符串类型 string
				2) 哈希类型 hash
				3) 列表类型 list
				4) 集合类型 set
				5) 有序集合类型 sortedset
			1.3.1 redis的应用场景
				•	缓存（数据查询、短连接、新闻内容、商品内容等等）
				•	聊天室的在线好友列表
				•	任务队列。（秒杀、抢购、12306等等）
				•	应用排行榜
				•	网站访问统计
				•	数据过期处理（可以精确到毫秒
				•	分布式集群架构中的session分离


	2. 下载安装
		1. 官网：https://redis.io
		2. 中文网：http://www.redis.net.cn/
		3. 解压直接可以使用：
			* redis.windows.conf：配置文件
			* redis-cli.exe：redis的客户端
			* redis-server.exe：redis服务器端
		
	3. 命令操作
		1. redis的数据结构：
			* redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构
				* value的数据结构：
					1) 字符串类型 string
					2) 哈希类型 hash ： map格式  
					3) 列表类型 list ： linkedlist格式。支持重复元素
					4) 集合类型 set  ： 不允许重复元素
					5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序
		
		2. 字符串类型 string
			1. 存储： set key value
				127.0.0.1:6379> set username zhangsan
				OK
			2. 获取： get key
				127.0.0.1:6379> get username
				"zhangsan"
			3. 删除： del key
				127.0.0.1:6379> del age
				(integer) 1
		3. 哈希类型 hash
			1. 存储： hset key field value
				127.0.0.1:6379> hset myhash username lisi
				(integer) 1
				127.0.0.1:6379> hset myhash password 123
				(integer) 1
			2. 获取： 
				* hget key field: 获取指定的field对应的值
					127.0.0.1:6379> hget myhash username
					"lisi"
				* hgetall key：获取所有的field和value
					127.0.0.1:6379> hgetall myhash
					1) "username"
					2) "lisi"
					3) "password"
					4) "123"
					
			3. 删除： hdel key field
				127.0.0.1:6379> hdel myhash username
				(integer) 1
		
		4. 列表类型 list:可以添加一个元素到列表的头部（左边）或者尾部（右边）
			1. 添加：
				1. lpush key value: 将元素加入列表左表
					
				2. rpush key value：将元素加入列表右边
					
					127.0.0.1:6379> lpush myList a
					(integer) 1
					127.0.0.1:6379> lpush myList b
					(integer) 2
					127.0.0.1:6379> rpush myList c
					(integer) 3
			2. 获取：
				* lrange key start end ：范围获取
					127.0.0.1:6379> lrange myList 0 -1
					1) "b"
					2) "a"
					3) "c"
			3. 删除：
				* lpop key： 删除列表最左边的元素，并将元素返回
				* rpop key： 删除列表最右边的元素，并将元素返回


		5. 集合类型 set ： 不允许重复元素
			1. 存储：sadd key value
				127.0.0.1:6379> sadd myset a
				(integer) 1
				127.0.0.1:6379> sadd myset a
				(integer) 0
			2. 获取：smembers key:获取set集合中所有元素
				127.0.0.1:6379> smembers myset
				1) "a"
			3. 删除：srem key value:删除set集合中的某个元素	
				127.0.0.1:6379> srem myset a
				(integer) 1
		6. 有序集合类型 sortedset：不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。
	
			1. 存储：zadd key score value
				127.0.0.1:6379> zadd mysort 60 zhangsan
				(integer) 1
				127.0.0.1:6379> zadd mysort 50 lisi
				(integer) 1
				127.0.0.1:6379> zadd mysort 80 wangwu
				(integer) 1
			2. 获取：zrange key start end [withscores]
				127.0.0.1:6379> zrange mysort 0 -1
				1) "lisi"
				2) "zhangsan"
				3) "wangwu"
	
				127.0.0.1:6379> zrange mysort 0 -1 withscores
				1) "zhangsan"
				2) "60"
				3) "wangwu"
				4) "80"
				5) "lisi"
				6) "500"
			3. 删除：zrem key value
				127.0.0.1:6379> zrem mysort lisi
				(integer) 1
	
		7. 通用命令
			1. keys * : 查询所有的键
			2. type key ： 获取键对应的value的类型
			3. del key：删除指定的key value


	4. 持久化
		1. redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。
		2. redis持久化机制：
			1. RDB：默认方式，不需要进行配置，默认就使用这种机制
				* 在一定的间隔时间中，检测key的变化情况，然后持久化数据
				1. 编辑redis.windwos.conf文件
					#   after 900 sec (15 min) if at least 1 key changed
					save 900 1
					#   after 300 sec (5 min) if at least 10 keys changed
					save 300 10
					#   after 60 sec if at least 10000 keys changed
					save 60 10000
					
				2. 重新启动redis服务器，并指定配置文件名称
					D:\JavaWeb2018\day23_redis\资料\redis\windows-64\redis-2.8.9>redis-server.exe redis.windows.conf	
				
			2. AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据
				1. 编辑redis.windwos.conf文件
					appendonly no（关闭aof） --> appendonly yes （开启aof）
					
					# appendfsync always ： 每一次操作都进行持久化
					appendfsync everysec ： 每隔一秒进行一次持久化
					# appendfsync no	 ： 不进行持久化
	
	5. Java客户端 Jedis
		* Jedis: 一款java操作redis数据库的工具.
		* 使用步骤：
			1. 下载jedis的jar包
			2. 使用
				//1. 获取连接
	    		Jedis jedis = new Jedis("localhost",6379);
	   			//2. 操作
	   			jedis.set("username","zhangsan");
	    		//3. 关闭连接
	    		jedis.close();


​		

		* Jedis操作各种redis中的数据结构
			1) 字符串类型 string
				set
				get
				
				 //1. 获取连接
		        Jedis jedis = new Jedis();//如果使用空参构造，默认值 "localhost",6379端口
		        //2. 操作
		        //存储
		        jedis.set("username","zhangsan");
		        //获取
		        String username = jedis.get("username");
		        System.out.println(username);
		
		        //可以使用setex()方法存储可以指定过期时间的 key value
		        jedis.setex("activecode",20,"hehe");//将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对
		
		        //3. 关闭连接
		        jedis.close();
	
			2) 哈希类型 hash ： map格式  
				hset
				hget
				hgetAll
				//1. 获取连接
		        Jedis jedis = new Jedis();//如果使用空参构造，默认值 "localhost",6379端口
		        //2. 操作
		        // 存储hash
		        jedis.hset("user","name","lisi");
		        jedis.hset("user","age","23");
		        jedis.hset("user","gender","female");
		
		        // 获取hash
		        String name = jedis.hget("user", "name");
		        System.out.println(name);


​		

		        // 获取hash的所有map中的数据
		        Map<String, String> user = jedis.hgetAll("user");
		
		        // keyset
		        Set<String> keySet = user.keySet();
		        for (String key : keySet) {
		            //获取value
		            String value = user.get(key);
		            System.out.println(key + ":" + value);
		        }
		
		        //3. 关闭连接
		        jedis.close();


			3) 列表类型 list ： linkedlist格式。支持重复元素
				lpush / rpush
				lpop / rpop
				lrange start end : 范围获取
				
				 //1. 获取连接
		        Jedis jedis = new Jedis();//如果使用空参构造，默认值 "localhost",6379端口
		        //2. 操作
		        // list 存储
		        jedis.lpush("mylist","a","b","c");//从左边存
		        jedis.rpush("mylist","a","b","c");//从右边存
		
		        // list 范围获取
		        List<String> mylist = jedis.lrange("mylist", 0, -1);
		        System.out.println(mylist);
		        
		        // list 弹出
		        String element1 = jedis.lpop("mylist");//c
		        System.out.println(element1);
		
		        String element2 = jedis.rpop("mylist");//c
		        System.out.println(element2);
		
		        // list 范围获取
		        List<String> mylist2 = jedis.lrange("mylist", 0, -1);
		        System.out.println(mylist2);
		
		        //3. 关闭连接
		        jedis.close();


			4) 集合类型 set  ： 不允许重复元素
				sadd
				smembers:获取所有元素
	
				//1. 获取连接
		        Jedis jedis = new Jedis();//如果使用空参构造，默认值 "localhost",6379端口
		        //2. 操作


​		

		        // set 存储
		        jedis.sadd("myset","java","php","c++");
		
		        // set 获取
		        Set<String> myset = jedis.smembers("myset");
		        System.out.println(myset);
		
		        //3. 关闭连接
		        jedis.close();
			5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序
				zadd
				zrange
	
				//1. 获取连接
		        Jedis jedis = new Jedis();//如果使用空参构造，默认值 "localhost",6379端口
		        //2. 操作
		        // sortedset 存储
		        jedis.zadd("mysortedset",3,"亚瑟");
		        jedis.zadd("mysortedset",30,"后裔");
		        jedis.zadd("mysortedset",55,"孙悟空");
		
		        // sortedset 获取
		        Set<String> mysortedset = jedis.zrange("mysortedset", 0, -1);
		
		        System.out.println(mysortedset);
		        //3. 关闭连接
		        jedis.close();

			        * jedis连接池： JedisPool
			* 使用：
				1. 创建JedisPool连接池对象
				2. 调用方法 getResource()方法获取Jedis连接
					//0.创建一个配置对象
			        JedisPoolConfig config = new JedisPoolConfig();
			        config.setMaxTotal(50);
			        config.setMaxIdle(10);
			
			        //1.创建Jedis连接池对象
			        JedisPool jedisPool = new JedisPool(config,"localhost",6379);
			
			        //2.获取连接
			        Jedis jedis = jedisPool.getResource();
			        //3. 使用
			        jedis.set("hehe","heihei");	
			        //4. 关闭 归还到连接池中
			        jedis.close();
			
			* 连接池工具类
				public class JedisPoolUtils {
	
				    private static JedisPool jedisPool;
				
				    static{
				        //读取配置文件
				        InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream("jedis.properties");
				        //创建Properties对象
				        Properties pro = new Properties();
				        //关联文件
				        try {
				            pro.load(is);
				        } catch (IOException e) {
				            e.printStackTrace();
				        }
				        //获取数据，设置到JedisPoolConfig中
				        JedisPoolConfig config = new JedisPoolConfig();
				        config.setMaxTotal(Integer.parseInt(pro.getProperty("maxTotal")));
				        config.setMaxIdle(Integer.parseInt(pro.getProperty("maxIdle")));
				
				        //初始化JedisPool
				        jedisPool = new JedisPool(config,pro.getProperty("host"),Integer.parseInt(pro.getProperty("port")));
				        }
				        			    /**
				     * 获取连接方法
				     */
				    public static Jedis getJedis(){
				        return jedisPool.getResource();
				    }
				}                        


### 案例：

	案例需求：
		1. 提供index.html页面，页面中有一个省份 下拉列表
		2. 当 页面加载完成后 发送ajax请求，加载所有省份


	* 注意：使用redis缓存一些不经常发生变化的数据。
		* 数据库的数据一旦发生改变，则需要更新缓存。
			* 数据库的表执行 增删改的相关操作，需要将redis缓存数据情况，再次存入
			* 在service对应的增删改方法中，将redis数据删除。

## 24_maven基础-

```
Maven是一个项目管理工具，它包含了一个项目对象模型 (POM：Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标(goal)的逻辑。
```

## 25_Linux-

## 26_Linux&Nginx-

### 1.学习目标

目标1：掌握Nginx的安装

目标2：掌握Nginx的静态网站部署

目标3：理解Nginx的反向代理与负载均衡，能够配置反向代理与负载均衡

### 2.Nginx的安装与启动

#### 2.1什么是Nginx

Nginx 是一款高性能的 http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。由俄罗斯的程序设计师伊戈尔·西索夫（Igor Sysoev）所开发，官方测试 nginx 能够支支撑 5 万并发链接，并且 cpu、内存等资源消耗却非常低，运行非常稳定。

​                               

**Nginx** **应用场景：**

1、http 服务器。Nginx 是一个 http 服务可以独立提供 http 服务。可以做网页静态服务器。

2、虚拟主机。可以实现在一台服务器虚拟出多个网站。例如个人网站使用的虚拟主机。

3、反向代理，负载均衡。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用 nginx 做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况。 

#### 2.2 Nginx在Linux下的安装

重新准备一台虚拟机作为服务器。比如IP地址为192.168.177.129 

##### 2.2.1环境准备

（1）需要安装 gcc 的环境【此步省略】

  yum install gcc-c++  

（2）第三方的开发包。

 **PCRE**

  PCRE(Perl Compatible Regular Expressions)是一个 Perl 库，包括 perl 兼容的正则表达式库。nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 linux 上安装 pcre 库。

  yum install -y pcre pcre-devel  

注：pcre-devel 是使用 pcre 开发的一个二次开发库。nginx 也需要此库。

 **zlib**

zlib 库提供了很多种压缩和解压缩的方式，nginx 使用 zlib 对 http 包的内容进行 gzip，所以需要在 linux 上安装 zlib 库。

  yum install -y zlib zlib-devel  

 **OpenSSL**

OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。nginx 不仅支持 http 协议，还支持 https（即在 ssl 协议上传输 http），所以需要在 linux安装 openssl 库。

  yum install -y openssl openssl-devel  

##### 2.2.2 Nginx下载

官方网站下载 nginx：http://nginx.org/

我们课程中使用的版本是 1.8.0 版本。

##### 2.2.3 Nginx安装

第一步：把 nginx 的源码包nginx-1.8.0.tar.gz上传到 linux 系统

第二步：解压缩

  tar zxvf nginx-1.8.0.tar.gz  

第三步：进入nginx-1.8.0目录  使用 configure 命令创建一 makeFile 文件。

  ./configure \  --prefix=/usr/local/nginx \  --pid-path=/var/run/nginx/nginx.pid \  --lock-path=/var/lock/nginx.lock \  --error-log-path=/var/log/nginx/error.log  \  --http-log-path=/var/log/nginx/access.log  \  --with-http_gzip_static_module \  --http-client-body-temp-path=/var/temp/nginx/client  \  --http-proxy-temp-path=/var/temp/nginx/proxy  \  --http-fastcgi-temp-path=/var/temp/nginx/fastcgi  \  --http-uwsgi-temp-path=/var/temp/nginx/uwsgi  \  --http-scgi-temp-path=/var/temp/nginx/scgi  

执行后可以看到Makefile文件

 

| **----** **知识点小贴士** **----**  Makefile是一种配置文件， Makefile 一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。 |
| ------------------------------------------------------------ |
| **----** **知识点小贴士** **----**  **configure****参数**  **./configure \**  **--prefix=/usr  \**                              **指向安装目录**  **--sbin-path=/usr/sbin/nginx  \**                  **指向（执行）程序文件（****nginx****）**  **--conf-path=/etc/nginx/nginx.conf  \**           **指向配置文件**  **--error-log-path=/var/log/nginx/error.log  \**         **指向****log**  **--http-log-path=/var/log/nginx/access.log  \**      **指向****http-log**  **--pid-path=/var/run/nginx/nginx.pid  \**             **指向****pid**  **--lock-path=/var/lock/nginx.lock  \**              **（安装文件锁定，防止安装文件被别人利用，或自己误操作。）**  **--user=nginx \**  **--group=nginx \**  **--with-http_ssl_module  \**             **启用****ngx_http_ssl_module****支持（使支持****https****请求，需已安装****openssl****）**  **--with-http_flv_module  \**             **启用****ngx_http_flv_module****支持（提供寻求内存使用基于时间的偏移量文件）**  **--with-http_stub_status_module  \**   **启用****ngx_http_stub_status_module****支持（获取****nginx****自上次启动以来的工作状态）**  **--with-http_gzip_static_module  \**  **启用****ngx_http_gzip_static_module****支持（在线实时压缩输出数据流）**  **--http-client-body-temp-path=/var/tmp/nginx/client/  \** **设定****http****客户端请求临时文件路径**  **--http-proxy-temp-path=/var/tmp/nginx/proxy/  \** **设定****http****代理临时文件路径**  **--http-fastcgi-temp-path=/var/tmp/nginx/fcgi/  \** **设定****http fastcgi****临时文件路径**  **--http-uwsgi-temp-path=/var/tmp/nginx/uwsgi  \** **设定****http uwsgi****临时文件路径**  **--http-scgi-temp-path=/var/tmp/nginx/scgi  \** **设定****http scgi****临时文件路径**  **--with-pcre** **启用****pcre****库** |

第四步：编译

  make  

第五步：安装

  make install  

#### 2.3 Nginx启动与访问

注意：启动nginx 之前，上边将临时文件目录指定为/var/temp/nginx/client， 需要在/var 下创建此 目录

  mkdir /var/temp/nginx/client -p  

进入到Nginx目录下的sbin目录

  cd /usr/local/ngiux/sbin  

输入命令启动Nginx

  ./nginx  

启动后查看进程

  ps aux|grep nginx  

 

 

地址栏输入虚拟机的IP即可访问（默认为80端口）

 

关闭 nginx：

  ./nginx -s stop  

或者

  ./nginx -s quit  

重启 nginx：

1、先关闭后启动。

2、刷新配置文件：

  ./nginx -s reload  

### 3.Nginx静态网站部署

#### 3.1 静态网站的部署

将/资料/静态页面/index目录下的所有内容 上传到服务器的/usr/local/nginx/html下即可访问

 

#### 3.2 配置虚拟主机

虚拟主机，也叫“网站空间”，就是把一台运行在互联网上的物理服务器划分成多个“虚拟”服务器。虚拟主机技术极大的促进了网络技术的应用和普及。同时虚拟主机的租用服务也成了网络时代的一种新型经济形式。

##### 3.2.1 端口绑定

（1）上传静态网站：

将/资料/静态页面/index目录上传至 /usr/local/nginx/index下

将/资料/静态页面/regist目录上传至 /usr/local/nginx/regist下

（2）修改Nginx 的配置文件：/usr/local/nginx/conf/nginx.conf

  server {      listen    81; # 监听的端口      server_name localhost; # 域名或ip      location / {   # 访问路径配置        root  index;# 根目录        index index.html index.htm; # 默认首页      }      error_page  500 502 503 504 /50x.html;   #  错误页面      location = /50x.html {        root  html;      }    }           server {      listen    82; # 监听的端口      server_name localhost; # 域名或ip      location / {   # 访问路径配置        root  regist;# 根目录        index regist.html; # 默认首页      }      error_page  500 502 503 504 /50x.html;   #  错误页面      location = /50x.html {        root  html;      }             }  

（3）访问测试：

地址栏输入http://192.168.177.129/:81 可以看到首页面

地址栏输入http://192.168.177.129/:82 可以看到注册页面

##### 3.2.2 域名绑定

**什么是域名：**

[域名](https://baike.baidu.com/item/域名)（[Domain Name](https://baike.baidu.com/item/Domain Name)），是由一串用“点”分隔的[字符](https://baike.baidu.com/item/字符)组成的Internet上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位（有时也指地理位置，地理上的域名，指代有行政自主权的一个地方区域）。域名是一个[IP地址](https://baike.baidu.com/item/IP地址)上有“面具” 。域名的目的是便于记忆和沟通的一组服务器的地址（[网站](https://baike.baidu.com/item/网站/155722)，电子邮件，[FTP](https://baike.baidu.com/item/FTP/13839)等）。域名作为力所能及难忘的互联网参与者的名称。域名按[域名系统](https://baike.baidu.com/item/域名系统)（DNS）的规则流程组成。在[DNS](https://baike.baidu.com/item/DNS/427444)中注册的任何名称都是域名。域名用于各种网络环境和应用程序特定的命名和寻址目的。通常，域名表示[互联网协议](https://baike.baidu.com/item/互联网协议)（IP）资源，例如用于访问因特网的个人计算机，托管网站的服务器计算机，或网站本身或通过因特网传送的任何其他服务。世界上第一个注册的域名是在1985年1月注册的。

**域名级别：**

**（****1****）顶级域名**

顶级域名又分为两类：

一是国家顶级域名（national top-level domainnames，简称nTLDs），200多个国家都按照ISO3166国家代码分配了顶级域名，例如中国是cn，美国是us，日本是jp等；

二是国际顶级域名（international top-level domain names，简称iTDs），例如表示工商企业的 .Com .Top，表示网络提供商的.net，表示非盈利组织的.org，表示教育的.edu，以及没有限制的中性域名如.xyz等。大多数域名争议都发生在com的顶级域名下，因为多数公司上网的目的都是为了赢利。但因为自2014年以来新顶级域名的发展，域名争议案件数量增长幅度越来越大[5] 。为加强域名管理，解决域名资源的紧张，Internet协会、Internet分址机构及世界知识产权组织（WIPO）等国际组织经过广泛协商， 在原来三个国际通用顶级域名：（com）的基础上，新增加了7个国际通用顶级域名：firm（公司企业）、store（销售公司或企业）、Web（突出WWW活动的单位）、arts（突出文化、娱乐活动的单位）、rec (突出消遣、娱乐活动的单位）、info(提供信息服务的单位）、nom(个人），并在世界范围内选择新的注册机构来受理域名注册申请。

例如：baidu.com

**（****2****）二级域名**

二级域名是指顶级域名之下的域名，在国际顶级域名下，它是指域名注册人的网上名称，例如 ibm，yahoo，microsoft等；在国家顶级域名下，它是表示注册企业类别的符号，例如.top，com，edu，gov，net等。

中国在国际互联网络信息中心（Inter NIC） 正式注册并运行的顶级域名是CN，这也是中国的一级域名。在顶级域名之下，中国的二级域名又分为类别域名和行政区域名两类。类别域名共7个， 包括用于科研机构的ac；用于工商金融企业的com、top；用于教育机构的edu；用于政府部门的 gov；用于互联网络信息中心和运行中心的net；用于非盈利组织的org。而行政区域名有34个，分别对应于中国各省、自治区和直辖市。

例如：map.baidu.com

**（****3****）三级域名**

三级域名用字母（ A～Z，a～z，大小写等）、数字（0～9）和连接符（－）组成， 各级域名之间用实点（.）连接，三级域名的长度不能超过20个字符。如无特殊原因，建议采用申请人的英文名（或者缩写）或者汉语拼音名 （或者缩写） 作为三级域名，以保持域名的清晰性和简洁性。

例如：

item.map.baidu.com

**域名与****IP****绑定：**

一个域名对应一个 ip 地址，一个 ip 地址可以被多个域名绑定。

本地测试可以修改 hosts 文件（C:\Windows\System32\drivers\etc）

可以配置域名和 ip 的映射关系，如果 hosts 文件中配置了域名和 ip 的对应关系，不需要走dns 服务器。

192.168.177.129   www.hmtravel.com

192.168.177.129   regist.hmtravel.com

 

做好域名指向后，修改nginx配置文件

​    server {      listen    80;      server_name www.hmtravel.com;      location / {        root  cart;        index cart.html;      }    }    server {       listen     80;      server_name regist.hmtravel.com;      location / {        root  search;        index search.html;      }    }  

执行以下命令，刷新配置

[root@localhost sbin]# ./nginx -s reload

 

测试：

地址栏输入http://www.hmtravel.com/

  

地址栏输入http://regist.hmtravel.com/

 

 

### 4.Nginx反向代理与负载均衡

#### 4.1 反向代理

##### 4.1.1 什么是反向代理

反向代理（Reverse Proxy）方式是指以[代理服务器](http://baike.baidu.com/item/代理服务器)来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。

首先我们先理解正向代理，如下图：

 

正向代理是针对你的客户端，而反向代理是针对服务器的，如下图

 

 

 

##### 4.1.2 配置反向代理-准备工作

（1） 将travel案例部署到tomcat中（ROOT目录），上传到服务器。

（2）启动TOMCAT，输入网址http://192.168.177.129:8080 可以看到网站首页

##### 4.1.3 配置反向代理

（1）在Nginx主机修改 Nginx配置文件

​    upstream tomcat-travel{         server 192.168.177.129:8080;    }       server {      listen    80; # 监听的端口      server_name www.hmtravel.com; # 域名或ip      location / {   # 访问路径配置        # root  index;# 根目录          proxy_pass http://tomcat-travel;        index index.html index.htm; # 默认首页      }  }  

（2）重新启动Nginx 然后用浏览器测试：http://www.hmtravel.com  （此域名须配置域名指向）

#### 4.2 负载均衡

##### 4.2.1 什么是负载均衡

负载均衡 建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展[网络设备](http://baike.baidu.com/item/网络设备)和[服务器](http://baike.baidu.com/item/服务器)的带宽、增加[吞吐量](http://baike.baidu.com/item/吞吐量)、加强网络数据处理能力、提高网络的灵活性和可用性。

负载均衡，英文名称为Load Balance，其意思就是分摊到多个操作单元上进行执行，例如Web[服务器](http://baike.baidu.com/item/服务器)、[FTP服务器](http://baike.baidu.com/item/FTP服务器)、[企业](http://baike.baidu.com/item/企业)关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。

##### 4.2.2 配置负载均衡-准备工作

（1）将刚才的存放工程的tomcat复制三份，修改端口分别为8080 ，8081，8082 。

（2）分别启动这三个tomcat服务。

（3）为了能够区分是访问哪个服务器的网站，可以在首页标题加上标记以便区分。

##### 4.2.3 配置负载均衡

修改 Nginx配置文件：

   upstream tomcat-travel {         server 192.168.177.129:8080;         server 192.168.177.129:8081;         server 192.168.177.129:8082;    }       server {      listen    80; # 监听的端口      server_name www.hmtravel.com; # 域名或ip      location / {   # 访问路径配置        # root  index;# 根目录          proxy_pass http://tomcat-travel;           index index.html index.htm; # 默认首页      }      error_page  500 502 503 504 /50x.html;   #  错误页面      location = /50x.html {        root  html;      }    }  

地址栏输入http:// www.hmtravel.com / 刷新观察每个网页的标题，看是否不同。

经过测试，三台服务器出现的概率各为33.3333333%，交替显示。

如果其中一台服务器性能比较好，想让其承担更多的压力，可以设置权重。

比如想让NO.1出现次数是其它服务器的2倍，则修改配置如下：

​    upstream tomcat-travel {         server 192.168.177.129:8080;         server 192.168.177.129:8081 weight=2;         server 192.168.177.129:8082;    }  

经过测试，每刷新四次，有两次是8081

# 框架

## 持久层(ORM)框架:Mybatis

### 第一部分

### 01_ mybatis课程介绍

```
第一天:mybatis入门
	  mybatis的概述
	  mybatis的环境搭建
	  mybatis入门案例
	  自定义mybatis框架（主要的目的是为了让大家了解mybatis中执行细节）
第二天:mybatis基本使用
	  mybatis的单表crud操作
	  mybatis的参数和返回值
	  mybatis的dao编写
	  mybatis配置的细节
	  		几个标签的使用
第三天:mybatis的深入和多表
	  mybatis的连接池
	  mybatis的事务控制及设计的方法
	  mybatis的多表查询
			一对多（多对一）
			多对多
第四天:mybatis的缓存和注解开发
      mybatis中的加载时机（查询的时机）
	  mybatis中的一级缓存和二级缓存
	  mybatis的注解开发
			单表CRUD
			多表查询
```

### 02三层架构和ssm框架的对应关系

```
三层架构
	表现层：是用于展示数据的
	业务层：是处理业务需求
	持久层：是和数据库交互的
```

![01三层架构](C:/Users/Murphy/Pictures/01三层架构.png)

### 03jdbc操作数据库的问题分析

```
持久层技术解决方案
JDBC技术：
	Connection
	PreparedStatement
	ResultSet
Spring的JdbcTemplate：
	Spring中对jdbc的简单封装
Apache的DBUtils：
	它和Spring的JdbcTemplate很像，也是对Jdbc的简单封装
以上这些都不是框架
	JDBC是规范
	Spring的JdbcTemplate和Apache的DBUtils都只是工具类
```

### 04_mybatis概述

```
	mybatis是一个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。 
	mybatis通过xml或注解的方式将要执行的各种statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射为java对象并返回。 
	采用ORM思想解决了实体和数据库映射的问题，对jdbc进行了封装，屏蔽了jdbc api底层访问细节，使我们不用与jdbc api打交道，就可以完成对数据库的持久化操作。 
	ORM：
		0bject Relational Mappging对象关系映射
	简单的说：
		就是把数据库表和实体类及实体类的属性对应起来
		让我们可以操作实体类就实现操作数据库表。
```

### 05 mybatis环境措建-前期准备

```xml
导入数据库
创建Maven工程
pom.xml导入依赖

<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.itheima</groupId>
    <artifactId>day01_esay_01mybaris</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>jar</packaging>     这里需要手动改为jar

    <dependencies>                 这个节点都是新增的
        <dependency>
            <groupId>org.mybatis</groupId>
            <artifactId>mybatis</artifactId>
            <version>3.4.5</version>
        </dependency>
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>5.1.6</version>
        </dependency>
        <dependency>
            <groupId>log4j</groupId>
            <artifactId>log4j</artifactId>
            <version>1.2.12</version>
        </dependency>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.10</version>
            <scope>test</scope>
        </dependency>
    </dependencies>
</project>
```

### 06_ mybatis的环境搭建

```
mybatis的入门
mybatis的环境搭建
	第一步：创建maven工程并导入坐标
	第二步：创建实体类和dao的接口
	第三步：创建Mybatis的主配置文件
			SqlMapConifg.xml
	第四步：创建映射配置文件
			IUserDao.xml
```

```
serialization 允许将实现了Serializable接口的对象转换为字节序列，这些字节序列可以被完全存储以备以后重新生成原来的对象。 
serialization不但可以在本机做，而且可以经由网络操作（就是猫小说的RMI）。这个好处是很大的----因为它自动屏蔽了操作系统的差异，字节顺序等。比如，在Window平台生成一个对象并序列化之，然后通过网络传到一台Unix机器上，然后可以在这台Unix机器上正确地重构这个对象。 
```

实体类

```java
package com.itheima.domain;

import java.io.Serializable;
import java.util.Date;

public class User implements Serializable {
    private Integer id;
    private String username;
    private Date birthday;
    private String sex;
    private String address;

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public Date getBirthday() {
        return birthday;
    }

    public void setBirthday(Date birthday) {
        this.birthday = birthday;
    }

    public String getSex() {
        return sex;
    }

    public void setSex(String sex) {
        this.sex = sex;
    }

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    @Override
    public String toString() {
        return "User{" +
                "id=" + id +
                ", username='" + username + '\'' +
                ", birthday=" + birthday +
                ", sex='" + sex + '\'' +
                ", address='" + address + '\'' +
                '}';
    }
}

```

创建dao接口

```java
package com.itheima.dao;

import com.itheima.domain.User;

import java.util.List;

/**
 * 用户的持久层接口
 */
public interface IUserDao {
    List<User> findAll();
}

```

创建Mybatis的主配置文件
			SqlMapConifg.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<!--mybatis的主配置文件-->
<configuration>
    <!--配置环境-->
    <environments default="mysql">
        <!--配置mysql的环境-->
        <environment id="mysql">
            <!--配置事务的类型-->
            <transactionManager type="JDBC"></transactionManager>
            <!--配置数据源（连接池）-->
            <dataSource type="POOLED">
                <!--配置链接数据库的4个基本信息-->
                <property name="driver" value="com.mysql.jdbc.Driver"/>
                <property name="url" value="jdbc:mysql://localhost:3306/eesy_mybatis"/>
                <property name="username" value="root"/>
                <property name="password" value="123456"/>
            </dataSource>
        </environment>
    </environments>

    <!--指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件-->
    <mappers>
        <mapper resource="com/itheima/dao/IUserDao.xml"/>
    </mappers>
</configuration>
```

第四步：创建映射配置文件
			IUserDao.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
 <mapper namespace="com.itheima.dao.IUserDao">
    <!--配置查询所有-->
    <select id="finAll">
        select * from user ;
    </select>
</mapper>
```

### 07环境搭建的注意事项

```
环境搭建的注意事项：
第一个：创建IUserDao.xml和IUserDao.java时名称是为了和我们之前的知识保持一致。
	在Mybatis中它把持久层的操作接口名称和映射文件也叫做：Mapper
	所以：IUserDao和IUserMapper是一样的
第二个：在idea中创建目录的时候，它和包是不一样的
	包在创建时：com.itheima.dao它是三级结构
	目录在创建时：com.itheima.dao是一级目录
第三个：mybatis的映射配置文件位置必须和dao接口的包结构相同
第四个：映射配置文件的mapper标签namespace属性的取值必须是dao接口的全限定类名
第五个：映射配置文件的操作配置（select），id属性的取值必须是dao接口的方法名

当我们遵从了第三，四，五点之后，我们在开发中就无须再写dao的实现类。
```

### 08_ mybatis的入门

```
mybatis的入案例
	第一步：读取配置文件
	第二步：创建SqlSessionFactory工厂
	第三步：创建SqlSession
	第四步：创建Dao接口的代理对象
	第五步：执行dao中的方法
	第六步：释放资源
	注意事项：
		不要忘记在映射配置中告知mybatis要封装到哪个实体类中
		配置的方式：指定实体类的全限定类名
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.itheima.dao.IUserDao">
    <!--配置查询所有-->
    <select id="findAll" resultType="com.itheima.domain.User">
        select * from user
    </select>
</mapper>
```

```java
package com.itheima;

import com.itheima.dao.IUserDao;
import com.itheima.domain.User;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.apache.log4j.lf5.util.Resource;

import java.io.IOException;
import java.io.InputStream;
import java.util.List;

/**
 * mybatis的入门案例
 */
public class MybatisTest {
    /**
     * 入门案例
     * @param args
     */
    public static void main(String[] args) throws IOException {
        //1.读取配置文件
        InputStream in = Resources.getResourceAsStream("SqlMapConfig.xml");
        //2.创建SqlSessionFactory工厂
        SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();
        SqlSessionFactory factory = builder.build(in);
        //3.使用工厂生产SqlSession对象
        SqlSession session = factory.openSession();
        //4.使用SqlSession创建Dao接口的代理对象
        IUserDao userDao = session.getMapper(IUserDao.class);
        //5.使用代理对象执行方法
        List<User> users = userDao.findAll();
        for (User user : users) {
            System.out.println(user);
        }
        //6.释放资源
        session.close();
        in.close();
    }
}

```

![04mybatis的分析](C:/Users/Murphy/Pictures/04mybatis的分析.png)

### 09_mybatis注解开发和编写dao实现类的方式

```
mybatis基于注解的入门案例：
	把IUserDao.xml移除，在dao接口的方法上使用@Select注解，并且指定SQL语句
	同时需要在SqlMapConfig.xml中的mapper配置时，使用class属性指定dao接口的全限定类名。
	明确我们在实际开发中，都是越简便越好，所以都是采用不写dao实现类的方式。
	不管使用xml还是注解配置
	但是MyBatis是支持写dao实现类
```

用注解就用不着单个类的xml，删除resources\com\itheima\dao\路径下的IUserDao.xml

直接在dao加注解

```java
package com.itheima.dao;

import com.itheima.domain.User;
import org.apache.ibatis.annotations.Select;

import java.util.List;

/**
 * 用户的持久层接口
 */

public interface IUserDao {
    @Select("select * from user")
    List<User> findAll();
}

```

修改resources目录下的SqlMapConfig.xml，此处只放了一个节点

```
 <!--指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件
        如果是用注解来配置的话，此处应该使用Class属性指定被注解的dao全限定类名
    -->
    <mappers>
        <mapper class="com.itheima.dao.IUserDao"/>
    </mappers>
```

### 10mybatis入门案例中的设计模式分析

```
绝对路径：假如放在D盘，没有D盘就会出问题                
相对路径：对象在SRC下，部署项目时没有SRC，就会出问题

第一个：使用类加载器。它只能读取类路径的配置文件
第二个：使用ServletContext对象的getRealPath()

工程模式，没有用到new去创建对象，降低了类之间的依赖，减少修改
```

![入门案例的分析](C:/Users/Murphy/Pictures/入门案例的分析.png)

### 11_自定义Mybatis的分析-执行查询所有分析

```
自定义Mybatis的分析：mybatis在使用代理dao的方式实现增删改查时做什么事呢？
只有两件事：
第一：创建代理对象
第二：在代理对象中调用selectList
```

![自定义Mybatis分析](C:/Users/Murphy/Pictures/自定义Mybatis分析.png)

### 12_自定义Mybatis的分析-创建代理对象的分析

```
与上一部分是同一个图
```

### 13_自定义mybatis的编码-根据测试类中缺少的创建接口和类

```
自定义项目详见  D:\IdeaProjects\day01_eesy_01mybatis_design
```

### 14自定义mybatis的编码-解析XML的工具类介绍



### 15_自定义Mybatis的编码-创建两个默认实现类并分析类之间的关系_



### _16_自定义Mybatis的编码-实现基于XML的查询所有操作



### 17自定义Mybatis的编码-实现基于注解配置的查询所有

### ----------------------

### 第二部分

### 01今日课程内容介绍

```
1、回顾mybatis的自定义再分析和环境搭建+完善基于注解的mybatis
2、mybatis的curd（基于代理dao的方式）
3、mybatis中的参数深入及结果集的深入
4、mybatis中基于传统dao的方式（编写dao的实现类）----了解的内容5、mybatis中的配置（主配置文件：SqlMapConfig.xml）
I properties标签
typeAliases标签
mappers标签
```

### 02回顾自定义mybatis的流程分析

```

```

![自定义mybatis开发流程图](C:/Users/Murphy/Pictures/自定义mybatis开发流程图.png)

### 03基于注解的自定义再分析



### 04回顾Mybatis的环境搭建-实现查询所有功能



### 05_ Mybatis的CRUD-保存操作

增加saveUser方法

```java
package com.itheima.dao;

import com.itheima.domain.User;
import org.apache.ibatis.annotations.Select;

import java.util.List;

/**
 * 用户的持久层接口
 */

public interface IUserDao {

    /**
     * 查询所有用户
     * @return
     */
    List<User> findAll();

    /**
     * 保存用户
      * @param user
     */
    void saveUser(User user);                     此处
}

```

增加配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.itheima.dao.IUserDao">
    <!--配置查询所有-->
    <select id="findAll" resultType="com.itheima.domain.User">
        select * from user;
    </select>

    <!--保存用户-->                              此处
    <insert id="saveUser" parameterType="com.itheima.domain.User">
        insert into user (username,address,sex,birthday)values(#{username},#{address},#{sex},#{birthday});
    </insert>
</mapper>
```

提高代码复用性，用@Before 和@After注解简化代码，再测试saveUser

```java
package com.itheima.test;

import com.itheima.dao.IUserDao;
import com.itheima.domain.User;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import java.io.InputStream;
import java.util.Date;
import java.util.List;

/**
 * 测试mybatis的crud操作
 */
public class MybatisTest {

    private InputStream in;
    private SqlSession sqlSession;
    private IUserDao userDao;

    @Before//用于在测试方法执行之前执行                         此处
    public void init() throws Exception{
        //1.读取配置文件
         in = Resources.getResourceAsStream("SqlMapConfig.xml");
        //2.创建SqlSessionFactory工厂
        SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in);
        //3.使用工厂生产SqlSession对象
        sqlSession = factory.openSession();
        //4.使用SqlSession创建Dao接口的代理对象
        userDao = sqlSession.getMapper(IUserDao.class);
    }

    @After//用于在测试方法执行之后执行                        此处
    public void destory() throws Exception{

        //提交事物                                        此处
        sqlSession.commit();

        //6.释放资源
        sqlSession.close();
        in.close();
    }

    /**
     * 测试查询所有
     */
    @Test
    public void testFindAll() throws Exception {

        //5.使用代理对象执行方法
        List<User> users = userDao.findAll();
        for(User user : users){
            System.out.println(user);
        }

    }

    /**
     * 测试保存操作                                        此处
     */
    @Test
    public void  testSave(){
        User user = new User();
        user.setUsername("mybatis saveuser");
        user.setAddress("北京市东城区");
        user.setSex("男");
        user.setBirthday(new Date());

        //5.使用保存方法
        userDao.saveUser(user);

    }
}

```

### 06 Mybatis的CRUD-修改和删除操作

增加updateUser方法、deleteUser方法

```java
package com.itheima.dao;

import com.itheima.domain.User;
import org.apache.ibatis.annotations.Select;

import java.util.List;

/**
 * 用户的持久层接口
 */

public interface IUserDao {

    /**
     *  更新用户                            此处
     */
    void updateUser(User user);

    /**
     * 根据id删除用户                        此处
     */
    void deleteUser(Integer userId);
}

```

增加配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.itheima.dao.IUserDao">
    <!--更新用户-->                         此处
    <update id="updateUser" parameterType="com.itheima.domain.User">
        update user set username=#{username},address=#{address},sex=#{sex},birthday=#{birthday} where id=#{id};
    </update>

    <!--删除用户-->                         此处
    <delete id="deleteUser" parameterType="java.lang.Integer">/* int Integer  java.lang.Integer 都可以   这里uid是占位符，可以随便写*/
        delete from user where id=#{uid};
    </delete>
</mapper>
```

测试类测试

```java
package com.itheima.test;

import com.itheima.dao.IUserDao;
import com.itheima.domain.User;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import java.io.InputStream;
import java.util.Date;
import java.util.List;

/**
 * 测试mybatis的crud操作
 */
public class MybatisTest {

    private InputStream in;
    private SqlSession sqlSession;
    private IUserDao userDao;

    @Before//用于在测试方法执行之前执行
    public void init() throws Exception{
        //1.读取配置文件
         in = Resources.getResourceAsStream("SqlMapConfig.xml");
        //2.创建SqlSessionFactory工厂
        SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in);
        //3.使用工厂生产SqlSession对象
        sqlSession = factory.openSession();
        //4.使用SqlSession创建Dao接口的代理对象
        userDao = sqlSession.getMapper(IUserDao.class);
    }

    @After//用于在测试方法执行之后执行
    public void destory() throws Exception{

        //提交事物
        sqlSession.commit();

        //6.释放资源
        sqlSession.close();
        in.close();
    }

    /**
     *测试更新操作                                               此处
     */
    @Test
    public void testUpdate(){
        User user = new User();
        user.setId(50);
        user.setUsername("mybatis updateuser");
        user.setAddress("北京市东城区");
        user.setSex("女");
        user.setBirthday(new Date());

        //5.使用保存方法
        userDao.updateUser(user);
    }

    /**
     *测试删除操作                                               此处
     */
    @Test
    public void testDelete(){
        //5.执行删除方法
        userDao.deleteUser(48);
    }
}

```

### 07 Mybatis的CRUD-查询一个和模糊查询

增加findById、findByName方法

```java
package com.itheima.dao;

import com.itheima.domain.User;
import org.apache.ibatis.annotations.Select;

import java.util.List;

/**
 * 用户的持久层接口
 */

public interface IUserDao {

    /**
     * 根据id查询用户                                    此处
     */
    User findById(Integer userId);

    /**
     * 根据名称，模糊查询用户信息                           此处
     */
    List<User> findByName(String username);
}

```

增加配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.itheima.dao.IUserDao">
 
    <!--根据id查询用户-->                                     此处
    <select id="findById" parameterType="INT" resultType="com.itheima.domain.User">
        select * from user where  id=#{uid}
    </select>

    <!--根据名称模糊查询-->                                    此处
    <select id="findByName" parameterType="string" resultType="com.itheima.domain.User">
        select * from user where username like #{name};
    </select>
</mapper>
```

测试类测试

```java
package com.itheima.test;

import com.itheima.dao.IUserDao;
import com.itheima.domain.User;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import java.io.InputStream;
import java.util.Date;
import java.util.List;

/**
 * 测试mybatis的crud操作
 */
public class MybatisTest {

    private InputStream in;
    private SqlSession sqlSession;
    private IUserDao userDao;

    @Before//用于在测试方法执行之前执行
    public void init() throws Exception{
        //1.读取配置文件
         in = Resources.getResourceAsStream("SqlMapConfig.xml");
        //2.创建SqlSessionFactory工厂
        SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in);
        //3.使用工厂生产SqlSession对象
        sqlSession = factory.openSession();
        //4.使用SqlSession创建Dao接口的代理对象
        userDao = sqlSession.getMapper(IUserDao.class);
    }

    @After//用于在测试方法执行之后执行
    public void destory() throws Exception{

        //提交事物
        sqlSession.commit();

        //6.释放资源
        sqlSession.close();
        in.close();
    }

    /**
     * 测试查询一个                                    此处
     */
    @Test
    public void testFindOne(){
        //5.执行删除方法
        User user = userDao.findById(50);
        System.out.println(user);
    }

    /**
     * 测试模糊查询操作									此处
     */
    @Test
    public void testFindByUserName(){
        //5.执行删除方法
        List<User> users = userDao.findByName("%王%");
        for (User user : users) {
            System.out.println(user);
        }
    }
}

```

### 08 Mybatis的CRUD-查询返回一行一列和占位符分析

查询总记录数

```java
 /**
     * 查询总用户数
     * @return
     */
    int findTotal();
```

配置

```xml
<!--获取用户的总记录条数-->
    <select id="findTotal" resultType="Int">
        select count(id) from user;
    </select>
```

测试类

```java
/**
     * 查询总记录条数
     */
    @Test
    public void testFindTotal(){
        //执行查询方法
        int count = userDao.findTotal();
        System.out.println(count);
    }
```

模糊查询另一种方式

配置

```xml
<!--根据名称模糊查询-->
    <select id="findByName" parameterType="string" resultType="com.itheima.domain.User">
        select * from user where username like '%${value}';               此处      固定写法，详见源码
    </select>
```

测试类

```java
/**
     * 测试模糊查询操作
     */
    @Test
    public void testFindByUserName(){
        //5.执行删除方法
        List<User> users = userDao.findByName("王");            此处
        for (User user : users) {
            System.out.println(user);
        }
    }
```

```
带有域处理，右侧更好     
```

![无标题](C:/Users/Murphy/Pictures/无标题.png)

### 09 Mybatis的CRUD-保存操作的细节-获取保存数据的id



```
查询插入的数据的id
select last_insert_id();
```

配置

```xml
<!--保存用户-->
    <insert id="saveUser" parameterType="com.itheima.domain.User">
        <!--配置插入操作后，获取插入数据的id    id的属性名称，对应实体类、id的列名，对应表、结果集类型、什么时候执行，插入后-->
        <selectKey keyProperty="id" keyColumn="id" resultType="int" order="AFTER">
            select last_insert_id();
        </selectKey>
        insert into user (username,address,sex,birthday)values(#{username},#{address},#{sex},#{birthday});
    </insert>
```

测试类

```java
 /**
     * 测试保存操作
     */
    @Test
    public void  testSave() {
        User user = new User();
        user.setUsername("mybatis last insertid");
        user.setAddress("北京市东城区");
        user.setSex("男");
        user.setBirthday(new Date());

        System.out.println("保存操作前" + user);

        //5.使用保存方法
        userDao.saveUser(user);

        System.out.println("保存操作后" + user);
    }
```

### 10_ Mybatis中参数的深入-使用实体类的包装对象作为查询条件

```
ONGL表达式：
	Object Graphic Navigation Language
	对象       图     导航         语言
	
	它是通过对象的取值方法来获取数据。在写法上把get省略了。
	比如：我们获取用户的名称
		类中的写法：user.getUser()
		ONGL表达式写法： user.username             可以继续打.调用
	MyBatis中为什么能直接写username，而不用user.呢
    因为在parameterType中已经提供了属性所属的类，所以此时不需要写对象名
```

创建对象（条件）

```java
package com.itheima.domain;

public class QueryVo {
    private User user;

    public User getUser() {
        return user;
    }

    public void setUser(User user) {
        this.user = user;
    }
}

```

IUserDao类中新增方法

```java
/**
     *根据QueryVo查询中的条件查询用户
     */
    List<User> findUserByVo(QueryVo vo);
```

IUserDao.xml新增配置

```xml
 <!--根据QueryVo的条件查询用户    ONGL表达式的一个用法-->
    <select id="findUserByVo" parameterType="com.itheima.domain.QueryVo" resultType="com.itheima.domain.User">
        select * from user where username like #{user.username};
    </select>
```

MybatisTest中新增测试类

```java
/**
     * 测试使用QueryVo作为查询条件查询用户
     */
    @Test
    public void testfindUserByVo(){
        QueryVo vo = new QueryVo();
        User user = new User();
        user.setUsername("%王%");
        vo.setUser(user);
        //执行一个查询方法
        List<User> users = userDao.findUserByVo(vo);
        for (User u : users) {
            System.out.println(u);
        }
    }
```

### 11 Mybatis中的返回值深入-调整实体类属性解决增和改方法的报错



### 12Mybatis中的返回值深入-解决实体类属性和数据库列名不对应的两种方式

类属性改变后

第一种方式起别名         执行效率高

修改配置sql

```xml
 <!--配置查询所有-->
    <select id="findAll" resultType="com.itheima.domain.User">
        select id as userId,address as userAddress,username as userName,sex as userSex,birthday as UserBirthday from user;
    </select>
```

第二种方式      开发效率更高

```xml
<!--配置 查询结果的列名和实体类的属性名的对应关系-->
    <resultMap id="userMap" type="com.itheima.domain.User">
        <!-- 主键字段的对应 -->
        <id property="userId" column="id"></id>
        <!--非主键字段的对应-->
        <result property="userName" column="username"></result>
        <result property="userAddress" column="address"></result>
        <result property="userSex" column="sex"></result>
        <result property="userBirthday" column="birthdaye"></result>
    </resultMap>

    <!--配置查询所有-->
    <select id="findAll" resultMap="userMap">                   注意此处改用了resultMap 
        <!--select id as userId,address as userAddress,username as userName,sex as userSex,birthday as UserBirthday from user;-->
        select * from user;
    </select>
```

### 13 Mybatis中编写dao实现类的使用方式-查询列表

这里是展示自己编写dao实现类，实际mybatis已实现，不用自己写，节约很多时间

创建实现类

```java
package com.itheima.dao.impl;

import com.itheima.dao.IUserDao;
import com.itheima.domain.User;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;

import java.util.List;

public class UserDaoImpl implements IUserDao {

    private SqlSessionFactory factory;

    public UserDaoImpl(SqlSessionFactory factory){//通过构造函数给factory传值
        this.factory = factory;
    }
    
	@Override
    public List<User> findAll() {
        //1.根据factory获取SqlSession对象
        SqlSession session = factory.openSession();
        //2.调用SqlSession中的方法实现查询列表
        List<User> users = session.selectList("com.itheima.dao.IUserDao.findAll");//参数就是能获取配置信息的key
        //3.释放资源
        session.close();
        return users;
    }
}

```

修改测试方法

```java
package com.itheima.test;

import com.itheima.dao.IUserDao;
import com.itheima.dao.impl.UserDaoImpl;
import com.itheima.domain.User;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import java.io.InputStream;
import java.util.Date;
import java.util.List;

/**
 * 测试mybatis的crud操作
 */
public class MybatisTest {

    private InputStream in;
    private IUserDao userDao;

    @Before//用于在测试方法执行之前执行
    public void init() throws Exception{
        //1.读取配置文件
         in = Resources.getResourceAsStream("SqlMapConfig.xml");
        //2.创建SqlSessionFactory工厂
        SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in);
        //3.使用工厂对昂，创建dao对象
        userDao = new UserDaoImpl(factory);
    }

    @After//用于在测试方法执行之后执行
    public void destory() throws Exception{

        //6.释放资源
        in.close();
    }

    /**
     * 测试查询所有
     */
    @Test
    public void testFindAll(){

        //5.使用代理对象执行方法
        List<User> users = userDao.findAll();
        for(User user : users){
            System.out.println(user);
        }

    }

}
 
```

### 14_Mybatis中编写dao实现类的使用-保存操作

完善实体类方法

```java
package com.itheima.dao.impl;

import com.itheima.dao.IUserDao;
import com.itheima.domain.User;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;

import java.util.List;

public class UserDaoImpl implements IUserDao {

    private SqlSessionFactory factory;

    public UserDaoImpl(SqlSessionFactory factory){//通过构造函数给factory传值
        this.factory = factory;
    }
	@Override
    public List<User> findAll() {
        //1.根据factory获取SqlSession对象
        SqlSession session = factory.openSession();
        //2.调用SqlSession中的方法实现查询列表
        List<User> users = session.selectList("com.itheima.dao.IUserDao.findAll");//参数就是能获取配置信息的key
        //3.释放资源
        session.close();
        return users;
    }
	@Override
    public void saveUser(User user) {               //此处
        //1.根据factory获取SqlSession对象
        SqlSession session = factory.openSession();
        //2/调用方法实现保存
        session.insert("com.itheima.dao.IUserDao.saveUser",user);   //此处user易漏掉出错
        //3.提交事物
        session.commit();
        //4.释放资源
        session.close();
    }
}

```

修改测试方法      同上阶段，部分代码已省略

```
/**
     * 测试保存操作
     */
    @Test
    public void  testSave() {
        User user = new User();
        user.setUsername("dao impl user");
        user.setAddress("北京市东城区");
        user.setSex("男");
        user.setBirthday(new Date());

        System.out.println("保存操作前" + user);

        //5.使用保存方法
        userDao.saveUser(user);

        System.out.println("保存操作后" + user);
    }
```

### 15_Mybatis中编写dao实现类的使用-修改删除等其他操作

完善实体类方法

```java
    @Override
    public void updateUser(User user) {
        //1.根据factory获取SqlSession对象
        SqlSession session = factory.openSession();
        //2/调用方法实现更新
        session.update("com.itheima.dao.IUserDao.updateUser",user);
        //3.提交事物
        session.commit();
        //4.释放资源
        session.close();
    }

    @Override
    public void deleteUser(Integer user) {
        //1.根据factory获取SqlSession对象
        SqlSession session = factory.openSession();
        //2/调用方法实现更新
        session.delete("com.itheima.dao.IUserDao.deleteUser",user);
        //3.提交事物
        session.commit();
        //4.释放资源
        session.close();
    }

    @Override
    public User findById(Integer userId) {
        //1.根据factory获取SqlSession对象
        SqlSession session = factory.openSession();
        //2/调用方法实现更新
        User user = session.selectOne("com.itheima.dao.IUserDao.findById", userId);
        //3.释放资源
        session.close();
        return user;
    }

    @Override
    public List<User> findByName(String username) {
        //1.根据factory获取SqlSession对象
        SqlSession session = factory.openSession();
        //2/调用方法实现更新
        List<User> users = session.selectList("com.itheima.dao.IUserDao.findByName",username);
        //3.释放资源
        session.close();
        return users;
    }

    @Override
    public int findTotal() {
        //1.根据factory获取SqlSession对象
        SqlSession session = factory.openSession();
        //2/调用方法实现更新
        Integer count = session.selectOne("com.itheima.dao.IUserDao.findTotal");
        //3.释放资源
        session.close();
        return count;
    }
```

修改测试方法      同上阶段，部分代码已省略

```java
   /**
     *测试更新操作
     */
    @Test
    public void testUpdate(){
        User user = new User();
        user.setId(50);
        user.setUsername("userdao impl update user");
        user.setAddress("北京市东城区");
        user.setSex("女");
        user.setBirthday(new Date());

        //5.使用保存方法
        userDao.updateUser(user);
    }

    /**
     *测试删除操作
     */
    @Test
    public void testDelete(){
        //5.执行删除方法
        userDao.deleteUser(54);
    }

    /**
     * 测试查询一个
     */
    @Test
    public void testFindOne(){
        //5.执行删除方法
        User user = userDao.findById(46);
        System.out.println(user);
    }

    /**
     * 测试模糊查询操作
     */
    @Test
    public void testFindByUserName(){
        //5.执行删除方法
        List<User> users = userDao.findByName("%王%");
        for (User user : users) {
            System.out.println(user);
        }
    }

    /**
     * 查询总记录条数
     */
    @Test
    public void testFindTotal(){
        //执行查询方法
        int count = userDao.findTotal();
        System.out.println(count);
    }
```

### 16 Mybatis中使用Dao实现类的执行过程分析-查询方法1

![非常重要的一张图-分析编写dao实现类Mybatis的执行过程](C:/Users/Murphy/Pictures/非常重要的一张图-分析编写dao实现类Mybatis的执行过程.png)

### 16_ Mybatis中使用Dao实现类的执行过程分析-查询方法2

较为复杂，没怎么看

### 17_Mybatis中使用Dao实现类的执行过程分析-增删改方法

较为复杂，没怎么看

### 18Mybatis中使用代理Dao的执行过程分析

```
xmind已画图
```

### ![非常重要的一张图-分析代理dao的执行过程](C:/Users/Murphy/Pictures/非常重要的一张图-分析代理dao的执行过程.png)19_properties标签的使用及细节

可以通过properties标签去配置连接数据库的信息，先修改dataSource下property标签的value信息，再到properties节点下配置resource的文件jdbcConfig.properties  

jdbcConfig.properties文件与SqlMapConfig.xml都在resourses文件夹下

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<!--mybatis的主配置文件-->
<configuration>
    <!--配置properties
        可以在标签内部配置连接数据库的信息。也可以通过属性引用外部配置文件信息
        resource属性：
            用于指定配置文件的位置，是按照类路径的写法来写，并且必须存在于路径下。
    -->

    <properties resource="jdbcConfig.properties">
        <!--
        <property name="driver" value="com.mysql.jdbc.Driver"/>
        <property name="url" value="jdbc:mysql://localhost:3306/eesy_mybatis"/>
        <property name="username" value="root"/>
        <property name="password" value="123456"/>
        -->
    </properties>


    <!--配置环境-->
    <environments default="mysql">
        <!--配置mysql的环境-->
        <environment id="mysql">
            <!--配置事务的类型-->
            <transactionManager type="JDBC"></transactionManager>
            <!--配置数据源（连接池）-->
            <dataSource type="POOLED">
                <!--配置链接数据库的4个基本信息-->
                <property name="driver" value="${jdbc.driver}"/>
                <property name="url" value="${jdbc.url}"/>
                <property name="username" value="${jdbc.username}"/>
                <property name="password" value="${jdbc.password}"/>
            </dataSource>
        </environment>
    </environments>

    <!--指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件-->
    <mappers>
<!--        <mapper resource="com/itheima/dao/IUserDao.xml"/>-->
        <mapper resource="com/itheima/dao/IUserDao.xml"/>
    </mappers>
</configuration>
```

jdbcConfig.properties文件内容

注意：dataSource下property标签的value信息要与jdbcConfig.properties文件中保持一致，比如用jdbc.driver就都用，或者都不用只用driver

```xml
jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/eesy_mybatis
jdbc.username=root
jdbc.password=123456
```

也可以改用url标签

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<!--mybatis的主配置文件-->
<configuration>
    <!--配置properties
        可以在标签内部配置连接数据库的信息。也可以通过属性引用外部配置文件信息
        resource属性：
            用于指定配置文件的位置，是按照类路径的写法来写，并且必须存在于路径下。
        url属性:
            是要求按照url的写法来写地址
            URL:Uniform Resource Locator统一资源定位符。它是可以唯一标识一个资源的位置。
            它的写法：
                http://localhost:8080/mybatisserver/demo1Servlet
                协议      主机     端口  URI
            URI：Uniform Resource Identifier统一资源标识符。它是在应用中可以唯一定位一个资源的。
			file是file协议，使用的是默认端口号
    -->

    <properties url="file:///D:/IdeaProjects/mybatis/day02_eesy_01mybatisCRUD/src/main/resources/jdbcConfig.properties">    此处
        <!--
        <property name="driver" value="com.mysql.jdbc.Driver"/>
        <property name="url" value="jdbc:mysql://localhost:3306/eesy_mybatis"/>
        <property name="username" value="root"/>
        <property name="password" value="123456"/>
        -->
    </properties>


    <!--配置环境-->
    <environments default="mysql">
        <!--配置mysql的环境-->
        <environment id="mysql">
            <!--配置事务的类型-->
            <transactionManager type="JDBC"></transactionManager>
            <!--配置数据源（连接池）-->
            <dataSource type="POOLED">
                <!--配置链接数据库的4个基本信息-->
                <property name="driver" value="${jdbc.driver}"/>
                <property name="url" value="${jdbc.url}"/>
                <property name="username" value="${jdbc.username}"/>
                <property name="password" value="${jdbc.password}"/>
            </dataSource>
        </environment>
    </environments>

    <!--指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件-->
    <mappers>
<!--        <mapper resource="com/itheima/dao/IUserDao.xml"/>-->
        <mapper resource="com/itheima/dao/IUserDao.xml"/>            此处同理，没有修改
    </mappers>
</configuration>
```

### 20_typeAliases标签和package标签

节省很多代码

SqlMapConfig.xml

```xml
<!--使用typeAliases配置别名，它只能配置domain中类的别名-->
    <typeAliases>                                      此处
        <!--typeAlias用于配置别名。type属性指定的是实体类全限定类名。alias属性指定别名，当指定了别名就不再区分大小写-->
        <typeAlias type="com.itheima.domain.User" alias="user"></typeAlias>
    </typeAliases>
```

IUserDao.xml

```
<!--更新用户-->
    <update id="updateUser" parameterType="user">        此处  直接用user即可
        update user set username=#{userName},address=#{userAddress},sex=#{userSex},birthday=#{userBirthday} where id=#{userId};
    </update>
```

更方便的方式

```xml
<typeAliases>
        <!--package用于指定要配置别名的包，当指定之后，该包下的实体类都会注册别名，并且类名就是别名，不再区分大小写-->
        <package name="com.itheima.domain"/>          	此处
    </typeAliases>
```

SqlMapConfig.xml

```xml
<mappers>
        <!--<mapper resource="com/itheima/dao/IUserDao.xml"/>-->
        <!--package标签是用于指定dao接口所在的包，当指定完成之后就不需要再写mapper及resource或者class-->
        <package name="com.itheima.dao"/>            	此处
    </mappers>
```

### 第三部分

### ----------------------

### 01_今日课程内容介绍

```
1、mybatis中的连接池以及事务控制                    原理部分了解，应用部分会用
	mybatis中连接池使用及分析
	mybatis事务控制的分析
2、mybatis基于XM配置的动态SQL语句使用				会用即可
		mappers配置文件中的几个标签：
		<if>
		<where>
		<foreach>
		<sql>
3、mybatis中的多表操作								掌握应用
		一对多
		一对一（？）
		多对多
```

### 02连接池介绍

```
1、连接池：
	我们在实际开发中都会使用连接池。
	因为它可以减少我们获取连接所消耗的时间。
```

![无标题](C:/Users/Murphy/Pictures/无标题-1628233602675.png)

### 03_mybatis连接池的分类

```
2、mybatis中的连接池
	mybatis连接池提供了3种方式的配置：
		配置的位置：
		主配置文件SqlMapConfig.xml中的dataSource标签，type属性就是表示采用何种连接池方
		type属性的取值：
			POOLED		采用传统的javax.sq1.DataSource规范中的连接池Imybatis中有针对规范的实现
			UNPOOLED	采用传统的获取连接的方式，虽然也实现Javax.sql.DataSource接口，但是并没有使用池的思想
			JNDI		采用服务器提供的JNDI技术实现，来获取DataSource对象，不同的服务器所能拿的DataSource是不一样。
						注意：如果不是web或者maven的war工程，是不能使用的。
						我们课程中使用的是tomcat服务器，采用连接池就是dbcp连接池。
```

### 04_mybatis中使用unpooled配置连接池的原理分析



![无标题2](C:/Users/Murphy/Pictures/无标题2.png)

### 05_mybatis中使用poolead配置连接的原理分析

![1](C:/Users/Murphy/Pictures/1.jpg)

-----------------------------------------

![mybatis_pooled的过程](C:/Users/Murphy/Pictures/mybatis_pooled的过程.png)

### 06_mybatis中的事务原理和自动提交设置

```
3、mybatis中的事务
	什么是事务
	事务的四大特性ACID
	不考虑隔离性会产生的3个问题
	解决办法：四种隔离级别
```

按照源码，openSession改为true就能自动提交----------其实多次连接数据库只会提交一次，并不是每次操作都提交

![image-20210807230351045](C:/Users/Murphy/Pictures/image-20210807230351045.png)

修改如下

```java
package com.itheima.test;

import com.itheima.dao.IUserDao;
import com.itheima.domain.QueryVo;
import com.itheima.domain.User;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import java.io.InputStream;
import java.util.Date;
import java.util.List;

/**
 * 测试mybatis的crud操作
 */
public class MybatisTest {

    private InputStream in;
    private SqlSession sqlSession;
    private IUserDao userDao;

    @Before//用于在测试方法执行之前执行
    public void init() throws Exception{
        //1.读取配置文件
         in = Resources.getResourceAsStream("SqlMapConfig.xml");
        //2.创建SqlSessionFactory工厂
        SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in);
        //3.使用工厂生产SqlSession对象
        sqlSession = factory.openSession(true);               此处
        //4.使用SqlSession创建Dao接口的代理对象
        userDao = sqlSession.getMapper(IUserDao.class);
    }

    @After//用于在测试方法执行之后执行
    public void destory() throws Exception{

        //提交事物
        //sqlSession.commit();                  此处注释掉

        //6.释放资源
        sqlSession.close();
        in.close();
    }
    
    /**
     * 测试保存操作
     */
    @Test
    public void  testSave() {
        User user = new User();
        user.setUserName("autocommit");
        user.setUserAddress("北京市东城区");
        user.setUserSex("男");
        user.setUserBirthday(new Date());

        System.out.println("保存操作前" + user);

        //5.使用保存方法
        userDao.saveUser(user);

        System.out.println("保存操作后" + user);
    }
 }   
```

### 07_mybatis中的动态sq|语句-if标签

IUserDao.xml

```xml
  <resultMap id="userMap" type="uSeR">           注意
        <!-- 主键字段的对应 -->
        <id property="userId" column="id"></id>
        <!--非主键字段的对应-->
        <result property="userName" column="username"></result>
        <result property="userAddress" column="address"></result>
        <result property="userSex" column="sex"></result>
        <result property="userBirthday" column="birthday"></result>
    </resultMap>
 <!--根据条件查询-->															此处
    <select id="findUserByCondition" resultMap="userMap" parameterType="user">      
        select * from user where 1=1
        <if test="userName !=null">
            and username = #{userName}
        </if>
    </select>
```

测试类

```java
 /**
     *根据条件查询
     */
    @Test
    public void testFindUserByCondition(){
        User u = new User();
        u.setUserName("老王");
        List<User> users = userDao.findUserByCondition(u);

        for (User user : users) {
            System.out.println(user);
        }
    }
```

### 08_mybatis中动态sq|语句-where标签的使用

自动根据传入参数查询SQL，使用where标签 ，避免使用where 1=1

IUserDao.xml

```xml
<select id="findUserByCondition" resultMap="userMap" parameterType="user">
        select * from user						此处不再使用where 1=1
        <where>                               此处
            <if test="userName !=null">
              and username = #{userName}
            </if>
            <if test="userSex !=null">
                and sex = #{userSex}
            </if>
        </where>
    </select>
```

测试类

```java
/**
     *根据条件查询
     */
    @Test
    public void testFindUserByCondition(){
        User u = new User();
        u.setUserName("老王");
        u.setUserSex("女");
        List<User> users = userDao.findUserByCondition(u);

        for (User user : users) {
            System.out.println(user);
        }
    }
```

### 09_mybatis中动态sq|语句-foreach和sq|标签

解决问题  select * from user where id in(41,42,43,46);

QueryVo

```java
package com.itheima.domain;

import java.util.List;

public class QueryVo {
    private User user;

    private List<Integer> ids;

    public User getUser() {
        return user;
    }

    public void setUser(User user) {
        this.user = user;
    }

    public List<Integer> getIds() {
        return ids;
    }

    public void setIds(List<Integer> ids) {
        this.ids = ids;
    }
}

```

IUserDao.xml

```xml
<!--根据QueryVo中的id集合实现查询用户列表   #{id}由item="id"决定-->
    <select id="findUserInIds" resultMap="userMap" parameterType="queryvo">
        select * from user
        <where>
            <if test="ids !=null and ids.size>0">
                <foreach collection="ids" open="and id in (" close=")" item="id" separator=",">
                    #{id}
                </foreach>
            </if>
        </where>
    </select>
```

测试类

```java
/**
     *测试foreach标签的使用
     */
    @Test
    public void testFindInIds(){
        QueryVo vo = new QueryVo();
        List<Integer> list = new ArrayList<Integer>();
        list.add(41);
        list.add(42);
        list.add(46);
        vo.setIds(list);
        //执行查询方法
        List<User> users = userDao.findUserInIds(vo);

        for (User user : users) {
            System.out.println(user);
        }
    }
```

其他，抽取重复的sql语句简化操作

IUserDao.xml

```xml
 <!-- 了解的内容：抽取重复的sql语句-->
    <sql id="defaultUser">
        select * from user
    </sql>
    
 <!-- 查询所有 -->
    <select id="findAll" resultMap="userMap">
        <include refid="defaultUser"></include>                             此处引用
    </select>

<!--根据QueryVo中的id集合实现查询用户列表   #{id}由item="id"决定-->
    <select id="findUserInIds" resultMap="userMap" parameterType="queryvo">
        <include refid="defaultUser"></include>                             此处引用
        <where>
            <if test="ids !=null and ids.size>0">
                <foreach collection="ids" open="and id in (" close=")" item="id" separator=",">
                    #{id}
                </foreach>
            </if>
        </where>
    </select>
```

### 10 mybatis表之间关系分析

```
4、mybatis中的多表查询
表之间的关系有几种：
一对多
多对一
一对一
多对多
举例：
	用户和订单就是一对多
	订单和用户就是多对一
		一个用户可以下多个订单
		多个订单属于同一个用户
	人和身份证就是一对一		
		一个身份证号只能属于一个人
		一个人只能有一个身份证号
	老师和学生之间就是多对多	
		一个老师可以交多个学生
		一个学生可以被多个老师教过
	特例：
		如果拿出每一个订单，他都只能属于一个用户。
		所以Mybatis就把多对一看成了一对一。
```

### 11_完成account表的建立及实现单表查询

```
mybatis中的多表查询：示例：用户和账户
	一个用户可以有多个账户
	一个账户只能属于一个用户 （多个账户也可以属于同一个用户）
	
步骤：
	1、建立两张表：用户表，账户表
		让用户表和账户表之间具备一对多的关系：需要使用外键在账户表中添加
	2、建立两个实体类：用户实体类和账户实体类	
		让用户和账户的实体类能体现出一对多的关系
	3、建立两个配置文件
		用户的配置文件
		账户的配置文件
	4、实现配置：
		当我们查询用户时，可以同时得到用户下所包含的账户信息
		当我们查询账户时，可以同时得到账户的所属用户信息
```

工程名称  day03_eesy_03one2many

新建实体类Account

```java
package com.itheima.domain;

import java.io.Serializable;

public class Account implements Serializable {
    private Integer id;
    private Integer uid;
    private Double money;

 	//此处省略了getter和setter、toSting
}

```

新建实体类

```java
package com.itheima.domain;

import java.util.Date;

public class User {
    private Integer id;
    private String username;
    private String address;
    private String sex;
    private Date birthday;

	//此处省略了getter和setter、toSting
}

```

新建dao      IAccountDao

```java
package com.itheima.dao;

import com.itheima.domain.Account;

import java.util.List;

public interface IAccountDao {
    /**
     * 查询所有账户
     * @return
     */
    List<Account> findAll();
}
```

新建dao      IAccountDao

```java
package com.itheima.dao;

import com.itheima.domain.User;

import java.util.List;

/**
 * 用户的持久层接口
 */

public interface IUserDao {

    /**
     * 查询所有用户
     * @return
     */
    List<User> findAll();
    /**
     * 根据id查询用户
     */
    User findById(Integer userId);
}
```

新建 IAccountDao.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.itheima.dao.IAccountDao">

    <!-- 查询所有 -->
    <select id="findAll" resultType="account">
        select * from account
    </select>

</mapper>
```

新建IUserDao.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE mapper
                PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
                "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.itheima.dao.IUserDao">

<!-- 查询所有 -->
<select id="findAll" resultType="user">
        select * from user
    </select>

<!--根据id查询用户-->
<select id="findById" parameterType="INT" resultType="user">
        select * from user where  id=#{uid};
    </select>

</mapper>
```

新建测试类

```java
package com.itheima.test;

import com.itheima.dao.IAccountDao;
import com.itheima.domain.Account;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import java.io.InputStream;
import java.util.List;

public class AccountTest {
    private InputStream in;
    private SqlSession sqlSession;
    private IAccountDao accountDao;

    @Before//用于在测试方法执行之前执行
    public void init() throws Exception{
        //1.读取配置文件
        in = Resources.getResourceAsStream("SqlMapConfig.xml");
        //2.创建SqlSessionFactory工厂
        SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in);
        //3.使用工厂生产SqlSession对象
        sqlSession = factory.openSession(true);
        //4.使用SqlSession创建Dao接口的代理对象
        accountDao = sqlSession.getMapper(IAccountDao.class);
    }

    @After//用于在测试方法执行之后执行
    public void destory() throws Exception{

        //提交事物
        //sqlSession.commit();

        //6.释放资源
        sqlSession.close();
        in.close();
    }

    /**
     * 测试查询所有
     */
    @Test
    public void testFindAll(){
        List<Account> accounts = accountDao.findAll();
        for (Account account : accounts) {
            System.out.println(account);
        }
    }
}

```

### 12完成account的一对一操作-通过写account的子类方式查询

注意此方式不常用

```sql
select u.*,a.id as aid,a.uid,a.money from account a,user u where u.id = a.uid;
```

新建类继承Account

```java
package com.itheima.domain;

public class AccountUser extends Account{
    private String username;
    private String address;

   //省略了Getter 、Setter

    @Override                                           
    public String toString() {
        return super.toString() + "       AccountUser{" +												//此处
                "username='" + username + '\'' +
                ", address='" + address + '\'' +
                '}';
    }
}

```

Dao中增加方法

```java
package com.itheima.dao;

import com.itheima.domain.Account;
import com.itheima.domain.AccountUser;

import java.util.List;

public interface IAccountDao {
    /**
     * 查询所有账户,同时还要获取到当前账户的所属用户信息
     * @return
     */
    List<Account> findAll();

    /**
     * 查询所有账户，并且带有用户名称和地址信息                         此处
     * @return
     */
    List<AccountUser> findAllAccount();
}

```

IAccountDao.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.itheima.dao.IAccountDao">

    <!-- 查询所有 -->
    <select id="findAll" resultType="account">
        select * from account
    </select>

    <!--查询所有账户同时包含用户名和地址信息-->
    <select id="findAllAccount" resultType="accountuser">
        select a.*,u.username,u.address from account a,user u where u.id = a.uid;
    </select>
</mapper>
```

测试类

```java
    /**
     *  查询所有账户同时包含用户名称和地址
     */
    @Test
    public void testFindAllAccountUser(){
        List<AccountUser> aus = accountDao.findAllAccount();
        for (AccountUser au : aus) {
            System.out.println(au);
        }
    }
```

### 13完成account一对一操作-建立实体类关系的方式

select u.*,a.id as aid,a.uid,a.money from account a,user u where u.id = a.uid;

常用的方式

修改Account类

```java
package com.itheima.domain;

import java.io.Serializable;

public class Account implements Serializable {
    private Integer id;
    private Integer uid;
    private Double money;

    //从表实体应该包含一个主表实体的引用对象
    private User user;

    public User getUser() {
        return user;
    }

     public void setUser(User user) {
        this.user = user;
    }
   //省略了其他Getter和Setter

    @Override
    public String toString() {
        return "Account{" +
                "id=" + id +
                ", uid=" + uid +
                ", money=" + money +
                '}';
    }
}
```

accountDao不修改

修改IAccountDao.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

    <mapper namespace="com.itheima.dao.IAccountDao">

    <!--定义封装account和user的resultMap -->                                      此处
    <resultMap id="accountUserMap" type="account">
        <id property="id" column="aid"></id>
        <result property="uid" column="uid"></result>
        <result property="money" column="money"></result>
        <!-- 一对一的关系映射：配置封装user的内容-->
        <association property="user" column="uid" javaType="user">
            <id property="id" column="id"></id>
            <result property="username" column="username"></result>
            <result property="address" column="address"></result>
            <result property="sex" column="sex"></result>
            <result property="birthday" column="birthday"></result>
        </association>
    </resultMap>

    <!-- 查询所有 -->
    <select id="findAll" resultMap="accountUserMap">
        select u.*,a.id as aid,a.uid,a.money from account a,user u where u.id = a.uid;
    </select>

   //省略了其他不相干内容
</mapper>
```

测试类

```java
 /**
     * 测试查询所有
     */
    @Test
    public void testFindAll(){
        List<Account> accounts = accountDao.findAll();
        for (Account account : accounts) {
            System.out.println("-----------每个account的信息--------------");
            System.out.println(account);
            System.out.println(account.getUser());
        }
    }
```

### 14完成user的一对多查询操作

select * from user u left outer join account a on u.id = a.uid

IUserDao不做修改

```java
package com.itheima.dao;

import com.itheima.domain.User;

import java.util.List;

/**
 * 用户的持久层接口
 */

public interface IUserDao {

    /**
     * 查询所有用户,同时获取到用户下所有账户的信息
     * @return
     */
    List<User> findAll();

    /**
     * 根据id查询用户
     */
    User findById(Integer userId);


}

```

User 新增List<Account> accounts

```java
package com.itheima.domain;

import java.util.Date;
import java.util.List;

public class User {
    private Integer id;
    private String username;
    private String address;
    private String sex;
    private Date birthday;

    //一对多关系映射：主表实体应该包含从表实体的集合引用               此处
    private List<Account> accounts;              

    public List<Account> getAccounts() {
        return accounts;
    }

    public void setAccounts(List<Account> accounts) {
        this.accounts = accounts;
    }

	//其他Getter和Setter已省略

    @Override
    public String toString() {
        return "User{" +
                "id=" + id +
                ", username='" + username + '\'' +
                ", address='" + address + '\'' +
                ", sex='" + sex + '\'' +
                ", birthday=" + birthday +
                '}';
    }
}

```

IUserDao.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE mapper
                PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
                "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
    <mapper namespace="com.itheima.dao.IUserDao">

    <!--定义user的resultMap-->                             此处
    <resultMap id="userAccountMap" type="user">
        <id property="id" column="id"></id>
        <result property="username" column="username"></result>
        <result property="address" column="address"></result>
        <result property="sex" column="sex"></result>
        <result property="birthday" column="birthday"></result>
        <!--配置user对象中account集合的映射    collection集合  ofType含义指的是集合中元素的类型  因为起了别名，所以不用写全限定类名，直接写account  -->
        <collection property="accounts" ofType="account">
            <!--column 数据库中的列名  property别名 由于id重复出现，所以起个别名-->
            <id column="aid" property="id"></id>
            <result column="uid" property="uid"></result>
            <result column="money" property="money"></result>
        </collection>
    </resultMap>

<!-- 查询所有 -->                                          
<select id="findAll" resultMap="userAccountMap">
        select * from user u left outer join account a on u.id = a.uid                此处
    </select>

<!--根据id查询用户-->
<select id="findById" parameterType="INT" resultType="user">
        select * from user where  id=#{uid};
    </select>

</mapper>
```

新增测试类

```java


package com.itheima.test;

        import com.itheima.dao.IUserDao;
        import com.itheima.domain.Account;
        import com.itheima.domain.AccountUser;
        import com.itheima.domain.User;
        import org.apache.ibatis.io.Resources;
        import org.apache.ibatis.session.SqlSession;
        import org.apache.ibatis.session.SqlSessionFactory;
        import org.apache.ibatis.session.SqlSessionFactoryBuilder;
        import org.junit.After;
        import org.junit.Before;
        import org.junit.Test;

        import java.io.InputStream;
        import java.util.List;

public class UserTest {
    private InputStream in;
    private SqlSession sqlSession;
    private IUserDao userDao;                   此处

    @Before//用于在测试方法执行之前执行
    public void init() throws Exception{
        //1.读取配置文件
        in = Resources.getResourceAsStream("SqlMapConfig.xml");
        //2.创建SqlSessionFactory工厂
        SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in);
        //3.使用工厂生产SqlSession对象
        sqlSession = factory.openSession(true);
        //4.使用SqlSession创建Dao接口的代理对象
        userDao = sqlSession.getMapper(IUserDao.class);
    }

    @After//用于在测试方法执行之后执行
    public void destory() throws Exception{

        //提交事物
        //sqlSession.commit();

        //6.释放资源
        sqlSession.close();
        in.close();
    }

    /**
     * 测试查询所有                                此处
     */
    @Test
    public void testFindAll(){
        List<User> users = userDao.findAll();
        for (User user : users) {
            System.out.println("---每个用户的信息---");
            System.out.println(user);
            System.out.println(user.getAccounts());
        }
    }

}

```

### 15_分析mybatis多对多的步骤并搭建环境

```
示例：用户和角色
	一个用户可以有多个角色
	一个角色可以赋予多个用户
	
步骤：
	1、建立两张表：用户表，角色表
		让用户表和角色表具有多对多的关系。
		需要使用中间表，中间表中包含各自的主键，在中间表中是外键。
	2、建立两个实体类：用户实体类和角色实体类
		让用户和角色的实体类能体现出来多对多的关系
		各自包含对方一个集合引用
	3、建立两个配置文件
		用户的配置文件
		角色的配置文件
	4、实现配置：
		当我们查询用户时，可以同时得到用户所包含的角色信息
		当我们查询角色时，可以同时得到角色的所赋予的 用户信息
		
建好项目day03_eeesy_04many2many
```

### 16_mybatis多对多准备角色表的实体类和映射配置

这里不在重复，操作类似12

### 17_mybatis多对多操作-查询角色获取角色下所属用户信息

![无标题1](C:/Users/Murphy/Pictures/无标题1.png)

![image-20210814131343922](C:/Users/Murphy/Pictures/image-20210814131343922.png)

```
select u.*,r.id as rid,r.role_name,r.role_desc from role r 
left outer join user_role ur on r.id = ur.rid
left outer join user u on u.id=ur.uid
```

Role.java

```java
package com.itheima.domain;

import java.io.Serializable;
import java.util.List;

public class Role implements Serializable {
    private Integer roleId;
    private  String roleName;
    private String roleDesc;

    //多对多的关系映射：一个角色可以赋予多个用户
    private List<User> users;

    //已省略

    @Override
    public String toString() {
        return "Role{" +
                "roleId=" + roleId +
                ", roleName='" + roleName + '\'' +
                ", roleDesc='" + roleDesc + '\'' +
                '}';
    }
}

```

IRoleDao.java

```java
package com.itheima.dao;

import com.itheima.domain.Role;

import java.util.List;

public interface IRoleDao {

    /**
     * 查询所有角色
     * @return
     */
    List<Role> findAll();
}

```

IRoleDao.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.itheima.dao.IRoleDao">
    <!--定义role表的ResultMap-->
    <resultMap id="roleMap" type="com.itheima.domain.Role">
        <id property="roleId" column="rid"></id>
        <result property="roleName" column="role_name"></result>
        <result property="roleDesc" column="role_desc"></result>
        <collection property="users" ofType="user">
            <id column="id" property="id"></id>
            <result column="username" property="username"></result>
            <result column="address" property="address"></result>
            <result column="sex" property="sex"></result>
            <result column="birthday" property="birthday"></result>
        </collection>
    </resultMap>

    <!--查询所有-->
    <select id="findAll" resultMap="roleMap">
        select u.*,r.id as rid,r.role_name,r.role_desc from role r
        left outer join user_role ur on r.id = ur.rid
        left outer join user u on u.id=ur.uid
    </select>
</mapper>
```

IRoleTest.java

```java


package com.itheima.test;

import com.itheima.dao.IRoleDao;
import com.itheima.domain.Role;
import com.itheima.domain.User;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import java.io.InputStream;
import java.util.List;

public class RoleTest {
    private InputStream in;
    private SqlSession sqlSession;
    private IRoleDao roleDao;

    @Before//用于在测试方法执行之前执行
    //已省略

    @After//用于在测试方法执行之后执行
   //已省略

    /**
     * 测试查询所有
     */
    @Test
    public void testFindAll() {
        List<Role> roles = roleDao.findAll();
        for (Role role : roles) {
            System.out.println("---每个角色的信息---");
            System.out.println(role);
            System.out.println(role.getUsers());
        }
    }

}

```

### 18_ mybatis多对多操作-查询用户获取用户所包含的角色信息

![image-20210814131226352](C:/Users/Murphy/Pictures/image-20210814131226352.png)

```
select u.*,r.id as rid,r.role_name,r.role_desc from user u 
left outer join user_role ur on u.id = ur.uid   
left outer join role r on r.id=ur.rid
```

User.java

```java
package com.itheima.domain;

import java.util.Date;
import java.util.List;

public class User {
    private Integer id;
    private String username;
    private String address;
    private String sex;
    private Date birthday;

    //多对多的关系映射：一个用户可以具备多个角色
    private Role role;

    private List<Role> roles;

	//已省略

    @Override
    public String toString() {
        return "User{" +
                "id=" + id +
                ", username='" + username + '\'' +
                ", address='" + address + '\'' +
                ", sex='" + sex + '\'' +
                ", birthday=" + birthday +
                '}';
    }
}

```

IUserDao.xml

**注意：<collection>标签中，property和column顺序不能写反，要先写property再写column**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.itheima.dao.IUserDao">

    <!--定义user的resultMap-->
    <resultMap id="userMap" type="user">
        <id property="id" column="id"></id>
        <result property="username" column="username"></result>
        <result property="address" column="address"></result>
        <result property="sex" column="sex"></result>
        <result property="birthday" column="birthday"></result>
        <!--配置角色集合的映射-->
        <collection property="roles" ofType="role">
            <id property="roleId" column="rid" ></id>
            <result property="roleName" column="role_name" ></result>
            <result property="roleDesc" column="role_desc" ></result>
        </collection>
    </resultMap>

    <!-- 查询所有 -->
    <select id="findAll" resultMap="userMap">
        select u.*,r.id as rid,r.role_name,r.role_desc from user u
         left outer join user_role ur  on u.id = ur.uid
         left outer join role r on r.id = ur.rid
    </select>

    <!--根据id查询用户-->
    <select id="findById" parameterType="INT" resultType="user">
        select * from user where  id=#{uid};
    </select>

</mapper>
```

UserTest.java

```java


package com.itheima.test;

        import com.itheima.dao.IUserDao;
        import com.itheima.domain.User;
        import org.apache.ibatis.io.Resources;
        import org.apache.ibatis.session.SqlSession;
        import org.apache.ibatis.session.SqlSessionFactory;
        import org.apache.ibatis.session.SqlSessionFactoryBuilder;
        import org.junit.After;
        import org.junit.Before;
        import org.junit.Test;

        import java.io.InputStream;
        import java.util.List;

public class UserTest {
    private InputStream in;
    private SqlSession sqlSession;
    private IUserDao userDao;

    @Before//用于在测试方法执行之前执行
    //已省略

    @After//用于在测试方法执行之后执行
    //已省略

    /**
     * 测试查询所有
     */
    @Test
    public void testFindAll(){
        List<User> users = userDao.findAll();
        for (User user : users) {
            System.out.println("---每个用户的信息---");
            System.out.println(user);
            System.out.println(user.getRoles());
        }
    }

}

```

### 19补充-JNDI概述和原理

```
JNDI：Java Naming and Directory Interface。是SUN公司推出的一套规范，属于JavaEE技术之一。目的是模仿windows系统中的注册表。
```

![JNDI](C:/Users/Murphy/Pictures/JNDI.png)

#### 20_补充-JNDI搭建maven的war工程

```xml
创建Maven，勾选Create from archetype，选择maven-archetype-webapp
day03_eesy_05jndi

Cannot resolve plugin org.apache.maven.plugins:maven-site-plugin问题解决方法
pom.xml添加
		<plugin>
		<groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-site-plugin</artifactId>
        <version>3.6</version>
        </plugin>
```

![image-20210814215701415](C:/Users/Murphy/Pictures/image-20210814215701415.png)

```
新建java文件夹
新建resources文件夹
新建test文件夹
详细骤参考视频
```

### 21补充-测试JNDI数据源的使用以及使用细节

```
新建META-INF文件夹
放置context.xml
替换SqlMapConfig.xml
写加载到tomcat，在index.jsp中用main方法写测试类就可以了，单测试类是无法使用的，因为没有通过tomcat，而使用jsp就通过tomcat
```

index.jsp

```jsp
<%@ page import="org.apache.ibatis.session.SqlSessionFactoryBuilder" %>
<%@ page import="java.io.InputStream" %>
<%@ page import="org.apache.ibatis.io.Resources" %>
<%@ page import="org.apache.ibatis.session.SqlSessionFactory" %>
<%@ page import="org.apache.ibatis.session.SqlSession" %>
<%@ page import="com.itheima.dao.IUserDao" %>
<%@ page import="com.itheima.domain.User" %>
<%@ page import="java.util.List" %>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<body>
<h2>Hello World!</h2>
<%
    //1.读取配置文件
    InputStream in = Resources.getResourceAsStream("SqlMapConfig.xml");
    //2.创建SqlSessionFactory工厂
    SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();
    SqlSessionFactory factory = builder.build(in);
    //3.使用工厂生产SqlSession对象
    SqlSession sqlSession = factory.openSession();
    //4.使用SqlSession创建Dao接口的代理对象
    IUserDao userDao = sqlSession.getMapper(IUserDao.class);
    //5.使用代理对象执行方法
    List<User> users = userDao.findAll();
    for(User user : users){
        System.out.println(user);
    }
    //6.释放资源
    sqlSession.close();
    in.close();
%>
</body>
</html>

```

![image-20210815164407228](C:/Users/Murphy/Pictures/image-20210815164407228.png)

### 第四部分

### ----------------------

### 01_今日课程安排

```
1、Mybatis中的延迟加载
	什么是延迟加载
	什么是立即加载
2、Mybatis中的缓存
	什么是缓存
	为什么使用缓存
	什么样的数据能使用缓存，什么样的数据不能使用
	Mybatis中的一级缓存和二级缓存
3、Mybatis中的注解开发
	环境搭建
	单表CRUD操作（代理Dao方式）
	多表查询操作
	缓存的配置
```

### 02延迟加载和立即加载的概念

```
1、Mybatis中的延迟加载

	问题：在一对多中，当我们有一个用户，它有100个账户。
	1)在查询用户的时候，要不要把关联的账户查出来？
	2)在查询账户的时候，要不要把关联的用户查出来？
		1).在查询用户时，用户下的账户信息应该是，什么时候使用，什么时候查询的。
		2).在查询账户时，账户的所属用户信息应该是随着账户查询时一起查询出来
	在查询用户时，用户下的账户信息
		什么是延迟加载
			在真正使用数据时才发起查询，不用的时候不查询。按需加载（懒加载）
		什么是立即加载
			不管用不用，只要一调用方法，马上发起查询。
	在对应的四种表关系中：一对多，多对一，一对一，多对多。
			一对多，多对多：通常情况下我们都是采用延迟加载。
			多对一，一对一：通常情况下我们都是采用立即加载。
```

### 03 mybatis一对一实现延迟加载

day04_eesy_04_lazy

![image-20210816211725518](C:/Users/Murphy/Pictures/image-20210816211725518.png)

配置SqlMapConfig.xml                      <settings>标签

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<!--mybatis的主配置文件-->
<configuration>

    <properties resource="jdbcConfig.properties"></properties>

    <!--配置参数-->                                         此处
    <settings>
        <!--开启MyBatis支持延迟加载-->
        <setting name="lazyLoadingEnabled" value="true"/>
        <setting name="aggressiveLazyLoading" value="false"></setting>
    </settings>

    <!--使用typeAliases配置别名，它只能配置domain中类的别名-->
    <typeAliases>
        <package name="com.itheima.domain"/>
    </typeAliases>

<!--配置环境-->
    <environments default="mysql">
        <!--配置mysql的环境-->
        <environment id="mysql">
            <!--配置事务的类型-->
            <transactionManager type="JDBC"></transactionManager>
            <!--配置数据源（连接池）-->
            <dataSource type="POOLED">
                <property name="driver" value="${jdbc.driver}"/>
                <property name="url" value="${jdbc.url}"/>
                <property name="username" value="${jdbc.username}"/>
                <property name="password" value="${jdbc.password}"/>
            </dataSource>
        </environment>
    </environments>
    <!--配置映射文件的位置-->
    <mappers>
        <package name="com.itheima.dao"/>
    </mappers>
</configuration>
```

修改IAccountDao.xml      <association>标签            修改sql语句为select * from account

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

    <mapper namespace="com.itheima.dao.IAccountDao">

    <!--定义封装account和user的resultMap -->
    <resultMap id="accountUserMap" type="account">
        <id property="id" column="id"></id>
        <result property="uid" column="uid"></result>
        <result property="money" column="money"></result>
        <!-- 一对一的关系映射：配置封装user的内容                        此处
            select属性指定的内容：查询用户的唯一标识:
            column属性指定的内容：用户根据id查询时，所需要的参数的值
        -->
        <association property="user" column="uid" javaType="user" select="com.itheima.dao.IUserDao.findById">
        </association>
    </resultMap>

    <!-- 查询所有 -->
    <select id="findAll" resultMap="accountUserMap">
        select * from account
    </select>
</mapper>
```

![延迟加载](C:/Users/Murphy/Pictures/延迟加载.png)

### 04 mybatis一对多实现延迟加载

同理主配置文件中修改SqlMapConfig.xml

```xml
<!--配置参数-->
    <settings>
        <!--开启MyBatis支持延迟加载-->
        <setting name="lazyLoadingEnabled" value="true"/>
        <setting name="aggressiveLazyLoading" value="false"></setting>
    </settings>
```

修改<collection>标签 修改<!-- 查询所有 -->findAll SQL语句

```xml
<?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE mapper
                PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
                "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
    <mapper namespace="com.itheima.dao.IUserDao">

    <!--定义user的resultMap-->
    <resultMap id="userAccountMap" type="user">
        <id property="id" column="id"></id>
        <result property="username" column="username"></result>
        <result property="address" column="address"></result>
        <result property="sex" column="sex"></result>
        <result property="birthday" column="birthday"></result>
        <!--配置user对象中account集合的映射    collection集合  ofType含义指的是集合中元素的类型  因为起了别名，所以不用写全限定类名，直接写account  -->
        <collection property="accounts" ofType="account" select="com.itheima.dao.IAccountDao.findAccountByUId" column="id">
        </collection>
    </resultMap>

<!-- 查询所有 -->
<select id="findAll" resultMap="userAccountMap">
        select * from user
    </select>

<!--根据id查询用户-->
<select id="findById" parameterType="INT" resultType="user">
        select * from user where  id=#{uid};
    </select>

</mapper>
```

IAccountDao.xml  新增findAccountByUId  SQL语句

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

    <mapper namespace="com.itheima.dao.IAccountDao">

    <!--定义封装account和user的resultMap -->
    <resultMap id="accountUserMap" type="account">
        <id property="id" column="id"></id>
        <result property="uid" column="uid"></result>
        <result property="money" column="money"></result>
        <!-- 一对一的关系映射：配置封装user的内容
            select属性指定的内容：查询用户的唯一标识:
            column属性指定的内容：用户根据id查询时，所需要的参数的值
        -->
        <association property="user" column="uid" javaType="user" select="com.itheima.dao.IUserDao.findById">

        </association>
    </resultMap>

    <!-- 查询所有 -->                      此处修改
    <select id="findAll" resultMap="accountUserMap">
        select * from account
    </select>

    <!-- 根据用户ID查询账户；列表 -->         此处新增
    <select id="findAccountByUId" resultType="account">
        select * from account where uid = #{uid}
    </select>
</mapper>
```

IAccountDao.java新增查询方法

```java
package com.itheima.dao;

import com.itheima.domain.Account;

import java.util.List;

public interface IAccountDao {
    /**
     * 查询所有账户,同时还要获取到当前账户的所属用户信息
     * @return
     */
    List<Account> findAll();

    /**
     * 根据用户id查询账户信息
     */
    List<Account> findAccountByUId(Integer uid);
}

```

### 05缓存的概念

```
2、Mybatis中的缓存
	什么是缓存
		存在于内存中的临时数据
	为什么使用缓存
		减少和数据库的交互次数，提高执行效率
	什么样的数据能使用缓存，什么样的数据不能使用
		适用于缓存：
			经常查询，并且不经常改变的。
			数据的正确与否对最终结果影响不大的。
		不适用于缓存：
			经常改变的数据
			数据的正确与否对最终结果影响很大的。
			例如：商品的库存，银行的汇率，股市的牌价。
	Mybatis中的一级缓存和二级缓存
3、Mybatis中的注解开发
	环境搭建
	单表CRUD操作（代理Dao方式）
	多表查询操作
	缓存的配置
```

### 06_Mybatis中的一级缓存

```
一级缓存：
	它指的是Mybatis中SqlSession对象的缓存。
	当我们执行查询之后，查询的结果会同时存入到SqlSession为我们提供的一块区域中。
	该区域的结构是一个Map。当我们再次查询同样的数据，Mybatis会先去SqlSession中查询是否有，有的话直接拿出来用。
	当SalSession对象消失时，Mybatis的一级缓存也就消失了。
```

测试

```java
package com.itheima.test;
import com.itheima.dao.IUserDao;
import com.itheima.domain.User;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import java.io.InputStream;
import java.util.List;

public class UserTest {
    private InputStream in;
    private SqlSession sqlSession;
    private SqlSessionFactory factory;
    private IUserDao userDao;

    @Before//用于在测试方法执行之前执行
    public void init() throws Exception{
        //1.读取配置文件
        in = Resources.getResourceAsStream("SqlMapConfig.xml");
        //2.创建SqlSessionFactory工厂
        factory = new SqlSessionFactoryBuilder().build(in);
        //3.使用工厂生产SqlSession对象
        sqlSession = factory.openSession(true);
        //4.使用SqlSession创建Dao接口的代理对象
        userDao = sqlSession.getMapper(IUserDao.class);
    }

    @After//用于在测试方法执行之后执行
    public void destory() throws Exception{

        //提交事物
        //sqlSession.commit();

        //6.释放资源
        sqlSession.close();
        in.close();
    }

    /**
     * 测试一级缓存
     */
    @Test
    public void testFirstLevelCache(){
        User user1 = userDao.findById(41);
        System.out.println(user1);

        //sqlSession.close(); 

        //再次获取SQLSession对象
        //sqlSession = factory.openSession(true);

        sqlSession.clearCache();//此方法也可以清空缓存          此处

        userDao = sqlSession.getMapper(IUserDao.class);

        User user2 = this.userDao.findById(41);
        System.out.println(user2);

        System.out.println(user1 == user2);//false
    }
}
```

### 07触发清空一级缓存的情况

数据库和缓存数据不一致时

```
一级缓存是SqlSession范围的缓存，当调用SqlSession的修改，添加，删除，commit()，close()等方法时，就会清空一级缓存
```

IUserDao.xml

```xml
<!--更新用户信息-->
    <select id="updateUser" parameterType="user">
        update user set username=#{username},address=#{address} where id=#{id}
    </select>
```

 UserTest

```java
/**
     *测试缓存的同步
     */
    @Test
    public void testClearCache(){
        //1.根据id查询用户
        User user1 = userDao.findById(41);
        System.out.println(user1);
        
        //2.更新用户信息
        user1.setUsername("update user clear cache");
        user1.setAddress("北京市海淀区");
        userDao.updateUser(user1);//Preparing: select * from user where id=?; 

        //3.再次查询id为41的用户
        User user2 = this.userDao.findById(41);
        System.out.println(user2);

        System.out.println(user1 == user2);//false
    }
```

### 08_mybatis的二级缓存

```
	二级缓存：
		它指的是Mybatis中SqlSessionFactory对象的缓存。由同一个Sq1SessionFactory对象创建的SqlSession共享其缓存。
	二级缓存的使用步骤：
			第一步：让Mybatis框架支持二级缓存（在Sq1MapConfig.xml中配置）
			第二步：让当前的映射文件支持二级缓存（在IUserDao.xml中配置）
			第三步：让当前的操作支持二级缓存（在select标签中配置）|
```

![二级缓存](C:/Users/Murphy/Pictures/二级缓存.png)

SqlMapConfig.xml

```xml
<settings>														第一步，此处
        <setting name="cacheEnabled" value="true"/>
</settings>
```

IUserDao.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.itheima.dao.IUserDao">

    <!--开启user支持二级缓存-->                       第二步，此处
    <cache/>

    <!-- 查询所有 -->
    <select id="findAll" resultType="user">
        select * from user
    </select>

    <!--根据id查询用户-->
    <select id="findById" parameterType="INT" resultType="user" useCache="true">         第三步，此处
        select * from user where  id=#{uid};
    </select>

    <!--更新用户信息-->
    <select id="updateUser" parameterType="user">
        update user set username=#{username},address=#{address} where id=#{id}
    </select>
</mapper>
```

```
SecondLevelCacheTest
```

```java
 /**
     * 测试二级缓存
     */
    @Test
    public void testFirstLevelCache(){
        SqlSession sqlSession1 = factory.openSession();
        IUserDao dao1 = sqlSession1.getMapper(IUserDao.class);
        User user1 = dao1.findById(41);
        System.out.println(user1);
        sqlSession1.close();//一级缓存消失

        SqlSession sqlSession2 = factory.openSession();
        IUserDao dao2 = sqlSession2.getMapper(IUserDao.class);
        User user2 = dao2.findById(41);
        System.out.println(user2);
        sqlSession2.close();

        System.out.println(user1 == user2);
    }
```

备注user一定要implements Serializable，否则会报错Error serializing object

即，给实体类实现java.io.Serializable接口

### 09 mybatis注解开发的环境搭建

day04_eesy_day03annotation_mybatis

引入pom.xml

创建User、IUserDao、SqlMapConfig.xml

导入jdbcConfig.properties、log4j.properties

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <!--引入外部配置文件-->
    <properties resource="jdbcConfig.properties"></properties>
    <!--配置别名-->
    <typeAliases>
        <package name="com.itheima.domain"/>
    </typeAliases>

    <!--配置环境-->
    <environments default="mysql">
        <environment id="mysql">
            <transactionManager type="jdbc"></transactionManager>
            <dataSource type="POOLED">
                <property name="driver" value="${jdbc.driver}"/>
                <property name="url" value="${jdbc.url}"/>
                <property name="username" value="${jdbc.username}"/>
                <property name="password" value="${jdbc.password}"/>
            </dataSource>
        </environment>
    </environments>
    <!--指定带有注解的dao接口所在位置-->
    <mappers>
        <package name="com.itheima.dao"/>
    </mappers>
</configuration>
```

添加注解

```java
package com.itheima.dao;

import com.itheima.domain.User;
import org.apache.ibatis.annotations.Select;

import java.util.List;

/**
 * 在MyBatis中，针对CRUD一共有四个注解
 * @Select @Insert @Update @Delete
 */
public interface IUserDao {

    /**
     * 查询所有用户
     * @return
     */
    @Select("select * from user")
    List<User> findAll();
}

```

### 10_mybatis注解开发测试和使用注意事项

注意：采用注解开发的时候，在同一个dao下不能存在xml，统一用注解就用注解，用xml开发就用xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <!--引入外部配置文件-->
    <properties resource="jdbcConfig.properties"></properties>
    <!--配置别名-->
    <typeAliases>
        <package name="com.itheima.domain"/>
    </typeAliases>

    <!--配置环境-->
    <environments default="mysql">
        <environment id="mysql">
            <transactionManager type="jdbc"></transactionManager>
            <dataSource type="POOLED">
                <property name="driver" value="${jdbc.driver}"/>
                <property name="url" value="${jdbc.url}"/>
                <property name="username" value="${jdbc.username}"/>
                <property name="password" value="${jdbc.password}"/>
            </dataSource>
        </environment>
    </environments>
    <!--指定带有注解的dao接口所在位置-->
    <mappers>
        <!--<package name="com.itheima.dao"/> 有注解用注解，没有注解用xml 此配置无效，有注解时只能移走IUserDao.xml-->
        <!--<mapper class="com.itheima.dao.IUserDao"></mapper>-->
        <package name="com.itheima.dao"/>    用注解时应该用<package>
        <!--<mapper resource="com/itheima/dao/IUserDao.xml"></mapper>  xml配置-->
    </mappers>
</configuration>
```

test

```java
    public static void main(String[] args) throws IOException {
        //1.获取字节输入流
        InputStream in = Resources.getResourceAsStream("SqlMapConfig.xml");
        //2.根据字节输入流构建SQLSessionFactory
        SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in);
        //3.根据SqlSessionFactory生产一个SQLSession
        SqlSession session = factory.openSession();
        //4.使用SQLSession获取sao的代理对象
        IUserDao userDao = session.getMapper(IUserDao.class);
        //5.执行dao的方法
        List<User> users = userDao.findAll();
        for (User user : users) {
            System.out.println(user);
        }
        //6.释放资源
        session.close();
        in.close();
    }
```

### 12 mybatis注解开发CRUD的其他操作

IUserDao

```java
package com.itheima.dao;

import com.itheima.domain.User;
import org.apache.ibatis.annotations.Delete;
import org.apache.ibatis.annotations.Insert;
import org.apache.ibatis.annotations.Select;
import org.apache.ibatis.annotations.Update;

import java.util.List;

/**
 * 在MyBatis中，针对CRUD一共有四个注解
 * @Select @Insert @Update @Delete
 */
public interface IUserDao {

    /**
     * 查询所有用户
     * @return
     */
    @Select("select * from user")
    List<User> findAll();

    /**
     * 保存用户
     * @param user
     */
    @Insert("insert into user(username,address,sex,birthday)values(#{username},#{address},#{sex},#{birthday})")
    void saveUser(User user);

    /**
     * 更新用户
     * @param user
     */
    @Update("update user set username=#{username},sex=#{sex},birthday=#{birthday},address=#{address} where id=#{id}")
    void updateUser(User user);

    /**
     * 删除用户
     * @param userId
     */
    @Delete("delete from user where id = #{id}")
    void deleteUser(Integer userId);

    /**
     * 根据id查询用户
     * @param userId
     * @return
     */
    @Select("select * from user where id = #{id}")
    User findById(Integer userId);

    /**
     * 根据用户名称模糊查询
     * @param userName
     * @return
     */
//    @Select("select * from user where username like '%${value}%'") 
    @Select("select * from user where username like #{username}")	 参数占位符
    List<User> findUserByName(String userName);

    /**
     *  查询总用户数量
     * @param
     * @return
     */
    @Select("select count(*) from user")
    int findTotalUser();

    /**
     * 查询上一个插入的id
     * @return
     */
    @Select("select last_insert_id()")
    int findLastId();
}

```

AnnotationCRUDTest

```java
package com.itheima.test;

import com.itheima.dao.IUserDao;
import com.itheima.domain.User;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import java.io.InputStream;
import java.util.Date;
import java.util.List;

/**
 * 测试mybatis的crud操作
 */
public class AnnotationCRUDTest {
    private InputStream in;
    private SqlSessionFactory factory;
    private SqlSession session;
    private IUserDao userDao;

    @Before
    public  void init()throws Exception{
        in = Resources.getResourceAsStream("SqlMapConfig.xml");
        factory = new SqlSessionFactoryBuilder().build(in);
        session = factory.openSession();
        userDao = session.getMapper(IUserDao.class);
    }

    @After
    public  void destroy()throws  Exception{
        session.commit();
        session.close();
        in.close();
    }


    @Test
    public void testSave(){
        User user = new User();
        user.setUsername("mybatis annotation");
        user.setAddress("北京市昌平区");
        user.setSex("男");
        user.setBirthday(new Date());

        userDao.saveUser(user);
    }

    @Test
    public void testUpdate(){
        User user = new User();
        user.setId(58);
        user.setUsername("mybatis annotation update");
        user.setAddress("北京市海淀区");
        user.setSex("男");
        user.setBirthday(new Date());

        userDao.updateUser(user);
    }


    @Test
    public void testDelete(){
        userDao.deleteUser(56);
    }

    @Test
    public void testfindById(){
        User user = userDao.findById(58);
        System.out.println(user);
    }

    @Test
    public void testFindByUserName(){
//        List<User> users = userDao.findUserByName("王");
        List<User> users = userDao.findUserByName("%王%");
        for (User user : users) {
            System.out.println(user);
        }
    }

    @Test
    public void testFindTotalUser(){
        int total = userDao.findTotalUser();
        System.out.println(total);
    }

    @Test                                这里写的不太对，勉强能看，具体参考xml使用
	public void testfindLastId(){
        User user = new User();
        user.setUsername("mybatis last insertid");
        user.setAddress("北京市东城区");
        user.setSex("男");
        user.setBirthday(new Date());

        System.out.println("保存操作前" + user);

        //5.使用保存方法
        userDao.saveUser(user);

        int lastId = userDao.findLastId();
        System.out.println(lastId);//61
    }
}
 
```

### 13_mybatis注解建立实体类属性和数据库表中列的对应关系

项目day04_eesy_01annoOne2Many

```java
package com.itheima.dao;

import com.itheima.domain.User;
import org.apache.ibatis.annotations.*;

import java.util.List;

/**
 * 在MyBatis中，针对CRUD一共有四个注解
 * @Select @Insert @Update @Delete
 */
public interface IUserDao {

    /**
     * 查询所有用户
     * @return
     */
    @Select("select * from user")
    @Results(id = "userMap",value = {                                      //此处    支持id，可写多个
            @Result(id=true,column="id",property = "userId"),
            @Result(column="username",property = "userName"),
            @Result(column="address",property = "userAddress"),
            @Result(column="sex",property = "userSex"),
            @Result(column="brithday",property = "userBirthday"),
    })
    List<User> findAll();

    /**
     * 根据id查询用户
     * @param userId
     * @return
     */
    @Select("select * from user where id = #{id}")
    @ResultMap(value = {"userMap"})                                        //此处  标准写法
    User findById(Integer userId);

    /**
     * 根据用户名称模糊查询
     * @param userName
     * @return
     */
    @Select("select * from user where username like #{username}")
    @ResultMap("userMap")													//如果只有一个，可以简写
    List<User> findUserByName(String userName);

}

```

test

```java
package com.itheima.test;

import com.itheima.dao.IUserDao;
import com.itheima.domain.User;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import java.io.InputStream;
import java.util.Date;
import java.util.List;

/**
 * 测试mybatis的crud操作
 */
public class AnnotationCRUDTest {
    private InputStream in;
    private SqlSessionFactory factory;
    private SqlSession session;
    private IUserDao userDao;

    @Before
    public  void init()throws Exception{
        in = Resources.getResourceAsStream("SqlMapConfig.xml");
        factory = new SqlSessionFactoryBuilder().build(in);
        session = factory.openSession();
        userDao = session.getMapper(IUserDao.class);
    }

    @After
    public  void destroy()throws  Exception{
        session.commit();
        session.close();
        in.close();
    }

    @Test
    public void testFindAll(){
        List<User> users = userDao.findAll();
        for (User user : users) {
            System.out.println(user);
        }
    }

    @Test
    public void testfindById(){
        User user = userDao.findById(58);
        System.out.println(user);
    }

    @Test
    public void testFindByUserName(){
        List<User> users = userDao.findUserByName("%王%");
        for (User user : users) {
            System.out.println(user);
        }
    }

}
 
```

### 14_mybatis注解开发一对一的查询配置

创建Account，增加user属性

```java
package com.itheima.domain;

import java.io.Serializable;

public class Account implements Serializable {
    private Integer id;
    private Integer uid;
    private double money;

    //多对一（mybatis中称之为一对一）的映射，一个账户只能属于一个用户               此处
    private User user;

    public User getUser() {
        return user;
    }

    public void setUser(User user) {
        this.user = user;
    }

   //其它Getter，Setter,toString已省略
}

```

新增IAccountDao，，使用@One      立即加载      这里是一对一

```java
package com.itheima.dao;

import com.itheima.domain.Account;
import org.apache.ibatis.annotations.One;
import org.apache.ibatis.annotations.Result;
import org.apache.ibatis.annotations.Results;
import org.apache.ibatis.annotations.Select;
import org.apache.ibatis.mapping.FetchType;

import java.util.List;

public interface IAccountDao {
    /**
     * 查询所有账户，并且获取每个账户所属的用户信息
     * @return
     */
    @Select("select * from account")
    @Results(id = "accountMap",value = {
            @Result(id = true,column = "id",property = "id"),
            @Result(column = "uid",property = "uid"),
            @Result(column = "money",property = "money"),
            @Result(property = "user",column = "uid",one = @One(select = "com.itheima.dao.IUserDao.findById",fetchType = FetchType.EAGER))
    })
    List<Account> findAll();
}

```

IUserDao     全限定类名加上方法名

```java
    /**
     * 根据id查询用户
     * @param userId
     * @return
     */
    @Select("select * from user where id = #{id}")                              //此处
    @ResultMap(value = {"userMap"})												//此处
    User findById(Integer userId);												//此处
```

测试

```java
    @Test
    public void testFindAll(){
        List<Account> accounts = accountDao.findAll();
        for (Account account : accounts) {
            System.out.printf("---每个账户的信息---");
            System.out.println(account);
            System.out.println(account.getUser());
        }
    }
```

### 15_Mybatis注解开发一对多的查询配置

创建User，增加List<Account>属性

```java
private List<Account> accounts;
```

 IAccountDao新增方法

```java
/**
     * 根据用户id查询账户信息
     * @param uid
     * @return
     */
    @Select("select * from account where uid=#{userId}")
    List<Account> findAccountByUid(Integer uid);
```

IUserDao   使用延迟加载，这里是一对多

```java
package com.itheima.dao;

/**
 * 在MyBatis中，针对CRUD一共有四个注解
 *
 * @Select @Insert @Update @Delete
 */
public interface IUserDao {

    /**
     * 查询所有用户
     *
     * @return
     */
    @Select("select * from user")
    @Results(id = "userMap", value = {
            @Result(id = true, column = "id", property = "userId"),
            @Result(column = "username", property = "userName"),
            @Result(column = "address", property = "userAddress"),
            @Result(column = "sex", property = "userSex"),
            @Result(column = "birthday", property = "userBirthday"),
            @Result(property = "accounts", column = "id",
                    many = @Many(select = "com.itheima.dao.IAccountDao.findAccountByUid",
                            fetchType = FetchType.LAZY))
    })
    List<User> findAll();

   //其余无关方法已省略

}

```

测试AnnotationCRUDTest

```java
@Test
    public void testFindAll(){
        List<User> users = userDao.findAll();
        for (User user : users) {
            System.out.println("---每个用户的信息---");
            System.out.println(user);
            System.out.println(user.getAccounts());
        }
    }
```

### 16_mybatis注解开发使用二级缓存

SqlMapConfig.xml

```xml
    <!--配置开启二级缓存-->
    <settings>
        <setting name="cacheEnabled" value="true"/>
    </settings>
```

IUserDao配置@CacheNamespace属性blocking = true

![image-20210823172603504](C:/Users/Murphy/Pictures/image-20210823172603504.png)

测试SecondLevelCacheTest

```java
package com.itheima.test;

import com.itheima.dao.IUserDao;
import com.itheima.domain.User;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import java.io.InputStream;

public class SecondLevelCacheTest {
    private InputStream in;
    private SqlSessionFactory factory;

    @Before
    public  void init()throws Exception{
        in = Resources.getResourceAsStream("SqlMapConfig.xml");
        factory = new SqlSessionFactoryBuilder().build(in);
    }

    @After
    public  void destroy()throws  Exception{

        in.close();
    }

    @Test
    public void testfindOne(){
        SqlSession session = factory.openSession();
        IUserDao userDao = session.getMapper(IUserDao.class);
        User user = userDao.findById(58);
        System.out.println(user);

        session.close();//释放一级缓存

        SqlSession session1 = factory.openSession();//再次打开session

        IUserDao userDao1 = session1.getMapper(IUserDao.class);
        User user1 = userDao1.findById(58);
        System.out.println(user1);

        session1.close();
    }
}

```

## 业务层:Spring

### 第一部分

1.1.1 spring是什么

```
Spring是分层的Java SE/EE应用 full-stack轻量级开源框架，以IoC（Inverse Of Control：反转控制）和AOP（Aspect Oriented Programming：面向切面编程）为内核，提供了展现层Spring MVC和持久层Spring JDBC以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java EE企业应用开源框架。
Spring Framework
```

------------------------------------

### 01_spring课程四天安排

```
第一天：spring框架的概述以及spring中基于XML的IOC配置
第二天：spring中基于注解的IOC和ioc的案例
第三天：spring中的aop和基于XML以及注解的AOP配置
第四天：spring中的JdbcTemlate以及Spring事务控制
```

### 02今日课程内容介绍

```
1、spring的概述
		spring是什么
		spring的两大核心
		spring的发展历程和优势
		spring体系结构
2、程序的耦合及解耦
		曾经案例中问题
		工厂模式解耦
3、I0C概念和spring中的I0C
		spring中基于XML的IOC环境搭建
4、依赖注入（Dependency Injection）
```

![三层架构](C:/Users/Murphy/Pictures/三层架构.png)

### 05_spring的优势

```
方便解耦，简化开发（第一天，第二天）
		通过Spring提供的IoC容器，可以将对象间的依赖关系交由Spring进行控制，避免硬编码所造成的过度程序耦合。用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。
AOP编程的支持(第三天)
		通过Spring的AOP功能，方便进行面向切面的编程，许多不容易用传统OOP实现的功能可以通过AOP轻松应付。
声明式事务的支持（第四天配置方式）
		可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活的进行事务的管理，提高开发效率和质量。
方便程序的测试（第二天）
		可以用非容器依赖的编程方式进行几乎所有的测试工作，测试不再是昂贵的操作，而是随手可做的事情。
方便集成各种优秀框架（第三天）
		Spring可以降低各种框架的使用难度，提供了对各种优秀框架（Struts、Hibernate、Hessian、Quartz等）的直接支持。
降低JavaEE API的使用难度（第四天）
		Spring对JavaEE API（如JDBC、JavaMail、远程调用等）进行了薄薄的封装层，使这些API的使用难度大为降低。
Java源码是经典学习范例（源码）
		Spring的源代码设计精妙、结构清晰、匠心独用，处处体现着大师对Java设计模式灵活运用以及对Java技术的高深造诣。它的源代码无意是Java技术的最佳实践的范例。
```

### 06_spring的体系结构

```
docs    api
lib     jar包
schema  约束
Core Container   核心容器，所有运行都依赖
```

![spring-overview](C:/Users/Murphy/Pictures/spring-overview.png)

### 07编写jdbc的工程代码用于分析

创建maven项目        day01_eesy_01jdbc

添加pom依赖

```xml
<dependencies>
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>5.1.6</version>
        </dependency>
    </dependencies>
```

创建类,一个简单的jdbc

```java
package com.itheima.jdbc;

import java.sql.*;

/**
 * 程序的耦合
 */
public class JdbcDemo1 {
    public static void main(String[] args) throws SQLException {
        //1.注册驱动
        DriverManager.registerDriver(new com.mysql.jdbc.Driver());
        //2.获取连接
        Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/eesy","root","123456");
        //3.后去操作数据库的预处理对象
        PreparedStatement ps = conn.prepareStatement("select * from account");
        //4.执行SQL，得到结果集
        ResultSet rs = ps.executeQuery();
        //5.遍历结果集
        while (rs.next()){
            System.out.println(rs.getString("name"));
        };
        //6.释放资源
        rs.close();
        ps.close();
        conn.close();
    }
}

```

### 08编译期依赖

依赖mysql	驱动，即程序的耦合

### 09程序的耦合和解耦的思路分析

```
 程序的耦合
       耦合：程序间的依赖关系
       包括：
           类之间的依赖
           方法间的依赖
     	解耦：降低程序间的依赖关系
     	实际开发中：
          应该做到：编译期不依赖，运行时才依赖。
```

```java
package com.itheima.jdbc;

import java.sql.*;

/**
 * 程序的耦合
 *      耦合：程序间的依赖关系
 *      包括：
 *          类之间的依赖
 *          方法间的依赖
 *     实际开发中：
 *          应该做到：编译期不依赖，运行时才依赖。
 *     解耦的思路：
 *          第一步：使用反射来创建对象，而避免使用new关键字。
 *          第二步：通过读取配置文件来获取要创建的对象全限定类名
 */
public class JdbcDemo1 {
    public static void main(String[] args) throws SQLException, ClassNotFoundException {
        //1.注册驱动
        //DriverManager.registerDriver(new com.mysql.jdbc.Driver());
        Class.forName("com.mysql.jdbc.Driver");//全限定类名，只是字符串。不再依赖某个具体的驱动类，编译可以通过。缺点，写死，不方便
        //2.获取连接
        Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/eesy","root","123456");
        //3.后去操作数据库的预处理对象
        PreparedStatement ps = conn.prepareStatement("select * from account");
        //4.执行SQL，得到结果集
        ResultSet rs = ps.executeQuery();
        //5.遍历结果集
        while (rs.next()){
            System.out.println(rs.getString("name"));
        };
        //6.释放资源
        rs.close();
        ps.close();
        conn.close();
    }
}

```

### 10曾经代码中的问题分析

创建新工程     day01_eesy_02factory

耦合过高，依赖很强；

### 11编写工厂类和配置文件

```
一个创建Bean对象的工厂

Bean：在计算机英语中，有可重用组件的含义。
JavaBean：用java语言编写的可重用组件。
		javabean >实体类
		
		它就是创建我们的Service和dao对象的
		
		第一个需要一个配置文件来配置service和dao
			配置的内容：唯一标识=全限定类名（key=value）
		第二个通过读取配置文件中配置的内容，反射创建对象
		
		配置文件可以是xml也可以是properties
```

bean.properties

```
accoutService=com.itheima.service.impl.AccountServiceImpl
accountDao=com.itheima.dao.impl.AccountDaoImpl
```

### 12工厂模式解耦

此处忽略

### 13分析工厂模式中的问题并改造

```
改成单例
```



![无标题](C:/Users/Murphy/Pictures/无标题-1629814113691.png)

### 14工厂模式解耦的升级版

单例

### 15ioc的概念和作用

```
读取配置文件，创建和获取三层对象的类就是工厂。
原来： 我们在获取对象时，都是采用new的方式。是主动的。
现在： 我们获取对象时，同时跟工厂要，有工厂为我们查找或者创建对象。是被动的。
这种被动接收的方式获取对象的思想就是控制反转，它是spring框架的核心之一。
明确ioc的作用： 削减计算机程序的耦合(解除我们代码中的依赖关系)。     只能降低，不能消除依赖
```

![ioc](C:/Users/Murphy/Pictures/ioc.png)

### 16_spring中的loc前期准备



### 17_spring基于XML的IOC环境搭建和入门

创建maven工程，引入pom依赖             day01_eesy_03spring

```xml
<dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context</artifactId>
        <version>5.0.2.RELEASE</version>
</dependency>
```

resources文件夹下创建bean.xml后续有固定写法，只是这里叫bean

使用之前写的接口

引入约束，添加bean标签

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">
    <!--把对象的创建交给spring来管理-->
    <bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"></bean>
    
    <bean id="accountDao" class="com.itheima.dao.impl.AccountDaoImpl"></bean>
</beans>
```

进行测试

```java
package com.itheima.ui;

import com.itheima.dao.IAccountDao;
import com.itheima.service.IAccountService;
import com.itheima.service.impl.AccountServiceImpl;
import javafx.application.Application;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

/**
 * 模拟一个表现层，用于调用业务层
 */
public class Client {
    /**
     * 获取spring容器的Ioc核心容器，并根据id获取对象
     * @param args
     */
    public static void main(String[] args) {
        //1、获取核心容器对象
        ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");
        //2.根据id获取bean对象,两种方式，一种是Object类型强转，一种是传递字节码强转
        IAccountService as = (IAccountService)ac.getBean("accountService");
        IAccountDao adao = (IAccountDao) ac.getBean("accountDao",IAccountDao.class);

        System.out.println(as);
        System.out.println(adao);

        //as.saveAccount();
    }
}

```

### 18_ApplicationContext的三个实现类

```
 ApplicationContext的三个常用实现类：
     *      ClassPathXmlApplicationContext：它可以加载类路径下的配置文件，要求配置文件必须在类路径下。不在的话，加载不了
     *      FileSystemApplicationContext：它可以加载磁盘任意路径下的配置文件（必须有访问权限）
     *      AnnotationConfigApplicationContext：它是用于读取注解创建容器的，是明天的内容
```

```java
package com.itheima.ui;

import com.itheima.dao.IAccountDao;
import com.itheima.service.IAccountService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.FileSystemXmlApplicationContext;

/**
 * 模拟一个表现层，用于调用业务层
 */
public class Client {
    /**
     * 获取spring容器的Ioc核心容器，并根据id获取对象
     *
     * ApplicationContext的三个常用实现类：
     *      ClassPathXmlApplicationContext：它可以加载类路径下的配置文件，要求配置文件必须在类路径下。不在的话，加载不了
     *      FileSystemApplicationContext：它可以加载磁盘任意路径下的配置文件（必须有访问权限）
     *      AnnotationConfigApplicationContext：它是用于读取注解创建容器的，是明天的内容
     * @param args
     */
    public static void main(String[] args) {
        //1、获取核心容器对象
        //ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");
        ApplicationContext ac = new FileSystemXmlApplicationContext("C:\\Users\\Murphy\\Desktop\\bean.xml");
        //2.根据id获取bean对象,两种方式，一种是Object类型强转，一种是传递字节码强转
        IAccountService as = (IAccountService)ac.getBean("accountService");
        IAccountDao adao = (IAccountDao) ac.getBean("accountDao",IAccountDao.class);

        System.out.println(as);
        System.out.println(adao);

        //as.saveAccount();
    }
}

```

### 19_BeanFactory和ApplicationContext的区别

```
* 核心容器的两个接口引发出的问题： 单例对象适用     采用此接口
     *  ApplicationContext：
     *      它在构建核心容器时，创建对象的策略是采用立即加载的方式。也就是说，只要一读取完配置文件马上就创建文件中配置的对象。
     *  BeanFactory：    多例对象适用
     *      它在构建核心容器时，创建对象的策略是采用延迟加载的方式。也就是说，什么时候根据id获取对象，什么时候才真正的创建对象。
```

```java
package com.itheima.ui;

import com.itheima.service.IAccountService;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.xml.XmlBeanFactory;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;

/**
 * 模拟一个表现层，用于调用业务层
 */
public class Client {
    /**
     * 获取spring容器的Ioc核心容器，并根据id获取对象
     *
     * ApplicationContext的三个常用实现类：
     *      ClassPathXmlApplicationContext：它可以加载类路径下的配置文件，要求配置文件必须在类路径下。不在的话，加载不了
     *      FileSystemApplicationContext：它可以加载磁盘任意路径下的配置文件（必须有访问权限）
     *      AnnotationConfigApplicationContext：它是用于读取注解创建容器的，是明天的内容
     *
     * 核心容器的两个接口引发出的问题： 单例对象适用     采用此接口
     *  ApplicationContext：
     *      它在构建核心容器时，创建对象的策略是采用立即加载的方式。也就是说，只要一读取完配置文件马上就创建文件中配置的对象。
     *  BeanFactory：    多例对象适用
     *      它在构建核心容器时，创建对象的策略是采用延迟加载的方式。也就是说，什么时候根据id获取对象，什么时候才真正的创建对象。
     * @param args
     */
    public static void main(String[] args) {
        //1、获取核心容器对象
        ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");
        //ApplicationContext ac = new FileSystemXmlApplicationContext("C:\\Users\\Murphy\\Desktop\\bean.xml");
        //2.根据id获取bean对象,两种方式，一种是Object类型强转，一种是传递字节码强转
        //IAccountService as = (IAccountService)ac.getBean("accountService");
        //IAccountDao adao = (IAccountDao) ac.getBean("accountDao",IAccountDao.class);

        //System.out.println(as);
        //System.out.println(adao);

        //as.saveAccount();

        //---------BeanFactory----------
        Resource resource = new ClassPathResource("bean.xml");
        BeanFactory factory = new XmlBeanFactory(resource);
        IAccountService as = (IAccountService) factory.getBean("AccountService");
        System.out.println(as);
    }
}

```

### 20_spring中bean的细节之三种创建Bean对象的方式

创建新项目      day01_eesy_04bean

注意：后两种主要用于jar包中的类，这里主要是模拟	

第一种，构造方式的class

需要先创建接口，再创建类

接口IAccountService

```java
package com.itheima.service;

/**
 * 业务层的接口
 */
public interface IAccountService {
    /**
     * 模拟保存账户
     */
    void saveAccount();
}

```

实现类AccountServiceImpl

```java
package com.itheima.service.impl;

import com.itheima.service.IAccountService;

/**
 * 账户的业务层实现类
 */
public class AccountServiceImpl implements IAccountService {

    public AccountServiceImpl() {
        System.out.println("对象创建了");
    }
    @Override
    public void saveAccount() {
        System.out.println("service中的saveAccount方法执行了");
    }
}

```

第二种

创建普通类InstanceFactory

```java
package com.itheima.factory;

import com.itheima.service.IAccountService;
import com.itheima.service.impl.AccountServiceImpl;

/**
 * 模拟一个工厂类（该类可能是存在于jar包中的，我们无法通过修改源码的方式来提供默认构造函数）
 */
public class InstanceFactory {
    public IAccountService getAccountService() {
        return new AccountServiceImpl();
    }
}

```

第三种

创建类StaticFactory中静态方法

```java
package com.itheima.factory;

import com.itheima.service.IAccountService;
import com.itheima.service.impl.AccountServiceImpl;

/**
 * 模拟一个工厂类（该类可能是存在于jar包中的，我们无法通过修改源码的方式来提供默认构造函数）
 */
public class StaticFactory {
    public static IAccountService getAccountService() {
        return new AccountServiceImpl();
    }
}

```

对应bean.xml中的写法

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">
    <!--把对象的创建交给spring来管理-->
    <!--spring对bean的管理细节
        1.创建bean的三种方式
        2.bean对象的作用范围
        3.bean独享的生命周期
    -->
    <!--创建Bean的三种方式-->
    <!--第一种方式：使用默认构造函数创建。
        在spring的配置文件中使用bean标签，配以id和class属性之后，且没有其他属性和标签时。
        采用的就是默认构造函数创建bean对象，此时如果类中没有默认构造函数，则对象无法创建。
    -->
    <!--<bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"></bean>-->

    <!--第二种方式：使用普通工厂中的方法创建对象（使用某个类中的方法创建对象，并存入spring容器 ）
    -->
    <!--<bean id="instanceFactory" class="com.itheima.factory.InstanceFactory"></bean>
    <bean id="accountService" factory-bean="instanceFactory" factory-method="getAccountService"></bean>-->

    <!--第三种方式：使用静态工厂中的静态方法创建对象（使用某个类中的静态方法创建对象，并存入spring容器）-->
    <bean id="accountService" class="com.itheima.factory.StaticFactory" factory-method="getAccountService"></bean>
</beans>
```

测试

```java
package com.itheima.ui;

import com.itheima.service.IAccountService;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.xml.XmlBeanFactory;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;

/**
 * 模拟一个表现层，用于调用业务层
 */
public class Client {
    /**
     * @param args
     */
    public static void main(String[] args) {
        //1、获取核心容器对象
        ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");
        //2.根据id获取bean对象,两种方式，一种是Object类型强转，一种是传递字节码强转
        IAccountService as = (IAccountService)ac.getBean("accountService");

        as.saveAccount();

    }
}

```

### 21_spring中bean的细节之作用范围

![全局session](C:/Users/Murphy/Pictures/全局session.png)

```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">
    <!--把对象的创建交给spring来管理-->
    <!--spring对bean的管理细节
        1.创建bean的三种方式
        2.bean对象的作用范围
        3.bean独享的生命周期
    -->

    <!--bean的作用范围调整
        bean标签的scope属性：
            作用:用于指定bean的作用范围
            取值：常用的就是单例的和多例的
                singleton:单例（默认值）
                prototype:多例的
                request:作用于web应用的请求范围
                session:作用于web应用的会话范围
                global-session:作用于集群环境的会话范围（全局会话范围），当不是集群环境时，它就是session
    -->
    <bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl" scope="prototype"></bean>
</beans>
```

### 22_spring中bean的细节之生命周期

新建两个方法            这里是讲解周期，测试

```java
package com.itheima.service.impl;

import com.itheima.service.IAccountService;

/**
 * 账户的业务层实现类
 */
public class AccountServiceImpl implements IAccountService {

    public AccountServiceImpl() {
        System.out.println("对象创建了");
    }
    @Override
    public void saveAccount() {
        System.out.println("service中的saveAccount方法执行了");
    }

    public void init() {
        System.out.println("对象初始化了");
    }

    public void destory() {
        System.out.println("对象销毁了了");
    }
}

```

bean.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">
        
    <!--bean对象的生命周期
        单例对象
            出生：当容器创建时，对象出生
            活着：只要容器还在，对象一直活着（立即）
            死亡：容器销毁，对象消亡
            总结：单例对象的生命周期和容器相同
        多例对象
            出生：当我们使用对象时，spring框架为我们创建（延迟）
            活着：对象只要是在使用过程中就一直活着
            死亡：当对象长时间不用且没有别的对象引用时，由Java的垃圾回收器回收
    -->
    <!--<bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"
          scope="singleton" init-method="init" destroy-method="destory"></bean>      单例-->

    <bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"
          scope="prototype" init-method="init" destroy-method="destory"></bean>
</beans>
```

测试

```java
package com.itheima.ui;

import com.itheima.service.IAccountService;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.xml.XmlBeanFactory;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;

/**
 * 模拟一个表现层，用于调用业务层
 */
public class Client {
    /**
     * @param args
     */
    public static void main(String[] args) {
        //1、获取核心容器对象
        //ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");
        ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");//多态，子类才能看见close，父类不能看见
        //2.根据id获取bean对象,两种方式，一种是Object类型强转，一种是传递字节码强转
        IAccountService as = (IAccountService)ac.getBean("accountService");

        as.saveAccount();

        //手动关闭容器
        ac.close();
    }
}

```

### 23_spring的依赖注入

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">
    <!--spring中的依赖注入
        依赖注入：
        Dependency Injection
        IOC的作用：
            降低程序间的耦合（依赖关系）
        依赖关系的管理：
            以后都交给了spirng来维护
        在当前类需要用到其他类的对象，由spring来为我们提供，我们只需要在配置文件中说明
        依赖关系的维护：
            就称之为依赖注入。
        依赖注入：
            能注入的数据：有三类
                基本类型和String
                其他bean类型（在配置文件中或者注解配置过的bean）
                复杂类型/集合类型
            注入的方式：有三种
                第一种：使用构造函数提供
                第二种：使用set方法提供
                第三种：使用注解提供（明天的内容）
    -->
    <bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"></bean>
</beans>
```

### 24_构造函数注入

新增属性和参数构造方法           项目day01_eesy_05DI

```java
package com.itheima.service.impl;

import com.itheima.service.IAccountService;

import java.util.Date;

/**
 * 账户的业务层实现类
 */
public class AccountServiceImpl implements IAccountService {

    //如果是经常变化的数据，并不适用于注入的方式（关注数据类型）
    private String name;
    private Integer age;
    private Date birthday;

    public AccountServiceImpl(String name,Integer age,Date birthday){
        this.name = name;
        this.age = age;
        this.birthday = birthday;
    };

    @Override
    public void saveAccount() {
        System.out.println("service中的saveAccount方法执行了"+name+","+age+","+birthday);
    }

}

```

配置bean.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">
    <!--spring中的依赖注入
        依赖注入：
        Dependency Injection
        IOC的作用：
            降低程序间的耦合（依赖关系）
        依赖关系的管理：
            以后都交给了spirng来维护
        在当前类需要用到其他类的对象，由spring来为我们提供，我们只需要在配置文件中说明
        依赖关系的维护：
            就称之为依赖注入。
        依赖注入：
            能注入的数据：有三类
                基本类型和String
                其他bean类型（在配置文件中或者注解配置过的bean）
                复杂类型/集合类型
            注入的方式：有三种
                第一种：使用构造函数提供
                第二种：使用set方法提供
                第三种：使用注解提供（明天的内容）
    -->

    <!--构造函数注入
        使用的标签：constructor-arg
        标签出现的位置：bean标签的内部
        标签中的属性
            type:用于指定要注入的数据的数据类型，该数据类型也是构造函数中某个或某些参数的类型
            index:用于指定要注入的数据给构造函数中指定索引位置的参数赋值。参数索引的位置从0开始
            name:用于指定给构造函数中指定名称的参数赋值                       常用的
            ==================以上三个用于指定给构造函数中哪个参数赋值===============================
            value:用于提供基本类型和String类型的数据
            ref:用于指定其它的bean类型数据。它指的就是在spring的IOC核心容器中出现过的bean对象

        优势：
            在获取bean对象时，注入数据是必须的操作，否则对象无法创建成功。
        弊端：
            改变了bean对象的实例化方式，使我们在创建对象时，如果用不到这些数据，也必须提供
    -->
    <bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl">
        <constructor-arg name="name" value="泰斯特"></constructor-arg>
        <constructor-arg name="age" value="18"></constructor-arg>
        <constructor-arg name="birthday" ref="now"></constructor-arg>
    </bean>

    <!--配置一个日期对象     读取这个全限定类名，反射创建一个对象  并且存入spring核心容器中   我们可以通过nowid来把这个对象取出来    -->
    <bean id="now" class="java.util.Date"></bean>
</beans>
```

测试

```java
package com.itheima.ui;

import com.itheima.service.IAccountService;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.xml.XmlBeanFactory;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;

/**
 * 模拟一个表现层，用于调用业务层
 */
public class Client {
    /**
     * @param args
     */
    public static void main(String[] args) {
        //1、获取核心容器对象
        ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");
        //2.根据id获取bean对象,两种方式，一种是Object类型强转，一种是传递字节码强转
        IAccountService as = (IAccountService)ac.getBean("accountService");

        as.saveAccount();

    }
}

```

### 25_set方法注入

新建实现类，增加get方法

```java
package com.itheima.service.impl;

import com.itheima.service.IAccountService;

import java.util.Date;

/**
 * 账户的业务层实现类
 */
public class AccountServiceImpl2 implements IAccountService {

    //如果是经常变化的数据，并不适用于注入的方式（关注数据类型）
    private String name;
    private Integer age;
    private Date birthday;

    public void setName(String name) {
        this.name = name;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public void setBirthday(Date birthday) {
        this.birthday = birthday;
    }

    @Override
    public void saveAccount() {
        System.out.println("service中的saveAccount方法执行了"+name+","+age+","+birthday);
    }

}

```

配置pom.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">
        
   

    <!--set方法注入                     更常用的方式
        涉及的标签：property
        出现的位置：bean标签的内部
        标签的属性
            name:用于指定注入时所调用的set方法名称
            value:用于提供基本类型和String类型的数据
            ref:用于指定其它的bean类型数据。它指的就是在spring的IOC核心容器中出现过的bean对象
        优势：
            创建对象时没有明确的限制，可以使用默认构造函数
        弊端：
            如果某个成员必须有值，则获取对象时，有可能set方法没有执行。
    -->
    <bean id="accountService2" class="com.itheima.service.impl.AccountServiceImpl2">
        <property name="name" value="TEST"></property>
        <property name="age" value="21"></property>
        <property name="birthday" ref="now"></property>
    </bean>
    
     <!--配置一个日期对象     读取这个全限定类名，反射创建一个对象  并且存入spring核心容器中   我们可以通过nowid来把这个对象取出来    -->
    <bean id="now" class="java.util.Date"></bean>
</beans>
```

测试

```java
package com.itheima.ui;

import com.itheima.service.IAccountService;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.xml.XmlBeanFactory;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;

/**
 * 模拟一个表现层，用于调用业务层
 */
public class Client {
    /**
     * @param args
     */
    public static void main(String[] args) {
        //1、获取核心容器对象
        ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");
        //2.根据id获取bean对象,两种方式，一种是Object类型强转，一种是传递字节码强转
        
        IAccountService as = (IAccountService)ac.getBean("accountService2");
        as.saveAccount();
    }
}
```

### 26注入集合数据

新建实现类，增加get方法

```java
package com.itheima.service.impl;

import com.itheima.service.IAccountService;

import java.io.Serializable;
import java.util.*;

/**
 * 账户的业务层实现类
 */
public class AccountServiceImpl3 implements IAccountService {

    private String[] myStrs;
    private List<String> myList;
    private Set<String> mySet;
    private Map<String,String> myMap;
    private Properties myProps;

    public void setMyStrs(String[] myStrs) {
        this.myStrs = myStrs;
    }

    public void setMyList(List<String> myList) {
        this.myList = myList;
    }

    public void setMySet(Set<String> mySet) {
        this.mySet = mySet;
    }

    public void setMyMap(Map<String, String> myMap) {
        this.myMap = myMap;
    }

    public void setMyProps(Properties myProps) {
        this.myProps = myProps;
    }

    @Override
    public void saveAccount() {
        System.out.println(Arrays.toString(myStrs));
        System.out.println(myList);
        System.out.println(mySet);
        System.out.println(myMap);
        System.out.println(myProps);
    }

}

```

pom.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!--复杂类型的注入/集合类型的注入
        用于给List结构集合注入的标签：
            list array set
        用于给Map结构集合注入的标签：
            map prop
        结构相同，标签可以互换          实际记住list结构和map结构就可以了
    -->
    <bean id="accountService3" class="com.itheima.service.impl.AccountServiceImpl3">
        <property name="myStrs">
            <array>
                <value>AAA</value>
                <value>BBB</value>
                <value>CCC</value>
            </array>
        </property>
        <property name="myList">
            <list>
                <value>AAA</value>
                <value>BBB</value>
                <value>CCC</value>
            </list>
        </property>
        <property name="mySet">
            <set>
                <value>AAA</value>
                <value>BBB</value>
                <value>CCC</value>
            </set>
        </property>
        <property name="myMap">
            <map>
                <entry key="testA" value="aaa"></entry>
                <entry key="testB">
                    <value>BBB</value>
                </entry>
            </map>
        </property>
        <property name="myProps">
            <props>
                <prop key="testC" >ccc</prop>
                <prop key="testD" >ddd</prop>
            </props>
        </property>
    </bean>
</beans>
```

测试

```java
package com.itheima.ui;

import com.itheima.service.IAccountService;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.xml.XmlBeanFactory;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;

/**
 * 模拟一个表现层，用于调用业务层
 */
public class Client {
    /**
     * @param args
     */
    public static void main(String[] args) {
        //1、获取核心容器对象
        ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");
        //2.根据id获取bean对象,两种方式，一种是Object类型强转，一种是传递字节码强转

        IAccountService as = (IAccountService)ac.getBean("accountService3");
        as.saveAccount();
    }
}

```

### ----------------------

### 第二部分

### 01今日课程内容介绍

```
1、spring中ioc的常用注解
2、案例使用xml方式和注解方式实现单表的CRUD操作
	持久层技术选择：dbutils
3、改造基于注解的ibc案例，使用纯注解的方式实现
	spring的一些新注解使用
4、spring和Junit整合
```

### 02_常用IOC注解按照作用分类

```
用于创建对象的
	他们的作用就和在XML配置文件中编写一个<bean>标签实现的功能是一样的
用于注入数据的
	他们的作用就和在xml配置文件中的bean标签中写一个<property>标签的作用是一样的
用于改变作用范围的
	他们的作用就和在bean标签中使用scope属性实现的功能是一样的
和生命周期相关
	他们的作用就和在bean标签中使用init-method和destroy-methode的作用是一样的
```

### 03用于创建的Component注解

​	项目    day02_eesy_01anno_ioc

创建pom.xml     这里用注解pom的约束和之前xml不同       xmlns:context

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd">

    <!--告知spring在创建容器时要扫描的包，配置所需要的标签不是在beans的约束中，而是一个名称为
    context名称空间和约束中-->

    <context:component-scan base-package="com.itheima"></context:component-scan>
</beans>
```

添加注解@Component("accountService")

```java
package com.itheima.service.impl;

import com.itheima.dao.IAccountDao;
import com.itheima.dao.impl.AccountDaoImpl;
import com.itheima.service.IAccountService;
import org.springframework.stereotype.Component;

/**
 * 账户的业务层实现类
 *
 * 曾经xml的配置
 * <bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"
 *         scope="“  init-method=""  destory-method="">
 *         <property name="" value="" / ref=""></property>
 * </bean>
 *
 * 用于创建对象的
 *      他们的作用就和在XML配置文件中编写一个<bean>标签实现的功能是一样的
 *      @Component:
 *          作用：用于把当前类对象存入spring容器中
 *          属性：
 *              value:用于指定bean的id。当我们不写时，它的默认值是当前类名，且首字母改小写。同理只有一个属性时，value可省略
 * 用于注入数据的
 *      他们的作用就和在XML配置文件中的bean标签中写一个<property>标签的作用是一样的
 * 用于改变作用范围的
 *      他们的作用就和在bean标签中使用scope属性实现的功能是一样的
 * 和生命周期相关
 *       他们的作用就和在bean标签中使用init-method和destory-method的作用是一样的
 */
@Component("accountService")
public class AccountServiceImpl implements IAccountService {

    private IAccountDao accountDao = new AccountDaoImpl();

    public AccountServiceImpl() {
        System.out.println("对象创建了");
    }
    @Override
    public void saveAccount() {
        accountDao.saveAccount();
    }
}

```

测试

```java
package com.itheima.ui;

import com.itheima.service.IAccountService;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.xml.XmlBeanFactory;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;

/**
 * 模拟一个表现层，用于调用业务层
 */
public class Client {
    /**
     * 获取spring容器的Ioc核心容器，并根据id获取对象
     *
     * @param args
     */
    public static void main(String[] args) {
        //1、获取核心容器对象
        ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");
        //2.根据id获取bean对象,两种方式，一种是Object类型强转，一种是传递字节码强转
        IAccountService as = (IAccountService)ac.getBean("accountService");
        System.out.println(as);
        //as.saveAccount();

    }
}

```

### 04_由Component衍生的注解

```java'
用于创建对象的
 *      他们的作用就和在XML配置文件中编写一个<bean>标签实现的功能是一样的
 *      Component:
 *          作用：用于把当前类对象存入spring容器中
 *          属性：
 *              value:用于指定bean的id。当我们不写时，它的默认值是当前类名，且首字母改小写。同理只有一个属性时，value可省略
 *      Controller：一般用在表现层
 *      Service：一般用于业务层
 *      Repository：一般用在持久层
 *      以上三个注解他们的作用和属性与Component是一模一样。
 *      他们三个是spring矿建为我们提供明确的三层使用的注解，使我们的三层对象更加清晰
```

持久层

```java
package com.itheima.dao.impl;

import com.itheima.dao.IAccountDao;
import org.springframework.stereotype.Repository;

/**
 * 账户的持久层实现类
 */
@Repository("AccountDao1")
public class AccountDaoImpl implements IAccountDao {
    @Override
    public void saveAccount() {
        System.out.println("保存了账户11111");
    }
}

```

业务层

```java
package com.itheima.service.impl;

import com.itheima.dao.IAccountDao;
import com.itheima.dao.impl.AccountDaoImpl;
import com.itheima.service.IAccountService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;
import org.springframework.stereotype.Service;

import javax.annotation.Resource;

/**
 * 账户的业务层实现类
 *
 * 曾经xml的配置
 * <bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"
 *         scope="“  init-method=""  destory-method="">
 *         <property name="" value="" / ref=""></property>
 * </bean>
 *
 * 用于创建对象的
 *      他们的作用就和在XML配置文件中编写一个<bean>标签实现的功能是一样的
 *      Component:
 *          作用：用于把当前类对象存入spring容器中
 *          属性：
 *              value:用于指定bean的id。当我们不写时，它的默认值是当前类名，且首字母改小写。同理只有一个属性时，value可省略
 *      Controller：一般用在表现层
 *      Service：一般用于业务层
 *      Repository：一般用在持久层
 *      以上三个注解他们的作用和属性与Component是一模一样。
 *      他们三个是spring矿建为我们提供明确的三层使用的注解，使我们的三层对象更加清晰
 * 用于注入数据的
 *      他们的作用就和在XML配置文件中的bean标签中写一个<property>标签的作用是一样的
 * 用于改变作用范围的
 *      他们的作用就和在bean标签中使用scope属性实现的功能是一样的
 * 和生命周期相关
 *       他们的作用就和在bean标签中使用init-method和destory-method的作用是一样的
 */
@Service("accountService")
public class AccountServiceImpl implements IAccountService {
    private IAccountDao accountDao;

    public AccountServiceImpl() {
        System.out.println("对象创建了");
    }
    @Override
    public void saveAccount() {
        accountDao.saveAccount();
    }
}

```

测试

```java
package com.itheima.ui;

import com.itheima.dao.IAccountDao;
import com.itheima.service.IAccountService;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.xml.XmlBeanFactory;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;

/**
 * 模拟一个表现层，用于调用业务层
 */
public class Client {
    /**
     * 获取spring容器的Ioc核心容器，并根据id获取对象
     *
     * @param args
     */
    public static void main(String[] args) {
        //1、获取核心容器对象
        ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");
        //2.根据id获取bean对象,两种方式，一种是Object类型强转，一种是传递字节码强转
        IAccountService as = (IAccountService)ac.getBean("accountService");
	    System.out.println(as);

        IAccountDao adao = (IAccountDao) ac.getBean("AccountDao");
        System.out.println(adao);

        //as.saveAccount();

    }
}

```

### 05自动按照类型注入

```
Autowired         即不用再写set方法
```

![自动按照类型注入](C:/Users/Murphy/Pictures/自动按照类型注入.png)

### 06用于注入数据的注解

```
用于注入数据的
 *      他们的作用就和在XML配置文件中的bean标签中写一个<property>标签的作用是一样的
 *      Autowired:
 *          作用：自动按照类型注入。只要容器中有唯一的一个bean对象类型和要注入的变量类型匹配，就可以注入成功
 *              如果ioc容器中没有任何bean的类型和要注入的变量类型匹配，则报错。
 *              如果ioc容器中有多个类型匹配时：(类名称和注解id一致可注入，但是这里应该借助于Qualifier)
 *          书写位置：
 *              可以是成员变量上，也可以是方法上
 *          细节：在使用注解注入时，set方法就不是必须的了。
 *      Qualifier：
 *          作用：在按照类中注入的基础之上再按照名称注入。它在给类成员注入时不能单独使用。但是在给方法参数注入时可以。
 *          属性：value：用于指定注入bean的id
 *      Resource
 *          作用：直接按照bean的id注入。它可以单独使用。
 *          属性：
 *              name：用于指定bean的id
 *      以上单个注解都只能注入其他bean类型的数据，而基本类型和String类型都无法使用上述注解实现。
 *      另外集合类型的注入只能通过xml来实现。
 *
 *      Value
 *          作用：用于注入基本类型和String类型的数据
 *          属性：
 *              value：用于指定数据的值。它可以使用spring中的SpEl（也就是spring中的el表达式）
 *                  SpEl的写法：${表达式}
```

持久层实现类

```java
package com.itheima.dao.impl;

import com.itheima.dao.IAccountDao;
import org.springframework.stereotype.Repository;

/**
 * 账户的持久层实现类
 */
@Repository("AccountDao1")
public class AccountDaoImpl implements IAccountDao {
    @Override
    public void saveAccount() {
        System.out.println("保存了账户11111");
    }
}

```

业务层实现类

```java
package com.itheima.service.impl;

import com.itheima.dao.IAccountDao;
import com.itheima.dao.impl.AccountDaoImpl;
import com.itheima.service.IAccountService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;
import org.springframework.stereotype.Service;

import javax.annotation.Resource;

/**
 * 账户的业务层实现类
 *
 * 曾经xml的配置
 * <bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"
 *         scope="“  init-method=""  destory-method="">
 *         <property name="" value="" / ref=""></property>
 * </bean>
 *
 * 用于注入数据的
 *      他们的作用就和在XML配置文件中的bean标签中写一个<property>标签的作用是一样的
 *      Autowired:
 *          作用：自动按照类型注入。只要容器中有唯一的一个bean对象类型和要注入的变量类型匹配，就可以注入成功
 *              如果ioc容器中没有任何bean的类型和要注入的变量类型匹配，则报错。
 *              如果ioc容器中有多个类型匹配时：(类名称和注解id一致可注入，但是这里应该借助于Qualifier)
 *          书写位置：
 *              可以是成员变量上，也可以是方法上
 *          细节：在使用注解注入时，set方法就不是必须的了。
 *      Qualifier：
 *          作用：在按照类中注入的基础之上再按照名称注入。它在给类成员注入时不能单独使用。但是在给方法参数注入时可以。
 *          属性：value：用于指定注入bean的id
 *      Resource
 *          作用：直接按照bean的id注入。它可以单独使用。
 *          属性：
 *              name：用于指定bean的id
 *      以上单个注解都只能注入其他bean类型的数据，而基本类型和String类型都无法使用上述注解实现。
 *      另外集合类型的注入只能通过xml来实现。
 *
 *      Value
 *          作用：用于注入基本类型和String类型的数据
 *          属性：
 *              value：用于指定数据的值。它可以使用spring中的SpEl（也就是spring中的el表达式）
 *                  SpEl的写法：${表达式}
 *
 * 用于改变作用范围的
 *      他们的作用就和在bean标签中使用scope属性实现的功能是一样的
 * 和生命周期相关
 *       他们的作用就和在bean标签中使用init-method和destory-method的作用是一样的
 */
@Service("accountService")
public class AccountServiceImpl implements IAccountService {

   /* @Autowired
    @Qualifier("AccountDao1")*/
    @Resource(name = "AccountDao2")
    private IAccountDao accountDao = null;

    public AccountServiceImpl() {
        System.out.println("对象创建了");
    }
    @Override
    public void saveAccount() {
        accountDao.saveAccount();
    }
}

```

测试

```java
package com.itheima.ui;

import com.itheima.dao.IAccountDao;
import com.itheima.service.IAccountService;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.xml.XmlBeanFactory;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;

/**
 * 模拟一个表现层，用于调用业务层
 */
public class Client {
    /**
     * 获取spring容器的Ioc核心容器，并根据id获取对象
     *
     * @param args
     */
    public static void main(String[] args) {
        //1、获取核心容器对象
        ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");
        //2.根据id获取bean对象,两种方式，一种是Object类型强转，一种是传递字节码强转
        IAccountService as = (IAccountService)ac.getBean("accountService");
//        System.out.println(as);
//
//        IAccountDao adao = (IAccountDao) ac.getBean("AccountDao");
//        System.out.println(adao);

        as.saveAccount();

    }
}

```

### 07改变作用范围以及和生命周期相关的注解

业务层实现类

```java
package com.itheima.service.impl;

import com.itheima.dao.IAccountDao;
import com.itheima.dao.impl.AccountDaoImpl;
import com.itheima.service.IAccountService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Component;
import org.springframework.stereotype.Service;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import javax.annotation.Resource;

/**
 * 账户的业务层实现类
 *
 * 曾经xml的配置
 * <bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"
 *         scope="“  init-method=""  destory-method="">
 *         <property name="" value="" / ref=""></property>
 * </bean>
 *
 * 用于创建对象的
 *      他们的作用就和在XML配置文件中编写一个<bean>标签实现的功能是一样的
 *      Component:
 *          作用：用于把当前类对象存入spring容器中
 *          属性：
 *              value:用于指定bean的id。当我们不写时，它的默认值是当前类名，且首字母改小写。同理只有一个属性时，value可省略
 *      Controller：一般用在表现层
 *      Service：一般用于业务层
 *      Repository：一般用在持久层
 *      以上三个注解他们的作用和属性与Component是一模一样。
 *      他们三个是spring矿建为我们提供明确的三层使用的注解，使我们的三层对象更加清晰
 * 用于注入数据的
 *      他们的作用就和在XML配置文件中的bean标签中写一个<property>标签的作用是一样的
 *      Autowired:
 *          作用：自动按照类型注入。只要容器中有唯一的一个bean对象类型和要注入的变量类型匹配，就可以注入成功
 *              如果ioc容器中没有任何bean的类型和要注入的变量类型匹配，则报错。
 *              如果ioc容器中有多个类型匹配时：(类名称和注解id一致可注入，但是这里应该借助于Qualifier)
 *          书写位置：
 *              可以是成员变量上，也可以是方法上
 *          细节：在使用注解注入时，set方法就不是必须的了。
 *      Qualifier：
 *          作用：在按照类中注入的基础之上再按照名称注入。它在给类成员注入时不能单独使用。但是在给方法参数注入时可以。
 *          属性：value：用于指定注入bean的id
 *      Resource
 *          作用：直接按照bean的id注入。它可以单独使用。
 *          属性：
 *              name：用于指定bean的id
 *      以上单个注解都只能注入其他bean类型的数据，而基本类型和String类型都无法使用上述注解实现。
 *      另外集合类型的注入只能通过xml来实现。
 *
 *      Value
 *          作用：用于注入基本类型和String类型的数据
 *          属性：
 *              value：用于指定数据的值。它可以使用spring中的SpEl（也就是spring中的el表达式）
 *                  SpEl的写法：${表达式}
 *
 * 用于改变作用范围的
 *      他们的作用就和在bean标签中使用scope属性实现的功能是一样的
 *      Scope
 *          作用：用于指定bean的作用范围
 *          属性：
 *              value：指定范围的取值。常用取值：singleton prototype
 * 和生命周期相关  了解
 *       他们的作用就和在bean标签中使用init-method和destory-method的作用是一样的
 *       PreDestroy
 *          作用:用于指定销毁方法
 *       PostConstruct
 *          作用:用于指定初始化方法
 */
@Service("accountService")
//@Scope("singleton")                               	    此处
public class AccountServiceImpl implements IAccountService {

   /* @Autowired
    @Qualifier("AccountDao1")*/
    @Resource(name = "AccountDao2")
    private IAccountDao accountDao = null;

    public AccountServiceImpl() {
        System.out.println("对象创建了");
    }
    @Override
    public void saveAccount() {
        accountDao.saveAccount();
    }

    @PostConstruct                                         //此处
    public void init() {
        System.out.println("初始化方法执行了");
    }
    @PreDestroy											   //此处
    public void destory() {
        System.out.println("销毁方法执行了");
    }
}

```

测试

```java
package com.itheima.ui;

import com.itheima.dao.IAccountDao;
import com.itheima.service.IAccountService;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.xml.XmlBeanFactory;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;

/**
 * 模拟一个表现层，用于调用业务层
 */
public class Client {
    /**
     * 获取spring容器的Ioc核心容器，并根据id获取对象
     *
     * @param args
     */
    public static void main(String[] args) {
        //1、获取核心容器对象
//        ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");
        ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");//同理把它看作自己，对象就会销毁,单例模式，且加上close方法                                              此处
        //2.根据id获取bean对象,两种方式，一种是Object类型强转，一种是传递字节码强转
        IAccountService as = (IAccountService)ac.getBean("accountService");
//        IAccountService as2 = (IAccountService)ac.getBean("accountService");
//        System.out.println(as);
//
//        IAccountDao adao = (IAccountDao) ac.getBean("AccountDao");
//        System.out.println(adao);

//        System.out.println(as==as2);
        as.saveAccount();
        ac.close();//销毁方法执行了                          此处
    }
}

```

### 08_XMLOC的案例准备案例的必须代码

项目    day02_eesy_02account_xmlioc

​	创建Service层

​	创建Dao层

​	创建domain

​	创建bean.xml

这里只贴一下Dao的实现类

```java
package com.itheima.dao.impl;

import com.itheima.dao.IAccountDao;
import com.itheima.domain.Account;
import org.apache.commons.dbutils.QueryRunner;
import org.apache.commons.dbutils.handlers.BeanHandler;
import org.apache.commons.dbutils.handlers.BeanListHandler;

import java.sql.SQLException;
import java.util.List;

public class AccountDaoImpl implements IAccountDao {

    private QueryRunner runner;

    public void setRunner(QueryRunner runner) {
        this.runner = runner;
    }

    @Override
    public List<Account> findAllAccount() {
        try {
            return runner.query("select * from account",new BeanListHandler<Account>(Account.class));
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public Account findAccountById(Integer accountId) {
        try {
            return runner.query("select * from account where id = ?",new BeanHandler<Account>(Account.class),accountId);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public void saveAccount(Account account) {
        try {
            runner.update("insert into account(name,money)values (?,?)",account.getName(),account.getMoney());
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public void updateAccount(Account account) {
        try {
            runner.update("update account set name = ?,money= ? where id = ?",account.getName(),account.getMoney(),account.getId());
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public void deleteAccount(Integer accountId) {
        try {
            runner.update("delete from account where id = ?",accountId);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}

```

### 09 XMLIOC案例-编写spring的loc配置

xml配置数据库      项目  day02_eesy_02account_xmlioc

这里只贴出重要的bean.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">
    <!--配置Service-->
    <bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl">
        <!--注入dao-->
        <property name="acoountDao" ref="accountDao"></property>
    </bean>

    <!--配置dao对象-->
    <bean id="accountDao" class="com.itheima.dao.impl.AccountDaoImpl">
        <!--注入QueryRunner-->
        <property name="runner" ref="runner"></property>
    </bean>

    <!--配置runner对象 需要配置多例，防止使用干扰-->
    <bean name="runner" class="org.apache.commons.dbutils.QueryRunner" scope="prototype">
        <!--注入数据源   只能用构造函数注入-->
        <constructor-arg name="ds" ref="dataSouerce"></constructor-arg>
    </bean>

    <!--配置数据源-->
    <bean id="dataSouerce" class="com.mchange.v2.c3p0.ComboPooledDataSource">
        <!--连接数据库的必备信息-->
        <property name="driverClass" value="com.mysql.jdbc.Driver"></property>
        <property name="jdbcUrl" value="jdbc:mysql://localhost:3306/eesy"></property>
        <property name="user" value="root"></property>
        <property name="password" value="123456"></property>
    </bean>
</beans>
```

要注意的是QueryRunner也需要注入

### 10测试基于XML的IOC案例

```java
package com.itheima.test;

import com.itheima.dao.IAccountDao;
import com.itheima.domain.Account;
import com.itheima.service.IAccountService;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import java.util.List;

/**
 * 使用JUnit单元测试：测试我们的配置
 */
public class AccountTest {

    @Test
    public void testFindAll() {
        //1.获取容器
        ApplicationContext ac = (ApplicationContext) new ClassPathXmlApplicationContext("bean.xml");
        //2.得到业务层对象
        IAccountService as = (IAccountService) ac.getBean("accountService",IAccountService.class);
        //3.执行方法
        List<Account> accounts = as.findAllAccount();
        for (Account account : accounts) {
            System.out.println(account);
        }
    }

    @Test
    public void testFindOne() {
        //1.获取容器
        ApplicationContext ac = (ApplicationContext) new ClassPathXmlApplicationContext("bean.xml");
        //2.得到业务层对象
        IAccountService as = (IAccountService) ac.getBean("accountService",IAccountService.class);
        //3.执行方法
        Account account = as.findAccountById(1);
        System.out.println(account);
    }

    @Test
    public void testFindSave() {
        Account account = new Account();
        account.setName("ddd");
        account.setMoney(12345f);
        //1.获取容器
        ApplicationContext ac = (ApplicationContext) new ClassPathXmlApplicationContext("bean.xml");
        //2.得到业务层对象
        IAccountService as = (IAccountService) ac.getBean("accountService",IAccountService.class);
        //3.执行方法
        as.saveAccount(account);
    }

    @Test
    public void testUpdate() {
        //1.获取容器
        ApplicationContext ac = (ApplicationContext) new ClassPathXmlApplicationContext("bean.xml");
        //2.得到业务层对象
        IAccountService as = (IAccountService) ac.getBean("accountService",IAccountService.class);
        //3.执行方法
        Account account = as.findAccountById(4);
        account.setMoney(1234f);
        as.updateAccount(account);
    }


    @Test
    public void testDelete() {
        //1.获取容器
        ApplicationContext ac = (ApplicationContext) new ClassPathXmlApplicationContext("bean.xml");
        //2.得到业务层对象
        IAccountService as = (IAccountService) ac.getBean("accountService",IAccountService.class);
        //3.执行方法
        as.deleteAccount(4);
    }
}

```

### 11注解IOC案例-把自己编写的类使用注解配置

创建新项目  day02_eesy_03account_annoioc     且引入前一个基于xml案例的项目   day02_eesy_02account_xmlioc 代码，在其基础上修改注解

这里只用Repository和Service注解优化了实现类 ，并使用Autowired自动注入属性，省略了setter方法

且将bean.xml文件约束更换，

```
 <!--告知spring在创建容器时要扫描的包-->
    <context:component-scan base-package="com.itheima"></context:component-scan>
```

改动比较简单，所以在之后再贴出代码   spring整合Junit部分

### 12_spring的新注解-Configuration和ComponentScan

创建新项目    day02_eesy_04account_annoiocwithoutxml

```java
package config;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.ComponentScans;
import org.springframework.context.annotation.Configuration;

/**
 * 该类是一个配置类，它的作用和bean.xml是一样的
 * spring中的新注解
 * Configuration
 *      作用：指定当前类是一个配置类
 * ComponentScan
 *      作用：用于通过注解指定spring在创建容器时要扫描的包
 *      属性：
 *          value：它和basePackages的作用是一样的，都是用于指定创建容器时要扫描的包
 *              我们使用此注解就等同于在xml中配置了：<context:component-scan base-package="com.itheima"></context:component-scan>
 */
@Configuration
@ComponentScan("com.itheima")//这里是数组，且只有一个值，所以可以省略，直接写值，原写法@ComponentScan(basePackages = {"com.itheima"})
public class SpringConfiguration {
}

```

### 13_spring的新注解-Bean

注意图里不一样，需要一个注解将当前方法等我返回值存入容器

![无标题](C:/Users/Murphy/Pictures/无标题-1630761588627.png)

```java
package config;

import com.mchange.v2.c3p0.ComboPooledDataSource;
import org.apache.commons.dbutils.QueryRunner;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.ComponentScans;
import org.springframework.context.annotation.Configuration;

import javax.sql.DataSource;
import java.beans.PropertyVetoException;

/**
 * Bean：
 *      作用：用于把当前方法的返回值作为bean对象存入spring的ioc容器中     容器有键值对，key，value
 *      属性：name用于指定bean的id。当不写时，默认值是当前方法的名称
 *      细节：
 *          当我们使用注解配置方法时，如果方法有参数，spring框架会从容器中查找有没有可用的bean对象
 *          查找的方式和Autowired注解的作用是一样的
 */
@Configuration
@ComponentScan("com.itheima")//这里是数组，且只有一个值，所以可以省略，直接写值，原写法@ComponentScan(basePackages = {"com.itheima"})
public class SpringConfiguration {

    /**
     * 用于创建一个QueryRunner对象
     * @param dataSource
     * @return
     */
    @Bean(name = "runner")//可以不写属性，如果要写，name不可省略
    public QueryRunner createQueryRunner(DataSource dataSource) {
        return new QueryRunner(dataSource);
    }

    /**
     * 创建数据源对象
     * @return
     */
    @Bean(name = "dataSourece")
    public DataSource createDataSource(){
        try {
            ComboPooledDataSource ds = new ComboPooledDataSource();
            ds.setDriverClass("com.mysql.jdbc.Driver");
            ds.setJdbcUrl("jdbc:mysql://localhost:3306/eesy");
            ds.setUser("root");
            ds.setPassword("123456");
            return ds;
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}

```

### 14_AnnotationConfigApplicationContext的使用

```java
package config;

import com.mchange.v2.c3p0.ComboPooledDataSource;
import org.apache.commons.dbutils.QueryRunner;
import org.springframework.context.annotation.*;

import javax.sql.DataSource;
import java.beans.PropertyVetoException;

@Configuration
@ComponentScan("com.itheima")//这里是数组，且只有一个值，所以可以省略，直接写值，原写法@ComponentScan(basePackages = {"com.itheima"})
public class SpringConfiguration {

    /**
     * 用于创建一个QueryRunner对象
     * @param dataSource
     * @return
     */
    @Bean(name = "runner")//可以不写属性，如果要写，name不可省略
    @Scope("prototype")                     //                       此处
    public QueryRunner createQueryRunner(DataSource dataSource) {
        return new QueryRunner(dataSource);
    }

    /**
     * 创建数据源对象
     * @return
     */
    @Bean(name = "dataSourece")
    public DataSource createDataSource(){
        try {
            ComboPooledDataSource ds = new ComboPooledDataSource();
            ds.setDriverClass("com.mysql.jdbc.Driver");
            ds.setJdbcUrl("jdbc:mysql://localhost:3306/eesy");
            ds.setUser("root");
            ds.setPassword("123456");
            return ds;
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}

```

测试

```java
package com.itheima.test;

import com.itheima.dao.IAccountDao;
import com.itheima.domain.Account;
import com.itheima.service.IAccountService;
import config.SpringConfiguration;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import java.util.List;

/**
 * 使用JUnit单元测试：测试我们的配置
 */
public class AccountTest {

    @Test
    public void testFindAll() {
        //1.获取容器                                                  此处
        ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfiguration.class);
        //2.得到业务层对象
        IAccountService as = (IAccountService) ac.getBean("accountService",IAccountService.class);
        //3.执行方法
        List<Account> accounts = as.findAllAccount();
        for (Account account : accounts) {
            System.out.println(account);
        }
    }
  }
```

测试runner,确定要用scope将runner改为多例

```java
package com.itheima.test;

import com.itheima.service.IAccountService;
import config.SpringConfiguration;
import org.apache.commons.dbutils.QueryRunner;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

/**
 * 测试QueryRunner是否单例
 */
public class QueryRunnerTest {
    @Test
    public void testQueryRunner(){
        //1.获取容器
        ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfiguration.class);
        //2.得到业务层对象
        QueryRunner runner1 = ac.getBean("runner",QueryRunner.class);
        QueryRunner runner2 = ac.getBean("runner",QueryRunner.class);

        System.out.println(runner1 == runner2);//true    所以需要给run修改为多例，使用scope注解
    }
}
```

### 15_spring的新注解-Import

```
当配置类作为AnnotationConfigContext对象创建的参数时，该注解。可以不写。即
           //1.获取容器
          ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfiguration.class);   此处
          如果你要扫描的内容，比如Jdbc挪到另外一个class类中去了，
          此时，
          ①就要扫描这个class所在的文件夹，
          @ComponentScan({"com.itheima","config"})
          ②且给这个class加上Configuration
          @Configuration
          public class JdbcConfig {...}
 
          如果不写，那就获取容器需要修改
          //1.获取容器
          ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfiguration.class, JdbcConfig.class);
          
用Inport注解可以简化上述操作，就可以直接写@ComponentScan({"com.itheima"})
		当做一个总的包,加载主配置类的时候就能把jdbc也一起加载了
```

子配置类JdbcConfig

```java
package config;

import com.mchange.v2.c3p0.ComboPooledDataSource;
import org.apache.commons.dbutils.QueryRunner;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Scope;

import javax.sql.DataSource;

/**
 * 和spring连接数据库相关的配置类
 */
//@Configuration
public class JdbcConfig {

    /**
     * 用于创建一个QueryRunner对象
     * @param dataSource
     * @return
     */
    @Bean(name = "runner")//可以不写属性，如果要写，name不可省略
    @Scope("prototype")
    public QueryRunner createQueryRunner(DataSource dataSource) {
        return new QueryRunner(dataSource);
    }

    /**
     * 创建数据源对象
     * @return
     */
    @Bean(name = "dataSourece")
    public DataSource createDataSource(){
        try {
            ComboPooledDataSource ds = new ComboPooledDataSource();
            ds.setDriverClass("com.mysql.jdbc.Driver");
            ds.setJdbcUrl("jdbc:mysql://localhost:3306/eesy");
            ds.setUser("root");
            ds.setPassword("123456");
            return ds;
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}

```

父配置类

```java
package config;

import com.mchange.v2.c3p0.ComboPooledDataSource;
import org.apache.commons.dbutils.QueryRunner;
import org.springframework.context.annotation.*;

import javax.sql.DataSource;
import java.beans.PropertyVetoException;

/**
 * 该类是一个配置类，它的作用和bean.xml是一样的
 * spring中的新注解
 * Configuration
 *      作用：指定当前类是一个配置类
 *      细节:当配置类作为AnnotationConfigContext对象创建的参数时，该注解。可以不写。
 * ComponentScan
 *      作用：用于通过注解指定spring在创建容器时要扫描的包
 *      属性：
 *          value：它和basePackages的作用是一样的，都是用于指定创建容器时要扫描的包
 *              我们使用此注解就等同于在xml中配置了：<context:component-scan base-package="com.itheima"></context:component-scan>
 * Bean：
 *      作用：用于把当前方法的返回值作为bean对象存入spring的ioc容器中     容器有键值对，key，value
 *      属性：name用于指定bean的id。当不写时，默认值是当前方法的名称
 *      细节：
 *          当我们使用注解配置方法时，如果方法有参数，spring框架会从容器中查找有没有可用的bean对象
 *          查找的方式和Autowired注解的作用是一样的
 * Inport
 *      作用:用于导入其他的配置类
 *      属性：value：用于指定其他配置类的字节码。
 *           当我们使用Import的注解之后，有Import注解的类就父配置类，而导入的都是子配置类
 */
//@Configuration
@Import(JdbcConfig.class)
@ComponentScan({"com.itheima","config"})//这里是数组，且只有一个值，所以可以省略，直接写值，原写法@ComponentScan(basePackages = {"com.itheima"})
public class SpringConfiguration {

}

```

测试

```java
package com.itheima.test;

import com.itheima.dao.IAccountDao;
import com.itheima.domain.Account;
import com.itheima.service.IAccountService;
import config.JdbcConfig;
import config.SpringConfiguration;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import java.util.List;

/**
 * 使用JUnit单元测试：测试我们的配置
 */
public class AccountTest {

    @Test
    public void testFindAll() {
        //1.获取容器
        ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfiguration.class);
        //2.得到业务层对象
        IAccountService as = (IAccountService) ac.getBean("accountService",IAccountService.class);
        //3.执行方法
        List<Account> accounts = as.findAllAccount();
        for (Account account : accounts) {
            System.out.println(account);
        }
    }
 }
```

### 16_spring的新注解-PropertySource

纯注解配置数据库  项目day02_eesy_04account_annoiocwithoutxml

resources文件夹下      jdbcConfig.properties  

```xml
jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/eesy
jdbc.username=root
jdbc.password=123456
```

jdbcConfig   类

```java
package config;

import com.mchange.v2.c3p0.ComboPooledDataSource;
import org.apache.commons.dbutils.QueryRunner;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Scope;

import javax.sql.DataSource;

/**
 * 和spring连接数据库相关的配置类
 */
//@Configuration
public class JdbcConfig {

    @Value("${jdbc.driver}")
    private String driver;

    @Value("${jdbc.url}")
    private String url;

    @Value("${jdbc.username}")
    private String username;

    @Value("${jdbc.password}")
    private String password;

    /**
     * 用于创建一个QueryRunner对象
     * @param dataSource
     * @return
     */
    @Bean(name = "runner")//可以不写属性，如果要写，name不可省略
    @Scope("prototype")
    public QueryRunner createQueryRunner(DataSource dataSource) {
        return new QueryRunner(dataSource);
    }

    /**
     * 创建数据源对象
     * @return
     */
    @Bean(name = "dataSourece")
    public DataSource createDataSource(){
        try {
            ComboPooledDataSource ds = new ComboPooledDataSource();
            ds.setDriverClass(driver);
            ds.setJdbcUrl(url);
            ds.setUser(username);
            ds.setPassword(password);
            return ds;
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}

```

SpringConfiguration      父配置类

```java
package config;

import com.mchange.v2.c3p0.ComboPooledDataSource;
import org.apache.commons.dbutils.QueryRunner;
import org.springframework.context.annotation.*;

import javax.sql.DataSource;
import java.beans.PropertyVetoException;

/**
 * ProperSource
 *      作用：用于指定properties文件的位置
 *      属性:
 *          value:指定文件的名称和路径。
 *                  关键字:classpath,表示类路径下
 *                  如果有包就可以写@PropertySource("classpath:com/itheima/jdbcConfig.properties")
 */
//@Configuration
@ComponentScan({"com.itheima"})//这里是数组，且只有一个值，所以可以省略，直接写值，原写法@ComponentScan(basePackages = {"com.itheima"})
@Import(JdbcConfig.class)
@PropertySource("classpath:jdbcConfig.properties")
public class SpringConfiguration {

}

```

关于数据的配置，实际项目选择xml还是全注解配置，哪种方便选哪种

### 17_Qualifier注解的另一种用法

```java
package config;

import com.mchange.v2.c3p0.ComboPooledDataSource;
import org.apache.commons.dbutils.QueryRunner;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Scope;

import javax.sql.DataSource;

/**
 * 和spring连接数据库相关的配置类
 */
//@Configuration
public class JdbcConfig {

    @Value("${jdbc.driver}")
    private String driver;

    @Value("${jdbc.url}")
    private String url;

    @Value("${jdbc.username}")
    private String username;

    @Value("${jdbc.password}")
    private String password;

    /**
     * 用于创建一个QueryRunner对象
     * @param dataSource
     * @return
     */
    @Bean(name = "runner")//可以不写属性，如果要写，name不可省略
    @Scope("prototype")
    public QueryRunner createQueryRunner(@Qualifier("ds2") DataSource dataSource) {//可以直接使用,不需要Autowired支持      此处
        return new QueryRunner(dataSource);
    }

    /**
     * 创建数据源对象
     * @return
     */
    @Bean(name = "ds1")
    public DataSource createDataSource(){
        try {
            ComboPooledDataSource ds = new ComboPooledDataSource();
            ds.setDriverClass(driver);
            ds.setJdbcUrl(url);
            ds.setUser(username);
            ds.setPassword(password);
            System.out.println("数据库1");
            return ds;
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    @Bean(name = "ds2")
    public DataSource createDataSource1(){
        try {
            ComboPooledDataSource ds = new ComboPooledDataSource();
            ds.setDriverClass(driver);
            ds.setJdbcUrl(url);
            ds.setUser(username);
            ds.setPassword(password);
            System.out.println("数据库2");
            return ds;
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}

```

### 18_spring整合junit问题分析

```
1、应用程序的入口
	main方法
2、junit单元测试中，没有main方法也能执行
	junit集成了一个main方法
	该方法就会判断当前测试类中哪些方法有 @Test注解
	junit就让有Test注解的方法执行
3、junit不会管我们是否采用spring框架
	在执行测试方法时，junit根本不知道我们是不是使用了spring框架
	所以也就不会为我们读取配置文件/配置类创建spring核心容器
4、由以上三点可知
	当测试方法执行时，没有Ioc容器，就算写了Autowired注解，也无法实现注入
```

### 19_spring整合junit完成

整合过程，

pom.xml添加依赖

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.itheima</groupId>
    <artifactId>day02_eesy_02account_xmlioc</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
    </properties>

    <packaging>jar</packaging>

    <dependencies>
        <dependency>
            <groupId>commons-dbutils</groupId>
            <artifactId>commons-dbutils</artifactId>
            <version>1.4</version>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
            <version>5.0.2.RELEASE</version>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>                            此处
            <artifactId>spring-test</artifactId>
            <version>5.0.2.RELEASE</version>
        </dependency>
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>5.1.6</version>
        </dependency>
        <dependency>
            <groupId>c3p0</groupId>
            <artifactId>c3p0</artifactId>
            <version>0.9.1.2</version>
        </dependency>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.12</version>                                        此处要求4.12以上
        </dependency>
    </dependencies>
</project>
```

修改测试类注解

```java
package com.itheima.test;

import com.itheima.dao.IAccountDao;
import com.itheima.domain.Account;
import com.itheima.service.IAccountService;
import config.JdbcConfig;
import config.SpringConfiguration;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import java.util.List;

/**
 * 使用JUnit单元测试：测试我们的配置
 * spring整合Junit的配置
 * 1.导入spring整合Junit的jar（坐标）
 * 2.使用Junit提供的一个注解把原有的main方法替换了，替换成spring提供的
 *      @Runwith
 * 3.告知spring的运行器，spring和ioc创建是基于xml还是注解，并说明位置
 *      @ContextConfiguration
 *          locations:指定xml文件的位置，加上classpath关键字，标识在类路径下
 *          classes:指定注解类所在的位置
 * 当我们使用spring5.x搬本的时候，要求junit的jar必须是4.12以上
 *
 */
@RunWith(SpringJUnit4ClassRunner.class)                                 //此处
@ContextConfiguration(classes = SpringConfiguration.class)              //此处
public class AccountTest {
    
    @Autowired
    private IAccountService as;                                         //此处

    @Test
    public void testFindAll() {
        //3.执行方法
        List<Account> accounts = as.findAllAccount();
        for (Account account : accounts) {
            System.out.println(account);
        }
    }

    @Test
    public void testFindOne() {
        //3.执行方法
        Account account = as.findAccountById(1);
        System.out.println(account);
    }

    @Test
    public void testFindSave() {
        Account account = new Account();
        account.setName("ddd");
        account.setMoney(23456f);
        //3.执行方法
        as.saveAccount(account);
    }

    @Test
    public void testUpdate() {
        Account account = as.findAccountById(4);
        account.setMoney(1234f);
        as.updateAccount(account);
    }


    @Test
    public void testDelete() {
        //3.执行方法
        as.deleteAccount(4);
    }
}

```

之前使用xml的项目 day02_eesy_02account_xmlioc  也已修改

### ----------------------

### 第三部分

### 01_今日课程内容介绍

```
1、完善我们的account案例
2、分析案例中问题
3、回顾之前讲过的一个技术：动态代理
4、动态代理另一种实现方式
5、解决案例中的问题
6、AOP的概念
7、spring中的AOP相关术语
8、spring中基于XML和注解的AOP配置
```

### 02案例中添加转账方法并演示事务问题

创建新项目     day03_eesy_01account

持久层实现类增加根据名称查询账户新方法

```java
package com.itheima.dao.impl;

import com.itheima.dao.IAccountDao;
import com.itheima.domain.Account;
import org.apache.commons.dbutils.QueryRunner;
import org.apache.commons.dbutils.handlers.BeanHandler;
import org.apache.commons.dbutils.handlers.BeanListHandler;

import java.sql.SQLException;
import java.util.List;

public class AccountDaoImpl implements IAccountDao {

    private QueryRunner runner;

    public void setRunner(QueryRunner runner) {
        this.runner = runner;
    }

    @Override
    public List<Account> findAllAccount() {
        try {
            return runner.query("select * from account", new BeanListHandler<Account>(Account.class));
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public Account findAccountById(Integer accountId) {
        try {
            return runner.query("select * from account where id = ?", new BeanHandler<Account>(Account.class), accountId);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public void saveAccount(Account account) {
        try {
            runner.update("insert into account(name,money)values (?,?)", account.getName(), account.getMoney());
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public void updateAccount(Account account) {
        try {
            runner.update("update account set name = ?,money= ? where id = ?", account.getName(), account.getMoney(), account.getId());
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public void deleteAccount(Integer accountId) {
        try {
            runner.update("delete from account where id = ?", accountId);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public Account findAcountByName(String accountName) {
        try {
            List<Account> accounts = runner.query("select * from account where name = ?", new BeanListHandler<Account>(Account.class), accountName);
            if (accounts == null || accounts.size() == 0) {
                return null;
            }
            if (accounts.size() > 1) {
                throw new RuntimeException("结果集不为1，数据有问题");
            }
            return accounts.get(0);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}

```

业务层实现类增加转账方法

```java
package com.itheima.service.impl;

import com.itheima.domain.Account;
import com.itheima.service.IAccountService;
import com.itheima.dao.IAccountDao;

import java.util.List;

/**
 * 账户的业务层实现类
 */
public class AccountServiceImpl implements IAccountService {
    private IAccountDao acoountDao;

    public void setAcoountDao(IAccountDao acoountDao) {
        this.acoountDao = acoountDao;
    }

    @Override
    public List<Account> findAllAccount() {
        return acoountDao.findAllAccount();
    }

    @Override
    public Account findAccountById(Integer accountId) {
        return acoountDao.findAccountById(accountId);
    }

    @Override
    public void saveAccount(Account account) {
        acoountDao.saveAccount(account);
    }

    @Override
    public void updateAccount(Account account) {
        acoountDao.updateAccount(account);
    }

    @Override
    public void deleteAccount(Integer accountId) {
        acoountDao.deleteAccount(accountId);
    }

    @Override
    public void transfer(String sourceName, String targetName, Float money) {       //此处
        //1.根据名称查询转出账户
        Account source = acoountDao.findAcountByName(sourceName);
        //2.根据名称查询转入账户
        Account target = acoountDao.findAcountByName(targetName);
        //3.转出账户减钱
        source.setMoney(source.getMoney()-money);
        //4.转入账户加钱
        target.setMoney(target.getMoney() + money);
        //5.更新转出账户
        acoountDao.updateAccount(source);
        int i=1/0;//导致转出账户减少，但是转入账户并没有增加   且报错  java.lang.ArithmeticException: / by zero   所以要解决这个问题
        //6.更新转入账户
        acoountDao.updateAccount(target);
    }
}
```

测试

```java
package com.itheima.test;

import com.itheima.dao.IAccountDao;
import com.itheima.domain.Account;
import com.itheima.service.IAccountService;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import java.util.List;

/**
 * 使用JUnit单元测试：测试我们的配置
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = "classpath:bean.xml")
public class AccountTest {

    @Autowired
    private IAccountService as;

    @Test
    public void testTransfer(){
        as.transfer("aaa","bbb",100f);
    }
}
```

### 03分析事务的问题并编写ConnectionUtils

![事务控制](C:/Users/Murphy/Pictures/事务控制.png)

```
事物控制应该都是在业务层
```

utils包创建    ConnectionUtils

```java
package com.itheima.utils;

import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.SQLException;

/**
 * 连接的工具类，它用于从数据源中获取一个连接，并且实现和线程的绑定
 */
public class ConnectionUtils {
    
    private ThreadLocal<Connection> tl = new ThreadLocal<Connection>();

    private DataSource dataSource;

    public void setDataSource(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    /**
     * 获取当前线程上的连接
     * @return
     */
    private Connection getConnection() {
        try {
            //1.先从ThreadLocal上获取
            Connection conn = tl.get();
            //2.判断当前线程上是否有连接
            if (conn == null) {
                //3.先从数据源中获取一个连接，并且存入Threadlocal中
                conn = dataSource.getConnection();
                tl.set(conn);
            }
            //4.返回当前线程上的连接
            return conn;
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}

```

### 04_编写事务管理工具类并分析连接和线程解绑



```java
package com.itheima.utils;

import javax.sql.DataSource;
import java.sql.Connection;

/**
 * 连接的工具类，它用于从数据源中获取一个连接，并且实现和线程的绑定
 */
public class ConnectionUtils {

    private ThreadLocal<Connection> tl = new ThreadLocal<Connection>();

    private DataSource dataSource;

    public void setDataSource(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    /**
     * 获取当前线程上的连接
     * @return
     */
    public Connection getThreadConnection() {
        try {
            //1.先从ThreadLocal上获取
            Connection conn = tl.get();
            //2.判断当前线程上是否有连接
            if (conn == null) {
                //3.先从数据源中获取一个连接，并且存入Threadlocal中
                conn = dataSource.getConnection();
                tl.set(conn);
            }
            //4.返回当前线程上的连接
            return conn;
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * 把连接和线程解绑
     */
    public void removeConnection(){
        tl.remove();
    }
}

```

```java
package com.itheima.utils;
/**
 * 和事物管理相关的工具类，它包含了，开启事务，提交事务，回滚事物和释放连接
 */
public class TransactionManager {

    private ConnectionUtils connectionUtils ;

    public void setConnectionUtils(ConnectionUtils connectionUtils) {
        this.connectionUtils = connectionUtils;
    }

    /**
     * 开启事务
     */
    public void beginTransaction(){
        try {
            connectionUtils.getThreadConnection().setAutoCommit(false);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * 提交事务
     */
    public void commit(){
        try {
            connectionUtils.getThreadConnection().commit();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * 回滚事务
     */
    public void rollback(){
        try {
            connectionUtils.getThreadConnection().rollback();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * 释放连接
     */
    public void release(){
        try {
            connectionUtils.getThreadConnection().close();//还回连接池中
            connectionUtils.removeConnection();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

### 05编写业务层和持久层事务控制代码并配置spring的ioc

工具类，把连接和线程解绑

```java
package com.itheima.utils;

import javax.sql.DataSource;
import java.sql.Connection;

/**
 * 连接的工具类，它用于从数据源中获取一个连接，并且实现和线程的绑定
 */
public class ConnectionUtils {

    private ThreadLocal<Connection> tl = new ThreadLocal<Connection>();

    private DataSource dataSource;

    public void setDataSource(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    /**
     * 获取当前线程上的连接
     * @return
     */
    public Connection getThreadConnection() {
        try {
            //1.先从ThreadLocal上获取
            Connection conn = tl.get();
            //2.判断当前线程上是否有连接
            if (conn == null) {
                //3.先从数据源中获取一个连接，并且存入Threadlocal中
                conn = dataSource.getConnection();
                tl.set(conn);
            }
            //4.返回当前线程上的连接
            return conn;
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * 把连接和线程解绑                                       此处
     */
    public void removeConnection(){
        tl.remove();
    }
}

```

完善业务层，事务控制流程

```java
package com.itheima.service.impl;

import com.itheima.domain.Account;
import com.itheima.service.IAccountService;
import com.itheima.dao.IAccountDao;
import com.itheima.utils.TransactionManager;

import java.util.List;

/**
 * 账户的业务层实现类
 *
 * 事物控制应该都是在业务层
 */
public class AccountServiceImpl implements IAccountService {

    private IAccountDao acoountDao;
    private TransactionManager txManager;

    public void setTxManager(TransactionManager txManager) {
        this.txManager = txManager;
    }

    public void setAcoountDao(IAccountDao acoountDao) {
        this.acoountDao = acoountDao;
    }

    @Override
    public List<Account> findAllAccount() {
        try {
            //1.开启事务
            txManager.beginTransaction();
            //2.执行操作
            List<Account> accounts = acoountDao.findAllAccount();
            //3.提交事务
            txManager.commit();
            //4.返回结果
            return accounts;
        } catch (Exception e) {
            //5.回滚操作
            txManager.rollback();
            throw new RuntimeException(e);
        }finally {
            //6.释放连接
            txManager.release();
        }
    }

    @Override
    public Account findAccountById(Integer accountId) {
        try {
            //1.开启事务
            txManager.beginTransaction();
            //2.执行操作
             Account account= acoountDao.findAccountById(accountId);
            //3.提交事务
            txManager.commit();
            //4.返回结果
            return account;
        } catch (Exception e) {
            //5.回滚操作
            txManager.rollback();
            throw new RuntimeException(e);
        }finally {
            //6.释放连接
            txManager.release();
        }
    }

    @Override
    public void saveAccount(Account account) {
        try {
            //1.开启事务
            txManager.beginTransaction();
            //2.执行操作
            acoountDao.saveAccount(account);
            //3.提交事务
            txManager.commit();
        } catch (Exception e) {
            //4.回滚操作
            txManager.rollback();
        }finally {
            //5.释放连接
            txManager.release();
        }

    }

    @Override
    public void updateAccount(Account account) {
        try {
            //1.开启事务
            txManager.beginTransaction();
            //2.执行操作
            acoountDao.updateAccount(account);
            //3.提交事务
            txManager.commit();
        } catch (Exception e) {
            //5.回滚操作
            txManager.rollback();
        }finally {
            //6.释放连接
            txManager.release();
        }

    }

    @Override
    public void deleteAccount(Integer accountId) {
        try {
            //1.开启事务
            txManager.beginTransaction();
            //2.执行操作
            acoountDao.deleteAccount(accountId);
            //3.提交事务
            txManager.commit();
        } catch (Exception e) {
            //5.回滚操作
            txManager.rollback();
        }finally {
            //6.释放连接
            txManager.release();
        }

    }

    @Override
    public void transfer(String sourceName, String targetName, Float money) {
        try {
            //1.开启事务
            txManager.beginTransaction();
            //2.执行操作
            //2.1.根据名称查询转出账户
            Account source = acoountDao.findAcountByName(sourceName);
            //2.2.根据名称查询转入账户
            Account target = acoountDao.findAcountByName(targetName);
            //2.3.转出账户减钱
            source.setMoney(source.getMoney()-money);
            //2.4.转入账户加钱
            target.setMoney(target.getMoney() + money);
            //2.5.更新转出账户
            acoountDao.updateAccount(source);
            //2.6.更新转入账户
            acoountDao.updateAccount(target);
            //3.提交事务
            txManager.commit();
        } catch (Exception e) {
            //4.回滚操作
            txManager.rollback();
        }finally {
            //5.释放连接
            txManager.release();
        }

    }
}

```

持久层添加新属性

```java
package com.itheima.dao.impl;

import com.itheima.dao.IAccountDao;
import com.itheima.domain.Account;
import com.itheima.utils.ConnectionUtils;
import org.apache.commons.dbutils.QueryRunner;
import org.apache.commons.dbutils.handlers.BeanHandler;
import org.apache.commons.dbutils.handlers.BeanListHandler;

import java.sql.Connection;
import java.util.List;

/**
 * 账户的持久层实现类
 */
public class AccountDaoImpl implements IAccountDao {

    private QueryRunner runner;
    private ConnectionUtils connectionUtils;

    public void setConnectionUtils(ConnectionUtils connectionUtils) {
        this.connectionUtils = connectionUtils;
    }

    public void setRunner(QueryRunner runner) {
        this.runner = runner;
    }

    @Override
    public List<Account> findAllAccount() {
        try {
            return runner.query(connectionUtils.getThreadConnection(),"select * from account", new BeanListHandler<Account>(Account.class));
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public Account findAccountById(Integer accountId) {
        try {
            return runner.query(connectionUtils.getThreadConnection(),"select * from account where id = ?", new BeanHandler<Account>(Account.class), accountId);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public void saveAccount(Account account) {
        try {
            runner.update(connectionUtils.getThreadConnection(),"insert into account(name,money)values (?,?)", account.getName(), account.getMoney());
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public void updateAccount(Account account) {
        try {
            runner.update(connectionUtils.getThreadConnection(),"update account set name = ?,money= ? where id = ?", account.getName(), account.getMoney(), account.getId());
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public void deleteAccount(Integer accountId) {
        try {
            runner.update(connectionUtils.getThreadConnection(),"delete from account where id = ?", accountId);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public Account findAcountByName(String accountName) {
        try {
            List<Account> accounts = runner.query(connectionUtils.getThreadConnection(),"select * from account where name = ?", new BeanListHandler<Account>(Account.class), accountName);
            if (accounts == null || accounts.size() == 0) {
                return null;
            }
            if (accounts.size() > 1) {
                throw new RuntimeException("结果集不为1，数据有问题");
            }
            return accounts.get(0);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}

```

修改xml  ,主要是 <!--注入事务管理器-->、<!--注入ConnectionUtils-->、 <!--配置Connection的工具类--><!--配置事务管理器-->

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">
    <!--配置Service-->
    <bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl">
        <!--注入dao-->
        <property name="acoountDao" ref="accountDao"></property>
        <!--注入事务管理器-->
        <property name="txManager" ref="txManager"></property>
    </bean>

    <!--配置dao对象-->
    <bean id="accountDao" class="com.itheima.dao.impl.AccountDaoImpl">
        <!--注入QueryRunner-->
        <property name="runner" ref="runner"></property>
        <!--注入ConnectionUtils-->
        <property name="connectionUtils" ref="connectionUtils"></property>
    </bean>

    <!--配置runner对象 需要配置多例，防止使用干扰-->
    <bean name="runner" class="org.apache.commons.dbutils.QueryRunner" scope="prototype"></bean>

    <!--配置数据源-->
    <bean id="dataSouerce" class="com.mchange.v2.c3p0.ComboPooledDataSource">
        <!--连接数据库的必备信息-->
        <property name="driverClass" value="com.mysql.jdbc.Driver"></property>
        <property name="jdbcUrl" value="jdbc:mysql://localhost:3306/eesy"></property>
        <property name="user" value="root"></property>
        <property name="password" value="123456"></property>
    </bean>

    <!--配置Connection的工具类-->
    <bean id="connectionUtils" class="com.itheima.utils.ConnectionUtils">
        <!--注入数据源-->
        <property name="dataSource" ref="dataSouerce"></property>
    </bean>

    <!--配置事务管理器-->
    <bean id="txManager" class="com.itheima.utils.TransactionManager">
        <!--注入ConnectionUtils-->
        <property name="connectionUtils" ref="connectionUtils"></property>
    </bean>
</beans>
```

### 06测试转账并分析案例中的问题

这里没讲什么内容...

### 07_代理的分析

![代理](C:/Users/Murphy/Pictures/代理.png)

### 08基于接口的动态代理回顾

项目      day03_eesy_02proxy

创建接口

```java
package com.itheima.proxy;

/**
 * 对生产厂家要求的接口
 */
public interface IProducer{

    /**
     * 销售
     * @param money
     */
    public void saleProduct(float money);

    /**
     * 售后
     * @param money
     */
    public void afterService(float money);
}

```

接口的实现类

```java
package com.itheima.proxy;

/**
 * 一个生产者
 */
public class Producer implements IProducer{

    /**
     * 销售
     * @param money
     */
    public void saleProduct(float money){
        System.out.println("销售产品，并拿到钱" + money);
    }

    /**
     * 售后
     * @param money
     */
    public void afterService(float money){
        System.out.println("提供售后服务，并拿到钱" + money);
    }
}
```

代理类

```java
package com.itheima.proxy;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

/**
 * 模拟一个消费者
 */
public class Client {

    public static void main(String[] args) {
        final Producer producer = new Producer();

        /**
         * 动态代理：
         *  特点：字节码随用随创建，随用随加载
         *  作用：不修改源码的基础上对方法增强
         *  分类：基于接口的动态代理
         *       基于子类的动态代理
         *  基于接口的动态代理
         *      涉及的类：Proxy
         *      提供者：JDK官方
         *  如何创建代理对象
         *      使用Proxy类中的new ProxyInstance方法
         *  创建代理对象的要求：
         *      被代理对象至少实现一个接口，如果没有则不能使用
         *      new ProxyInstance方法的参数：
         *          Classloader:类加载器
         *              它是用于加载代理对象字节码的。和被代理对象使用相同的类加载器。固定写法。
         *          Class[]：字节码数组
         *              它是用于让代理对象和被代理对象有相同方法。固定写法
         *          InvocationHandler用于提供增强的代码
         *              它是让我们写如何代理。我们一般都是写一个该接口的实现类，通常情况下都是匿名内部类，但不是必须的
         *              此接口的实现类都是谁用谁写。
         */
        IProducer proxyProducer =(IProducer) Proxy.newProxyInstance(producer.getClass().getClassLoader(),
                producer.getClass().getInterfaces(),
                new InvocationHandler() {
                    /**
                     * 作用：执行被代理对象的任何接口方法都会经过该方法
                     * 方法参数的含义
                     * @param proxy     代理对象的引用
                     * @param method    当前执行的方法
                     * @param args      当前执行方法所需的参数
                     * @return          和被代理对象方法有相同的返回值
                     * @throws Throwable
                     */
                    @Override
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                        //提供增强的代码
                        Object returnValue = null;
                        //1.获取方法执行的参数
                        Float money = (Float) args[0];
                        //2.判断当前方法是不是销售
                        if ("saleProduct".equals(method.getName())){
                            returnValue = method.invoke(producer, money*0.8f);
                        }
                        return returnValue;
                    }
                });
        proxyProducer.saleProduct(10000f);
    }
}

```

缺点，类不实现任何接口的时候就会代理异常

### 09_基于子类的动态代理

需要有jar包

pom.xml添加依赖

```xml
<dependencies>
        <dependency>
            <groupId>cglib</groupId>
            <artifactId>cglib</artifactId>
            <version>2.1_3</version>
        </dependency>
    </dependencies>
```

接口的实现类

```java
package com.itheima.cglib;

import com.itheima.proxy.IProducer;

/**
 * 一个生产者
 */
public class Producer implements IProducer {

    /**
     * 销售
     * @param money
     */
    public void saleProduct(float money){
        System.out.println("销售产品，并拿到钱" + money);
    }

    /**
     * 售后
     * @param money
     */
    public void afterService(float money){
        System.out.println("提供售后服务，并拿到钱" + money);
    }
}
```

代理类

```java
package com.itheima.cglib;

import com.itheima.proxy.IProducer;
import net.sf.cglib.proxy.Enhancer;
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

/**
 * 模拟一个消费者
 */
public class Client {

    public static void main(String[] args) {
        final Producer producer = new Producer();

        /**
         * 动态代理：
         *  特点：字节码随用随创建，随用随加载
         *  作用：不修改源码的基础上对方法增强
         *  分类：基于接口的动态代理
         *       基于子类的动态代理
         *  基于子类的动态代理
         *      涉及的类：Enhancer
         *      提供者：第三方jglib库
         *  如何创建代理对象
         *      使用Enhancer类中的create方法
         *  创建代理对象的要求：
         *      被代理类不能最终类
         *  create方法的参数：
         *      Class:字节码
         *          它是用于指定被代理对象的字节码。
         *
         *      CallBack:用于提供增强的代码
         *          它是让我们写如何代理。我们一般都是写一个该接口的实现类，通常情况下都是匿名内部类，但不是必须的。
         *          此接口的实现类都是谁用谁写。
         *          我们一般写的都是该接口的子接口实现类：MethodInterceptrt
         *
         */
        Producer cjlibProducer = (Producer) Enhancer.create(producer.getClass(), new MethodInterceptor() {
            /**
             * 执行被代理对象的任何方法都会经过改方法
             * @param proxy
             * @param method
             * @param args
             *      以上三个参数和基于接口的动态代理中，Invoke方法的参数是一样的
             * @param methodProxy：当前执行方法的代理对象
             * @return
             * @throws Throwable
             */
            @Override
            public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
                //提供增强的代码
                Object returnValue = null;

                //1.获取方法执行的参数
                Float money = (Float) args[0];
                //2.判断当前方法是不是销售
                if ("saleProduct".equals(method.getName())){
                    returnValue = method.invoke(producer, money*0.8f);
                }
                return returnValue;
            }
        });

        cjlibProducer.saleProduct(12000f);
    }
}
```

### 10使用动态代理实现事务控制

创建代理对象

```java
package com.itheima.factory;

import com.itheima.service.IAccountService;
import com.itheima.utils.TransactionManager;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

/**
 * 用于创建service的代理对象的工厂
 */
public class BeanFactory {

    private IAccountService accountService;

    private TransactionManager txManager;

    public void setTxManager(TransactionManager txManager) {
        this.txManager = txManager;
    }

    public final void setAccountService(IAccountService accountService) {
        this.accountService = accountService;
    }

    /**
     * 获取Service的代理对象
     * @return
     */
    public IAccountService getAccountService() {
        return (IAccountService) Proxy.newProxyInstance(accountService.getClass().getClassLoader(),
                accountService.getClass().getInterfaces(), new InvocationHandler() {
                    /**
                     * 添加事物的支持
                     * @param proxy
                     * @param method
                     * @param args
                     * @return
                     * @throws Throwable
                     */
                    @Override
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                        Object rtValue = null;
                        try {
                            //1.开启事务
                            txManager.beginTransaction();
                            //2.执行操作
                            rtValue = method.invoke(accountService, args);
                            //3.提交事务
                            txManager.commit();
                            //4.返回结果
                            return rtValue;
                        } catch (Exception e) {
                            //5.回滚操作
                            txManager.rollback();
                            throw new RuntimeException(e);
                        } finally {
                            //6.释放连接
                            txManager.release();
                        }
                    }
                });
    }
}

```

配置 bean     <!--配置BeanFactory-->    <!--配置代理的service对象-->

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">
    <!--配置代理的service对象 使用对象创建三种方式之一的实例工厂-->
    <bean id="proxyAccountService" factory-bean="beanFactory" factory-method="getAccountService"></bean>

    <!--配置BeanFactory-->
    <bean id="beanFactory" class="com.itheima.factory.BeanFactory">
        <!--注入Service-->
        <property name="accountService" ref="accountService"></property>
        <property name="txManager" ref="txManager"></property>
    </bean>
    <!--配置Service-->
    <bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl">
        <!--注入dao-->
        <property name="acoountDao" ref="accountDao"></property>
    </bean>

    <!--配置dao对象-->
    <bean id="accountDao" class="com.itheima.dao.impl.AccountDaoImpl">
        <!--注入QueryRunner-->
        <property name="runner" ref="runner"></property>
        <!--注入ConnectionUtils-->
        <property name="connectionUtils" ref="connectionUtils"></property>
    </bean>

    <!--配置runner对象 需要配置多例，防止使用干扰-->
    <bean name="runner" class="org.apache.commons.dbutils.QueryRunner" scope="prototype"></bean>

    <!--配置数据源-->
    <bean id="dataSouerce" class="com.mchange.v2.c3p0.ComboPooledDataSource">
        <!--连接数据库的必备信息-->
        <property name="driverClass" value="com.mysql.jdbc.Driver"></property>
        <property name="jdbcUrl" value="jdbc:mysql://localhost:3306/eesy"></property>
        <property name="user" value="root"></property>
        <property name="password" value="123456"></property>
    </bean>

    <!--配置Connection的工具类-->
    <bean id="connectionUtils" class="com.itheima.utils.ConnectionUtils">
        <!--注入数据源-->
        <property name="dataSource" ref="dataSouerce"></property>
    </bean>

    <!--配置事务管理器-->
    <bean id="txManager" class="com.itheima.utils.TransactionManager">
        <!--注入ConnectionUtils-->
        <property name="connectionUtils" ref="connectionUtils"></property>
    </bean>
</beans>
```

### 11_AOP的概念

```
把我们程序重复的代码抽取出来，在需要执行的时候，使用动态代理的技术，在不修改源码的基础上，对我们的已有方法进行增强。
作用:在程序运行期间，不修改源码对已有方法进行增强。
优势:减少重复代码 提高开发效率 维护方便
实现方式:使用动态代理技术
```

### 12_spring中的aop术语和细节

在spring中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式。

```
Joinpoint(连接点): 
	所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法,因为spring只支持方法类型的连接点。 
Pointcut(切入点): 
	所谓切入点是指我们要对哪些Joinpoint进行拦截的定义。
Advice(通知/增强): 
	所谓通知是指拦截到Joinpoint之后所要做的事情就是通知。 通知的类型：前置通知,后置通知,异常通知,最终通知,环绕通知。 
Introduction(引介): 
	引介是一种特殊的通知在不修改类代码的前提下, Introduction可以在运行期为类动态地添加一些方法或Field。 
Target(目标对象): 
	代理的目标对象。 
Weaving(织入): 
	是指把增强应用到目标对象来创建新的代理对象的过程。 spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入。 
Proxy（代理）: 
	一个类被AOP织入增强后，就产生一个结果代理类。 
Aspect(切面): 
	是切入点和通知（引介）的结合。
```

![通知的类型](C:/Users/Murphy/Pictures/通知的类型.jpg)

```
学习spring中的AOP要明确的事 
	a、开发阶段（我们做的） 
		编写核心业务代码（开发主线）：大部分程序员来做，要求熟悉业务需求。
        把公用代码抽取出来，制作成通知。（开发阶段最后再做）：AOP编程人员来做。 
        在配置文件中，声明切入点与通知间的关系，即切面。：AOP编程人员来做。
	b、运行阶段（Spring框架完成的） 
        Spring框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。
```

### 13_spring基于XML的AOP-编写必要的代码

注入依赖

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.itheima</groupId>
    <artifactId>day03_eesy_03springAOP</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
    </properties>

    <packaging>jar</packaging>

    <dependencies>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
            <version>5.0.2.RELEASE</version>
        </dependency>
        <!--解析切入点表达式-->
        <dependency>
            <groupId>org.aspectj</groupId>
            <artifactId>aspectjweaver</artifactId>
            <version>1.8.7</version>
        </dependency>
    </dependencies>
</project>
```

创建接口

```java
package com.itheima.service;

/**
 * 账户的业务层接口
 */
public interface IAccountService {
    /**
     * 模拟保存账户    以下主要是为了表现无参无返回值、有参无返回值、无参有返回值三类
     */
    void saveAccount();

    /**
     * 模拟更新账户
     * @param i
     */
    void undateAccount(int i);

    /**
     * 删除账户
     * @return
     */
    int deleteAccount();
}
```

实现类

```java
package com.itheima.service.impl;

import com.itheima.service.IAccountService;

public class AccountServiceImpl implements IAccountService {
    @Override
    public void saveAccount() {
        System.out.println("执行了保存");
    }

    @Override
    public void undateAccount(int i) {
        System.out.println("执行了更新");
    }

    @Override
    public int deleteAccount() {
        System.out.println("执行了删除");
        return 0;
    }
}
```

创建工具类

```java
package com.itheima.utils;

/**
 * 用于记录日志的工具类，它里面提供了公共的代码
 */
public class Logger {
    /**
     * 用于打印日志，计划让其在切入点之前执行（切入点就是业务层方法）
     */
    public void printlnLog(){
        System.out.println("Logger类中的prinLog方法开始记录日志了");
    }
}
```

下一步打算使用AOP注解的方式实现代理类，使工具类在运行方法之前执行开始记录日志

### 14_spring基于XML的AOP-配置步骤

项目      day03_eesy_03springAOP        注意这里的xml依赖有所不同xmlns:aop

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd">
    <!--配置spring的ioc把service对象配置进来-->
    <bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"></bean>

    <!--spring中基于xml的AOP配置步骤
        1.把通知Bean也交给spring来管理
        2.使用aop:config标签表名开始AOP的配置
        3.使用aop:aspect标签表名配置切面
            id属性：是给切面提供一个唯一标识
            ref属性：是指定通知类bean的id
        4.在aop:aspect标签的内部使用对应标签来配置通知的类型
            我们现在的示例是让printlog方法在切入点方法执行之前：所以是前置通知
            aop:before:表示配置前置通知
            method属性用于指定logger类中哪个方法是前置通知
            pointcut属性:用于指定切入点表达式，该表达式的含义指的是对业务层中哪些方法增强
         切入点表达式的写法:
            关键字:execution(表达式)
            表达式:
                访问修饰符  返回值  包名.包名.包名(参数列表)
            标准的表达式写法:
                public void com.itheima.service.impl.AccountService.saveAccount()
    -->

    <!--配置Logger类-->
    <bean id="logger" class="com.itheima.utils.Logger"></bean>

    <!--配置AOP-->
    <aop:config>
        <!--配置切面-->
        <aop:aspect id="logAdvice" ref="logger">
            <!--配置通知的类型并且建立通知方法和切入点方法的关联-->
            <aop:before method="printlnLog" pointcut="execution(public void com.itheima.service.impl.AccountService.saveAccount())"></aop:before>
        </aop:aspect>
    </aop:config>
</beans>
```

### 15切入点表达式的写法

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd">
    <!--配置spring的ioc把service对象配置进来-->
    <bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"></bean>

    <!--spring中基于xml的AOP配置步骤
        1.把通知Bean也交给spring来管理
        2.使用aop:config标签表名开始AOP的配置
        3.使用aop:aspect标签表名配置切面
            id属性：是给切面提供一个唯一标识
            ref属性：是指定通知类bean的id
        4.在aop:aspect标签的内部使用对应标签来配置通知的类型
            我们现在的示例是让printlog方法在切入点方法执行之前：所以是前置通知
            aop:before:表示配置前置通知
            method属性用于指定logger类中哪个方法是前置通知
            pointcut属性:用于指定切入点表达式，该表达式的含义指的是对业务层中哪些方法增强

         切入点表达式的写法:
            关键字:execution(表达式)
            表达式:
                访问修饰符  返回值  包名.包名.包名(参数列表)
            标准的表达式写法:
                public void com.itheima.service.impl.AccountServiceImpl.saveAccount()
            访问修饰符(public)可以省略
                void com.itheima.service.impl.AccountServiceImpl.saveAccount()
            返回值可以使用通配符，表示任意返回值
                * com.itheima.service.impl.AccountServiceImpl.saveAccount()
            包名可以使用通配符，表示任意包。但是有几级包，就需要写几个*.
                * *.*.*.*.AccountServiceImpl.saveAccount()
            包名可以使用..表示当前包及其子包
                * *..AccountServiceImpl.saveAccount()
            类名和方法名都可以使用*来实现通配
                * *..*.*()
            参数列表:
                可以直接写数据类型:
                    基本类型直接写名称    int
                    引用类型写包名.类名的方式    java.lang.String
                 可以使用通配符表示任意类型，但是必须有参数
                 可以使用..表示有无参数均可，有参数可以是任意类型
            全通配写法
                * *..*.*(..)

            实际开发中切入点表达式的通常写法:
                切入到业务层实现类下的所有写法
                    * com.itheima.service.impl.*.*(..)
    -->

    <!--配置Logger类-->
    <bean id="logger" class="com.itheima.utils.Logger"></bean>

    <!--配置AOP-->
    <aop:config>
        <!--配置切面-->
        <aop:aspect id="logAdvice" ref="logger">
            <!--配置通知的类型并且建立通知方法和切入点方法的关联-->
            <aop:before method="printLog" pointcut="execution(* *..*.*(..))"></aop:before>
        </aop:aspect>
    </aop:config>
</beans>
```

### 16_四种常用通知类型

项目      day03_eesy_04adviceType

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd">
    <!--配置spring的ioc把service对象配置进来-->
    <bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"></bean>

    <!--配置Logger类-->
    <bean id="logger" class="com.itheima.utils.Logger"></bean>

    <!--配置AOP-->
    <aop:config>
        <!--配置切面-->
        <aop:aspect id="logAdvice" ref="logger">
            <!--配置前置通知:在切入点方法执行之前执行。它和异常通知永远只能执行一个-->
            <aop:before method="beforePrintLog" pointcut="execution(* com.itheima.service.impl.*.*(..))"></aop:before>
            <!--配置后置通知:在切入点方法正常执行之后执行-->
            <aop:after-returning method="afterReturningPrintLog" pointcut="execution(* com.itheima.service.impl.*.*(..))"></aop:after-returning>
            <!--配置异常通知:在切入点方法执行产生异常之后执行。它和后置通知永远只能执行一个-->
            <aop:after-throwing method="afterThrowingPrintLog" pointcut="execution(* com.itheima.service.impl.*.*(..))"></aop:after-throwing>
            <!--配置最终通知:无论切入点方法是否正常执行它都会在其后面执行-->
            <aop:after method="afterPrintLog" pointcut="execution(* com.itheima.service.impl.*.*(..))"></aop:after>
        </aop:aspect>
    </aop:config>
</beans>
```

### 17通用化切入点表达式

<!--配置切入点表达式，id属性用于指定表达式的唯一标识。expression用于指定表达式内容    (aop标签中的pointcut就可以省略了)
                此标签写在aop:aspect内部只能当前切面使用。
                它还可以写在aop:aspect外面，此时就变成了所有切面可用(需要放在aop:aspect标签前面)
-->

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd">
    <!--配置spring的ioc把service对象配置进来-->
    <bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"></bean>

    <!--配置Logger类-->
    <bean id="logger" class="com.itheima.utils.Logger"></bean>

    <!--配置AOP-->
    <aop:config>
        <!--配置切入点表达式，id属性用于指定表达式的唯一标识。expression用于指定表达式内容    (aop标签中的pointcut就可以省略了)
                此标签写在aop:aspect内部只能当前切面使用。
                它还可以写在aop:aspect外面，此时就变成了所有切面可用(需要放在aop:aspect标签前面)
            -->
        <aop:pointcut id="pt1" expression="execution(* com.itheima.service.impl.*.*(..))"/>
        <!--配置切面-->
        <aop:aspect id="logAdvice" ref="logger">

            <!--配置前置通知:在切入点方法执行之前执行。它和异常通知永远只能执行一个-->
            <aop:before method="beforePrintLog" pointcut-ref="pt1"></aop:before>

            <!--配置后置通知:在切入点方法正常执行之后执行-->
            <aop:after-returning method="afterReturningPrintLog" pointcut-ref="pt1"></aop:after-returning>

            <!--配置异常通知:在切入点方法执行产生异常之后执行。它和后置通知永远只能执行一个-->
            <aop:after-throwing method="afterThrowingPrintLog" pointcut-ref="pt1"></aop:after-throwing>

            <!--配置最终通知:无论切入点方法是否正常执行它都会在其后面执行-->
            <aop:after method="afterPrintLog" pointcut-ref="pt1"></aop:after>

            <!--<aop:pointcut id="pt1" expression="execution(* com.itheima.service.impl.*.*(..))"/>-->
        </aop:aspect>

    </aop:config>
</beans>
```

### 18_spring中的环绕通知

配置xml

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd">
    <!--配置spring的ioc把service对象配置进来-->
    <bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"></bean>

    <!--配置Logger类-->
    <bean id="logger" class="com.itheima.utils.Logger"></bean>

    <!--配置AOP-->
    <aop:config>
        <!--配置切入点表达式，id属性用于指定表达式的唯一标识。expression用于指定表达式内容    (aop标签中的pointcut就可以省略了)
                此标签写在aop:aspect内部只能当前切面使用。
                它还可以写在aop:aspect外面，此时就变成了所有切面可用(需要放在aop:aspect标签前面)
            -->
        <aop:pointcut id="pt1" expression="execution(* com.itheima.service.impl.*.*(..))"/>
        <!--配置切面-->
        <aop:aspect id="logAdvice" ref="logger">

            <!--配置前置通知:在切入点方法执行之前执行。它和异常通知永远只能执行一个-->
            <!--<aop:before method="beforePrintLog" pointcut-ref="pt1"></aop:before>-->

            <!--配置后置通知:在切入点方法正常执行之后执行-->
            <!--<aop:after-returning method="afterReturningPrintLog" pointcut-ref="pt1"></aop:after-returning>-->

            <!--配置异常通知:在切入点方法执行产生异常之后执行。它和后置通知永远只能执行一个-->
            <!--<aop:after-throwing method="afterThrowingPrintLog" pointcut-ref="pt1"></aop:after-throwing>-->

            <!--配置最终通知:无论切入点方法是否正常执行它都会在其后面执行-->
            <!--<aop:after method="afterPrintLog" pointcut-ref="pt1"></aop:after>-->

            <!--配置环绕通知  详细的注释请看Logger类中-->
            <aop:around method="aroundPrintLog" pointcut-ref="pt1"></aop:around>
        </aop:aspect>

    </aop:config>
</beans>
```

修改方法

```java
package com.itheima.utils;

import org.aspectj.lang.ProceedingJoinPoint;

/**
 * 用于记录日志的工具类，它里面提供了公共的代码
 */
public class Logger {
    /**
     * 前置通知
     */
    public void beforePrintLog(){
        System.out.println("前置通知Logger类中的beforePrintLog方法开始记录日志了");
    }

    /**
     * 后置通知
     */
    public void afterReturningPrintLog(){
        System.out.println("后置通知Logger类中的afterReturningPrintLog方法开始记录日志了");
    }

    /**
     * 异常通知
     */
    public void afterThrowingPrintLog(){
        System.out.println("异常通知Logger类中的afterThrowingPrintLog方法开始记录日志了");
    }

    /**
     * 最终通知
     */
    public void afterPrintLog(){
        System.out.println("最终通知Logger类中的afterPrintLog方法开始记录日志了");
    }

    /**
     * 环绕通知
     * 问题：
     *      当我们配置了环绕通知之后，切入点方法没有执行，而通知方法执行了
     * 分析：
     *      通过对比动态代理中的环绕通知代码，发现动态代理中的环绕通知有明确的切入点方法调用，而我们的代码中没有。
     * 解决：
     *      Spring框架为我们提供了一个接口：ProceedingJoinPoint。该接口有一个方法proceed()，此方法相当于明确调用切入点方法。
     *      该接口可以作为环绕通知的方法参数，在程序执行时，spring会为我们提供该接口的实现类供我们使用。
     *
     * spring中的环绕通知：
     *      它是spring框架为我们提供的一种可以在代码中手动控制增强方法何时执行的方式。
     */
    public Object aroundPrintLog(ProceedingJoinPoint pjp){
        Object rtValue = null;
        try {
            Object[] args = pjp.getArgs(); //得到方法执行所需的参数

            System.out.println("Logger类中的aroundPrintLog方法开始记录日志了。。。前置");

            rtValue = pjp.proceed(args);//明确调用业务层方法（切入点方法）

            System.out.println("Logger类中的aroundPrintLog方法开始记录日志了。。。后置");

            return rtValue;
        } catch (Throwable e) {
            System.out.println("Logger类中的aroundPrintLog方法开始记录日志了。。。异常");
            throw new RuntimeException(e);
        }finally {
            System.out.println("Logger类中的aroundPrintLog方法开始记录日志了。。。最终");
        }
     }
}
```

### 19_spring基于注解的AOP配置

项目      day03_eesy_05annotationAOP

这里的依赖有所不同      xmlns:context

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd">

    <!--配置spring创建容器时要扫描的包-->
    <context:component-scan base-package="com.itheima"></context:component-scan>

    <!--配置spring开启注解AOP的支持-->
    <aop:aspectj-autoproxy></aop:aspectj-autoproxy>
</beans>
```

```java
package com.itheima.utils;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.*;
import org.springframework.stereotype.Component;

/**
 * 用于记录日志的工具类，它里面提供了公共的代码
 */
@Component("logger")
@Aspect//表示当前类是一个切面类
public class Logger {

    @Pointcut("execution(* com.itheima.service.impl.*.*(..))")
    private void tp1(){}
    /**
     * 前置通知
     */
    @Before("tp1()")
    public void beforePrintLog(){
        System.out.println("前置通知Logger类中的beforePrintLog方法开始记录日志了");
    }

    /**
     * 后置通知
     */
    @AfterReturning("tp1()")
    public void afterReturningPrintLog(){
        System.out.println("后置通知Logger类中的afterReturningPrintLog方法开始记录日志了");
    }

    /**
     * 异常通知
     */
    @AfterThrowing("tp1()")
    public void afterThrowingPrintLog(){
        System.out.println("异常通知Logger类中的afterThrowingPrintLog方法开始记录日志了");
    }

    /**
     * 最终通知
     */
    @After("tp1()")
    public void afterPrintLog(){
        System.out.println("最终通知Logger类中的afterPrintLog方法开始记录日志了");
    }

    /**
     * 环绕通知
     * 问题：
     *      当我们配置了环绕通知之后，切入点方法没有执行，而通知方法执行了
     * 分析：
     *      通过对比动态代理中的环绕通知代码，发现动态代理中的环绕通知有明确的切入点方法调用，而我们的代码中没有。
     * 解决：
     *      Spring框架为我们提供了一个接口：ProceedingJoinPoint。该接口有一个方法proceed()，此方法相当于明确调用切入点方法。
     *      该接口可以作为环绕通知的方法参数，在程序执行时，spring会为我们提供该接口的实现类供我们使用。
     *
     * spring中的环绕通知：
     *      它是spring框架为我们提供的一种可以在代码中手动控制增强方法何时执行的方式。
     */
    //@Around("tp1()")
    public Object aroundPrintLog(ProceedingJoinPoint pjp){
        Object rtValue = null;
        try {
            Object[] args = pjp.getArgs(); //得到方法执行所需的参数

            System.out.println("Logger类中的aroundPrintLog方法开始记录日志了。。。前置");

            rtValue = pjp.proceed(args);//明确调用业务层方法（切入点方法）

            System.out.println("Logger类中的aroundPrintLog方法开始记录日志了。。。后置");

            return rtValue;
        } catch (Throwable e) {
            System.out.println("Logger类中的aroundPrintLog方法开始记录日志了。。。异常");
            throw new RuntimeException(e);
        }finally {
            System.out.println("Logger类中的aroundPrintLog方法开始记录日志了。。。最终");
        }
     }
}
```

测试

```java
package com.itheima.test;

import com.itheima.service.IAccountService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

/**
 * 测试aop的配置
 */
public class AOPTest {
    public static void main(String[] args) {
        //1.获取容器
        ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");
        //2.获取对象
        IAccountService as = (IAccountService) ac.getBean("accountService");
        //3.执行方法
        as.saveAccount();
    }
}

```

完全去除xml的方式（与之前ioc纯注解类似）    不使用XML的配置方式

```java
@Configuration 
@ComponentScan(basePackages="com.itheima") 
@EnableAspectJAutoProxy 
public class SpringConfiguration {
}
```

### ----------------------

### 第四部分

### 01_今日课程内容介绍

```
1、spring中的JdbcTemplate
	JdbcTemplate的作用：
		它就是用于和数据库交互的，实现对表的CRUD操作
	如何创建该对象：
	对象中的常用方法：
2、作业：
	spring基于AOP的事务控制
3、spring中的事务控制
	基于XML的
	基于注解的
```

### 02JdbcTemplate的概述和入门

![持久层总图](C:/Users/Murphy/Pictures/持久层总图.jpg)

```
它是spring 框架中提供的一个对象，是对原始Jdbc API 对象的简单封装。spring 框架为我们提供了很多
的操作模板类。
操作关系型数据的：
	JdbcTemplate
	HibernateTemplate
操作nosql 数据库的：
	RedisTemplate
操作消息队列的：
	JmsTemplate
	
	JdbcTemplate在spring-jdbc-5.0.2.RELEASE.jar 中，我们在导包的时候，除了要导入这个jar 包
外，还需要导入一个spring-tx-5.0.2.RELEASE.jar（它是和事务相关的）。
```

项目      day04_eesy_01jdbctemplate

配置依赖

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.itheima</groupId>
    <artifactId>day04_eesy_01jdbctemplate</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
    </properties>

    <packaging>jar</packaging>

    <dependencies>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
            <version>5.0.2.RELEASE</version>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-jdbc</artifactId>
            <version>5.0.2.RELEASE</version>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-tx</artifactId>
            <version>5.0.2.RELEASE</version>
        </dependency>
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>5.1.6</version>
        </dependency>
    </dependencies>
</project>
```

创建类

```java
package com.itheima.domain;

import java.io.Serializable;

public class Account implements Serializable {
    private Integer id;
    private String name;
    private Float money;

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public float getMoney() {
        return money;
    }

    public void setMoney(float money) {
        this.money = money;
    }

    @Override
    public String toString() {
        return "Account{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", money=" + money +
                '}';
    }
}
```

创建类测试

```java
package com.itheima.jdbctemplate;

import com.itheima.domain.Account;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.datasource.DriverManagerDataSource;

import java.sql.Driver;
import java.util.List;

/**
 * jabctemplate的最基本用法
 */
public class JdbcTemplateDemo1 {
    public static void main(String[] args) {
        //准备数据源:spring的内置数据源
        DriverManagerDataSource ds = new DriverManagerDataSource();
        ds.setDriverClassName("com.mysql.jdbc.Driver");
        ds.setUrl("jdbc:mysql://localhost:3306/eesy");
        ds.setUsername("root");
        ds.setPassword("123456");
        //1.创建JdbcTemplate对象
        JdbcTemplate jt = new JdbcTemplate();
        //给gt设置数据源
        jt.setDataSource(ds);
        //2.执行操作
        //jt.execute("insert into account(name,money) values ('ccc',1000)");
        jt.execute("select * from account");
    }
}
```

### 03JdbcTemplate在spring的ioc中使用

配置bean，方便配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">
    <!--配置JdbcTemplate-->
    <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
        <property name="dataSource" ref="dateSource"></property>
    </bean>

    <!--配置数据源-->
    <bean id="dateSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
        <property name="driverClassName" value="com.mysql.jdbc.Driver"></property>
        <property name="url" value="jdbc:mysql://localhost:3306/eesy"></property>
        <property name="username" value="root"></property>
        <property name="password" value="123456"></property>
    </bean>
</beans>
```

测试

```java
package com.itheima.jdbctemplate;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.jdbc.core.JdbcTemplate;

/**
 * jabctemplate的最基本用法
 */
public class JdbcTemplateDemo2 {
    public static void main(String[] args) {
        //1.获取容器
        ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");
        //2.获取对象
        JdbcTemplate jt = ac.getBean("jdbcTemplate",JdbcTemplate.class);
        //3.执行操作
        jt.execute("insert into account(name,money) values ('ddd',2000)");
    }

}
```

### 04_JdbcTemplate的CRUD操作

查询所需的方法

![查询所需的方法](C:/Users/Murphy/Pictures/查询所需的方法.png)

jdbctemplate和queryrunner的区别

![jdbctemplate和queryrunner的区别](C:/Users/Murphy/Pictures/jdbctemplate和queryrunner的区别.png)

```java
package com.itheima.jdbctemplate;

import com.itheima.domain.Account;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;

/**
 * jabctemplate的CRUD操作
 */
public class JdbcTemplateDemo3 {
    public static void main(String[] args) {
        //1.获取容器
        ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");
        //2.获取对象
        JdbcTemplate jt = ac.getBean("jdbcTemplate", JdbcTemplate.class);
        //3.执行操作
        //保存
//        jt.update("insert into account (name,money)values(?,?)","eee",3333f);
        //更新
//        jt.update("update account set name = ?,money = ? where id = ?", "test_update", "222", 9);
        //删除
//        jt.update("delete from account where id = ?", 9);
        //查询所有
//        List<Account> accounts = jt.query("select * from account where money > ?", new AccountRowMapper(), 1000f);  麻烦一些
       /* List<Account> accounts = jt.query("select * from account where money > ?", new BeanPropertyRowMapper<Account>(Account.class), 1000f);  直接返回，推介使用
        for (Account account : accounts) {
            System.out.println(account);
        }*/

        //查询一个
        /*List<Account> account = jt.query("select * from account where id = ?", new BeanPropertyRowMapper<Account>(Account.class), 8);
        System.out.println(account.isEmpty()?"没有内容":account.get(0));*/
        //查询返回一行一列（使用聚合函数，但不加group by子句）
        Integer count = jt.queryForObject("select count(*) from account where money > ?", Integer.class, 1000f);
        System.out.println(count);
    }

}

/**
 * 定义Account的封装策略
 */
class AccountRowMapper implements RowMapper<Account> {

    /**
     * 把结果集中的数据封装到Account中，然后由spring把每个Account加到集合中
     *
     * @param rs
     * @param i
     * @return
     * @throws SQLException
     */
    @Override
    public Account mapRow(ResultSet rs, int i) throws SQLException {
        Account account = new Account();
        account.setId(rs.getInt("id"));
        account.setName(rs.getString("name"));
        account.setMoney(rs.getFloat("money"));
        return account;
    }
}
```

实际开发还是基于DAO的

### 05 JdbcTemplate在Dao中的使用

创建接口

```java
package com.itheima.dao;

import com.itheima.domain.Account;

/**
 * 账号的持久层接口
 */
public interface IAccountDao {

    /**
     * 根据id查询账户
     * @return
     */
    Account findAccountById(Integer accountId);

    /**
     * 根据Name查询账户
     * @return
     */
    Account findAccountByName(String accountName);

    /**
     * 更新账户
     */
    void updateAccountById(Account account);
}package com.itheima.dao;

import com.itheima.domain.Account;

/**
 * 账号的持久层接口
 */
public interface IAccountDao {

    /**
     * 根据id查询账户
     * @return
     */
    Account findAccountById(Integer accountId);

    /**
     * 根据Name查询账户
     * @return
     */
    Account findAccountByName(String accountName);

    /**
     * 更新账户
     */
    void updateAccountById(Account account);
}

```

创建实现类

```java
package com.itheima.dao.Impl;

import com.itheima.dao.IAccountDao;
import com.itheima.domain.Account;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;

import java.util.List;

/**
 * 账户的持久层实现类
 */
public class AccountImpl implements IAccountDao {

    private JdbcTemplate jdbcTemplate;

    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    @Override
    public Account findAccountById(Integer accountId) {
        List<Account> account = jdbcTemplate.query("select * from account where id = ?",new BeanPropertyRowMapper<Account>(Account.class),accountId);
        return account.isEmpty() ? null : account.get(0);
    }

    @Override
    public Account findAccountByName(String accountName) {
        List<Account> account = jdbcTemplate.query("select * from account where name = ?",new BeanPropertyRowMapper<Account>(Account.class),accountName);
        if (account.isEmpty()){
            return null;
        }
        if (account.size()>1){
            throw new RuntimeException("结果集不唯一");
        }
        return account.get(0);
    }

    @Override
    public void updateAccountById(Account account) {
        jdbcTemplate.update("update account set name = ?,money = ? where id = ?",account.getName(),account.getMoney(),account.getId());
    }
}
```

配置持久层实现类

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">
    <!--配置账户的持久层-->
    <bean id="accountDao" class="com.itheima.dao.Impl.AccountImpl">
        <property name="jdbcTemplate" ref="jdbcTemplate"> </property>
    </bean>

    <!--配置JdbcTemplate-->
    <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
        <property name="dataSource" ref="dateSource"></property>
    </bean>

    <!--配置数据源-->
    <bean id="dateSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
        <property name="driverClassName" value="com.mysql.jdbc.Driver"></property>
        <property name="url" value="jdbc:mysql://localhost:3306/eesy"></property>
        <property name="username" value="root"></property>
        <property name="password" value="123456"></property>
    </bean>
</beans>
```

测试

```java
package com.itheima.jdbctemplate;

import com.itheima.dao.IAccountDao;
import com.itheima.domain.Account;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.jdbc.core.JdbcTemplate;

/**
 * jabctemplate的最基本用法
 */
public class JdbcTemplateDemo4 {
    public static void main(String[] args) {
        //1.获取容器
        ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");
        //2.获取对象
        IAccountDao accountDao = ac.getBean("accountDao",IAccountDao.class);
        //3.执行
        /*Account account1 = accountDao.findAccountById(8);
        System.out.println(account1);*/

        /*Account account2 = accountDao.findAccountByName("aaa");
        System.out.println(account2);*/

        Account account3 = new Account();
        account3.setId(8);
        account3.setName("ddd");
        account3.setMoney(1500f);
        accountDao.updateAccountById(account3);

    }

}
```

### 06JdbcDaoSupport的使用以及Dao的两种编写方式

当有多个Dao的时候，我们没必要再自己定义JdbcTemplate也没必要再生成Set方法，两种写法，一种是继承JdbcDaoSupport，另一种是不继承。

继承就不能用注解@Autowired

使用xml配置选择1版本

```java
package com.itheima.dao.Impl;

import com.itheima.dao.IAccountDao;
import com.itheima.domain.Account;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.support.JdbcDaoSupport;

import java.util.List;

/**
 * 账户的持久层实现类
 */
public class AccountDaoImpl extends JdbcDaoSupport implements IAccountDao{

    @Override
    public Account findAccountById(Integer accountId) {
        List<Account> account = super.getJdbcTemplate().query("select * from account where id = ?",new BeanPropertyRowMapper<Account>(Account.class),accountId);
        return account.isEmpty() ? null : account.get(0);
    }

    @Override
    public Account findAccountByName(String accountName) {
        List<Account> account = super.getJdbcTemplate().query("select * from account where name = ?",new BeanPropertyRowMapper<Account>(Account.class),accountName);
        if (account.isEmpty()){
            return null;
        }
        if (account.size()>1){
            throw new RuntimeException("结果集不唯一");
        }
        return account.get(0);
    }

    @Override
    public void updateAccountById(Account account) {
        super.getJdbcTemplate().update("update account set name = ?,money = ? where id = ?",account.getName(),account.getMoney(),account.getId());
    }
}
```

1版本bean.xml配置如下

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">
    <!--配置账户的持久层-->
    <bean id="accountDao" class="com.itheima.dao.Impl.AccountDaoImpl">
        <!--<property name="jdbcTemplate" ref="jdbcTemplate"> </property>-->
        <property name="dataSource" ref="dateSource"> </property>
    </bean>

    <!--配置JdbcTemplate-->
    <!--<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
        <property name="dataSource" ref="dateSource"></property>
    </bean>-->

    <!--配置数据源-->
    <bean id="dateSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
        <property name="driverClassName" value="com.mysql.jdbc.Driver"></property>
        <property name="url" value="jdbc:mysql://localhost:3306/eesy"></property>
        <property name="username" value="root"></property>
        <property name="password" value="123456"></property>
    </bean>
</beans>
```

使用注解配置选择2版本

```java
package com.itheima.dao.Impl;

import com.itheima.dao.IAccountDao;
import com.itheima.domain.Account;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.util.List;

/**
 * 账户的持久层实现类
 */
@Repository
public class AccountDaoImpl2 implements IAccountDao {

    @Autowired
    private JdbcTemplate jdbcTemplate;


    @Override
    public Account findAccountById(Integer accountId) {
        List<Account> account = jdbcTemplate.query("select * from account where id = ?",new BeanPropertyRowMapper<Account>(Account.class),accountId);
        return account.isEmpty() ? null : account.get(0);
    }

    @Override
    public Account findAccountByName(String accountName) {
        List<Account> account = jdbcTemplate.query("select * from account where name = ?",new BeanPropertyRowMapper<Account>(Account.class),accountName);
        if (account.isEmpty()){
            return null;
        }
        if (account.size()>1){
            throw new RuntimeException("结果集不唯一");
        }
        return account.get(0);
    }

    @Override
    public void updateAccountById(Account account) {
        jdbcTemplate.update("update account set name = ?,money = ? where id = ?",account.getName(),account.getMoney(),account.getId());
    }
}
```

### 07作业-基于XML的AOP实现事务控制

旧项目      day03_eesy_01account

新项目      day04_eesy_02account_aoptx_xml

修改约束  xmlns:aop    配置aop

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd">

    <!--配置Service-->
    <bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl">
        <!--注入dao-->
        <property name="acoountDao" ref="accountDao"></property>
    </bean>

    <!--配置dao对象-->
    <bean id="accountDao" class="com.itheima.dao.impl.AccountDaoImpl">
        <!--注入QueryRunner-->
        <property name="runner" ref="runner"></property>
        <!--注入ConnectionUtils-->
        <property name="connectionUtils" ref="connectionUtils"></property>
    </bean>

    <!--配置runner对象 需要配置多例，防止使用干扰-->
    <bean name="runner" class="org.apache.commons.dbutils.QueryRunner" scope="prototype"></bean>

    <!--配置数据源-->
    <bean id="dataSouerce" class="com.mchange.v2.c3p0.ComboPooledDataSource">
        <!--连接数据库的必备信息-->
        <property name="driverClass" value="com.mysql.jdbc.Driver"></property>
        <property name="jdbcUrl" value="jdbc:mysql://localhost:3306/eesy"></property>
        <property name="user" value="root"></property>
        <property name="password" value="123456"></property>
    </bean>

    <!--配置Connection的工具类-->
    <bean id="connectionUtils" class="com.itheima.utils.ConnectionUtils">
        <!--注入数据源-->
        <property name="dataSource" ref="dataSouerce"></property>
    </bean>

    <!--配置事务管理器-->
    <bean id="txManager" class="com.itheima.utils.TransactionManager">
        <!--注入ConnectionUtils-->
        <property name="connectionUtils" ref="connectionUtils"></property>
    </bean>

    <!--配置aop-->                         此处
    <aop:config>
        <!--配置通用切入点表达式-->
        <aop:pointcut id="pt1" expression="execution(* com.itheima.service.impl.*.*(..))"/>
        <aop:aspect id="txAdvice" ref="txManager">
            <!--配置前置通知：开启事务-->
            <aop:before method="beginTransaction" pointcut-ref="pt1"></aop:before>
            <!--配置后置通知：提交事务-->
            <aop:after-returning method="beginTransaction" pointcut-ref="pt1"></aop:after-returning>
            <!--配置异常通知：回滚事务-->
            <aop:after-throwing method="rollback" pointcut-ref="pt1"></aop:after-throwing>
            <!--配置最终通知：释放连接-->
            <aop:after method="release" pointcut-ref="pt1"></aop:after>
        </aop:aspect>
    </aop:config>
</beans>
```

测试

```java
package com.itheima.test;

import com.itheima.dao.IAccountDao;
import com.itheima.domain.Account;
import com.itheima.service.IAccountService;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import java.util.List;

/**
 * 使用JUnit单元测试：测试我们的配置
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = "classpath:bean.xml")
public class AccountServiceTest {

    @Autowired
    private IAccountService as;

    @Test
    public void testTransfer(){
        as.transfer("aaa","bbb",100f);
    }
}
```

### 08作业-基于注解的AOP实现事务控制及问题分析1

首先修改业务层

```java
package com.itheima.service.impl;

import com.itheima.dao.IAccountDao;
import com.itheima.domain.Account;
import com.itheima.service.IAccountService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

/**
 * 账户的业务层实现类
 *
 * 事务控制应该都是在业务层
 */
@Service("accountService")
public class AccountServiceImpl implements IAccountService{

    @Autowired
    private IAccountDao accountDao;


    @Override
    public List<Account> findAllAccount() {
        return accountDao.findAllAccount();
    }

    @Override
    public Account findAccountById(Integer accountId) {
        return accountDao.findAccountById(accountId);

    }

    @Override
    public void saveAccount(Account account) {
        accountDao.saveAccount(account);
    }

    @Override
    public void updateAccount(Account account) {
        accountDao.updateAccount(account);
    }

    @Override
    public void deleteAccount(Integer acccountId) {
        accountDao.deleteAccount(acccountId);
    }

    @Override
    public void transfer(String sourceName, String targetName, Float money) {
        System.out.println("transfer....");
        //2.1根据名称查询转出账户
        Account source = accountDao.findAccountByName(sourceName);
        //2.2根据名称查询转入账户
        Account target = accountDao.findAccountByName(targetName);
        //2.3转出账户减钱
        source.setMoney(source.getMoney()-money);
        //2.4转入账户加钱
        target.setMoney(target.getMoney()+money);
        //2.5更新转出账户
        accountDao.updateAccount(source);

        //int i=1/0;

        //2.6更新转入账户
        accountDao.updateAccount(target);
    }
}

```

修改持久层

```java
package com.itheima.dao.impl;

import com.itheima.dao.IAccountDao;
import com.itheima.domain.Account;
import com.itheima.utils.ConnectionUtils;
import org.apache.commons.dbutils.QueryRunner;
import org.apache.commons.dbutils.handlers.BeanHandler;
import org.apache.commons.dbutils.handlers.BeanListHandler;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Repository;

import java.util.List;

/**
 * 账户的持久层实现类
 */
@Repository("accountDao")
public class AccountDaoImpl implements IAccountDao {

    @Autowired
    private QueryRunner runner;

    @Autowired
    private ConnectionUtils connectionUtils;


    @Override
    public List<Account> findAllAccount() {
        try{
            return runner.query(connectionUtils.getThreadConnection(),"select * from account",new BeanListHandler<Account>(Account.class));
        }catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public Account findAccountById(Integer accountId) {
        try{
            return runner.query(connectionUtils.getThreadConnection(),"select * from account where id = ? ",new BeanHandler<Account>(Account.class),accountId);
        }catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public void saveAccount(Account account) {
        try{
            runner.update(connectionUtils.getThreadConnection(),"insert into account(name,money)values(?,?)",account.getName(),account.getMoney());
        }catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public void updateAccount(Account account) {
        try{
            runner.update(connectionUtils.getThreadConnection(),"update account set name=?,money=? where id=?",account.getName(),account.getMoney(),account.getId());
        }catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public void deleteAccount(Integer accountId) {
        try{
            runner.update(connectionUtils.getThreadConnection(),"delete from account where id=?",accountId);
        }catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public Account findAccountByName(String accountName) {
        try{
            List<Account> accounts = runner.query(connectionUtils.getThreadConnection(),"select * from account where name = ? ",new BeanListHandler<Account>(Account.class),accountName);
            if(accounts == null || accounts.size() == 0){
                return null;
            }
            if(accounts.size() > 1){
                throw new RuntimeException("结果集不唯一，数据有问题");
            }
            return accounts.get(0);
        }catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}

```

修改工具类

```java
package com.itheima.utils;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import javax.sql.DataSource;
import java.sql.Connection;

/**
 * 连接的工具类，它用于从数据源中获取一个连接，并且实现和线程的绑定
 */
@Component("connectionUtils")
public class ConnectionUtils {

    private ThreadLocal<Connection> tl = new ThreadLocal<Connection>();

    @Autowired
    private DataSource dataSource;

    /**
     * 获取当前线程上的连接
     * @return
     */
    public Connection getThreadConnection() {
        try {
            //1.先从ThreadLocal上获取
            Connection conn = tl.get();
            //2.判断当前线程上是否有连接
            if (conn == null) {
                //3.先从数据源中获取一个连接，并且存入Threadlocal中
                conn = dataSource.getConnection();
                tl.set(conn);
            }
            //4.返回当前线程上的连接
            return conn;
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * 把连接和线程解绑
     */
    public void removeConnection(){
        tl.remove();
    }
}
```

修改事物控制类

```java
package com.itheima.utils;

import org.aspectj.lang.annotation.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

/**
 * 和事物管理相关的工具类，它包含了，开启事务，提交事务，回滚事物和释放连接
 */
@Component("txManager")
@Aspect
public class TransactionManager {


    @Autowired
    private ConnectionUtils connectionUtils ;

    @Pointcut("execution(* com.itheima.service.impl.*.*(..))")
    private void pt1(){};

    /**
     * 开启事务
     */
    @Before("pt1()")
    public void beginTransaction(){
        try {
            connectionUtils.getThreadConnection().setAutoCommit(false);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * 提交事务
     */
    @AfterReturning("pt1()")
    public void commit(){
        try {
            connectionUtils.getThreadConnection().commit();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * 回滚事务
     */
    @AfterThrowing("pt1()")
    public void rollback(){
        try {
            connectionUtils.getThreadConnection().rollback();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * 释放连接
     */
    @After("pt1()")
    public void release(){
        try {
            connectionUtils.getThreadConnection().close();//还回连接池中
            connectionUtils.removeConnection();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

替换依赖xmlns:context，配置spring创建容器时要扫描的包，删除多余xml，开启spring对注解aop的支持

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:context="http://www.springframework.org/schema/context"

       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd">

    <!--配置spring创建容器时要扫描的包-->
    <context:component-scan base-package="com.itheima"></context:component-scan>

    <!--配置QueryRunner-->
    <bean name="runner" class="org.apache.commons.dbutils.QueryRunner" scope="prototype"></bean>

    <!--配置数据源-->
    <bean id="dataSouerce" class="com.mchange.v2.c3p0.ComboPooledDataSource">
        <!--连接数据库的必备信息-->
        <property name="driverClass" value="com.mysql.jdbc.Driver"></property>
        <property name="jdbcUrl" value="jdbc:mysql://localhost:3306/eesy"></property>
        <property name="user" value="root"></property>
        <property name="password" value="123456"></property>
    </bean>

    <!--开启spring对注解aop的支持-->
    <aop:aspectj-autoproxy></aop:aspectj-autoproxy>
</beans>
```

### 08作业-基于注解的AOP实现事务控制及问题分析2

![注解AOP控制事务的问题分析](C:/Users/Murphy/Pictures/注解AOP控制事务的问题分析.png)

需要使用环绕通知，否则顺序是乱的，改为环绕通知

```java
package com.itheima.utils;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

/**
 * 和事务管理相关的工具类，它包含了，开启事务，提交事务，回滚事务和释放连接
 */
@Component("txManager")
@Aspect
public class TransactionManager {

    @Autowired
    private ConnectionUtils connectionUtils;

    @Pointcut("execution(* com.itheima.service.impl.*.*(..))")
    private void pt1(){}


    /**
     * 开启事务
     */
    public  void beginTransaction(){
        try {
            connectionUtils.getThreadConnection().setAutoCommit(false);
        }catch (Exception e){
            e.printStackTrace();
        }
    }

    /**
     * 提交事务
     */
    public  void commit(){
        try {
            connectionUtils.getThreadConnection().commit();
        }catch (Exception e){
            e.printStackTrace();
        }
    }

    /**
     * 回滚事务
     */
    public  void rollback(){
        try {
            connectionUtils.getThreadConnection().rollback();
        }catch (Exception e){
            e.printStackTrace();
        }
    }


    /**
     * 释放连接
     */
    public  void release(){
        try {
            connectionUtils.getThreadConnection().close();//还回连接池中
            connectionUtils.removeConnection();
        }catch (Exception e){
            e.printStackTrace();
        }
    }

    @Around("pt1()")
    public Object aroundAdvice(ProceedingJoinPoint pjp){
        Object rtValue = null;
        try {
            //1.获取参数
            Object[] args = pjp.getArgs();
            //2.开启事务
            this.beginTransaction();
            //3.执行方法
            rtValue = pjp.proceed(args);
            //4.提交事务
            this.commit();

            //返回结果
            return  rtValue;

        }catch (Throwable e){
            //5.回滚事务
            this.rollback();
            throw new RuntimeException(e);
        }finally {
            //6.释放资源
            this.release();
        }
    }
}
```

### 09_spring中事务控制的一组API

```
第一：JavaEE体系进行分层开发，事务处理位于业务层，Spring提供了分层设计业务层的事务处理解决方案。 第二：spring框架为我们提供了一组事务控制的接口。具体在后面的第二小节介绍。这组接口是在spring-tx-5.0.2.RELEASE.jar中。 第三：spring的事务控制都是基于AOP的，它既可以使用编程的方式实现，也可以使用配置的方式实现。我们学习的重点是使用配置的方式实现。
```

pom.xml增加依赖

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-tx</artifactId>
    <version>5.0.2.RELEASE</version>
</dependency>
```

PlatformTransactionManager接口提供事务操作的方法，包含有3个具体的操作

```
一获取事务状态信息
	- TransactionStatus getTransaction（TransactionDefinitiondefinition）
一提交事务
	- void commit（TransactionStatus status）
一回滚事务
	- void rollback（TransactionStatus status）
	
我们在开发中都是使用它的实现类，如下：
		真正管理事务的对象 
		org.springframework.jdbc.datasource.DataSourceTransactionManager   使用Spring JDBC或iBatis 进行持久化数据时使用 			      		  org.springframework.orm.hibernate5.HibernateTransactionManager   使用Hibernate版本进行持久化数据时使用
```

TransactionDefinition
它是事务的定义信息对象，里面有如下方法：

```
获取事务对象名称
	- String getName()
获取事务隔离级
	-int getlsolationLevel()
获取事务传播行为
	- intgetPropagationBehavior()
获取事务超时时间
	- intgetTimeout()
获取事务是否只读
	- boolean isReadOnly()
	
	读写型事务：增加、删除、修改开启事务
	只读型事务：执行查询时，也会开启事务
```

事务的隔离级别

```
事务隔离级反映事务提交并发访问时的处理态度
- ISOLATION_DEFAULT
	一默认级别，归属下列某一种
- ISOLATION_READ_UNCOMMITTED
	一可以读取未提交数据
- ISOLATION_READ_COMMITTED
	一只能读取已提交数据，解决脏读问题（Oracle默认级别）
- ISOLATION_REPEATABLE_READ
	一是否读取其他事务提交修改后的数据，解决不可重复读问题（MySQL默认级别）
- ISOLATION_SERIALIZABLE
	一是否读取其他事务提交添加后的数据，解决幻影读问题
```

事务的传播行为

```
	REQUIRED:如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。一般的选择（默认值） 
	SUPPORTS:支持当前事务，如果当前没有事务，就以非事务方式执行（没有事务） 
	MANDATORY：使用当前的事务，如果当前没有事务，就抛出异常 REQUERS_NEW:新建事务，如果当前在事务中，把当前事务挂起。 
	NOT_SUPPORTED:以非事务方式执行操作，如果当前存在事务，就把当前事务挂起 
	NEVER:以非事务方式运行，如果当前存在事务，抛出异常 
	NESTED:如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行REQUIRED类似的操作。
```

超时时间

```
默认值是-1，没有超时限制。如果有，以秒为单位进行设置。
```

是否是只读事务

```
建议查询时设置为只读。
```

TransactionStatus

此接口提供的是事务具体的运行状态，方法介绍如下图：

```
TransactionStatus接口描述了某个时间点上事务对象的状态信息，包含有6个具体的操作
一刷新事务
	- void flush()
一获取是否是否存在存储点
	- boolean hasSavepoint()
一获取事务是否完成
	- boolean isCompleted()
一获取事务是否为新的事务
	- boolean isNewTransaction()
一获取事务是否回滚						设置事务回滚
	- boolean isRollbackOnly()	void setRollbackOnly()
```

### 10_spring事务控制的代码准备

新建项目day04_eesy_04tx

导入pom.xml依赖

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.itheima</groupId>
    <artifactId>day04_eesy_04tx</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
    </properties>

    <packaging>jar</packaging>

    <dependencies>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
            <version>5.0.2.RELEASE</version>
        </dependency>

        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-jdbc</artifactId>
            <version>5.0.2.RELEASE</version>
        </dependency>

        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-tx</artifactId>
            <version>5.0.2.RELEASE</version>
        </dependency>

        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-test</artifactId>
            <version>5.0.2.RELEASE</version>
        </dependency>

        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>5.1.6</version>
        </dependency>

        <dependency>
            <groupId>org.aspectj</groupId>
            <artifactId>aspectjweaver</artifactId>
            <version>1.8.7</version>
        </dependency>

        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.12</version>
            <scope>test</scope>
        </dependency>
    </dependencies>
</project>
```

使用之前day04_eesy_01jdbctemplate项目的代码 进行部分删减

### 11_spring基于XML的声明式事务控制-配置步骤

新建项目day04_eesy_05tx_xml  复制day04_eesy_04tx的代码

更改依赖，依赖如下

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xmlns:tx="http://www.springframework.org/schema/tx"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd">
```

依赖改好后，配置步骤共五步

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd">

    <!-- 配置业务层-->
    <bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl">
        <property name="accountDao" ref="accountDao"></property>
    </bean>

    <!-- 配置账户的持久层-->
    <bean id="accountDao" class="com.itheima.dao.impl.AccountDaoImpl">
        <property name="dataSource" ref="dataSource"></property>
    </bean>


    <!-- 配置数据源-->
    <bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
        <property name="driverClassName" value="com.mysql.jdbc.Driver"></property>
        <property name="url" value="jdbc:mysql://localhost:3306/eesy"></property>
        <property name="username" value="root"></property>
        <property name="password" value="1234"></property>
    </bean>

    <!-- spring中基于XML的声明式事务控制配置步骤
        1、配置事务管理器
        2、配置事务的通知
                此时我们需要导入事务的约束 tx名称空间和约束，同时也需要aop的
                使用tx:advice标签配置事务通知
                    属性：
                        id：给事务通知起一个唯一标识
                        transaction-manager：给事务通知提供一个事务管理器引用
        3、配置AOP中的通用切入点表达式
        4、建立事务通知和切入点表达式的对应关系
        5、配置事务的属性
               是在事务的通知tx:advice标签的内部

     -->
    <!-- 配置事务管理器 -->
    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"></property>
    </bean>

    <!-- 配置事务的通知-->
    <tx:advice id="txAdvice" transaction-manager="transactionManager">
        <!-- 配置事务的属性
                isolation：用于指定事务的隔离级别。默认值是DEFAULT，表示使用数据库的默认隔离级别。
                propagation：用于指定事务的传播行为。默认值是REQUIRED，表示一定会有事务，增删改的选择。查询方法可以选择SUPPORTS。
                read-only：用于指定事务是否只读。只有查询方法才能设置为true。默认值是false，表示读写。
                timeout：用于指定事务的超时时间，默认值是-1，表示永不超时。如果指定了数值，以秒为单位。
                rollback-for：用于指定一个异常，当产生该异常时，事务回滚，产生其他异常时，事务不回滚。没有默认值。表示任何异常都回滚。
                no-rollback-for：用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常时事务回滚。没有默认值。表示任何异常都回滚。
        -->
        <tx:attributes>
            <tx:method name="*" propagation="REQUIRED" read-only="false"/>
            <tx:method name="find*" propagation="SUPPORTS" read-only="true"></tx:method>
        </tx:attributes>
    </tx:advice>

    <!-- 配置aop-->
    <aop:config>
        <!-- 配置切入点表达式-->
        <aop:pointcut id="pt1" expression="execution(* com.itheima.service.impl.*.*(..))"></aop:pointcut>
        <!--建立切入点表达式和事务通知的对应关系 -->
        <aop:advisor advice-ref="txAdvice" pointcut-ref="pt1"></aop:advisor>
    </aop:config>
</beans>
```

### 12_spring基于注解的声明式事务控制

创建新项目day04_eesy_06tx_anno

pom.xml与上一个项目相同

bean.xml依赖有所不同

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xmlns:context="http://www.springframework.org/schema/context"							此处
       xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd
        http://www.springframework.org/schema/context											此处
        http://www.springframework.org/schema/context/spring-context.xsd">						此处
```

完整bean.xml如下

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd">

    <!--配置spring创建容器时要扫描的包-->              此处
    <context:component-scan base-package="com.itheima"></context:component-scan>

    <!-- 配置JdbcTemplate-->              此处
    <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
        <property name="dataSource" ref="dataSource"></property>
    </bean>


    <!-- 配置数据源-->
    <bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
        <property name="driverClassName" value="com.mysql.jdbc.Driver"></property>
        <property name="url" value="jdbc:mysql://localhost:3306/eesy"></property>
        <property name="username" value="root"></property>
        <property name="password" value="123456"></property>
    </bean>

    <!-- spring中基于XML的声明式事务控制配置步骤
        1、配置事务管理器
        2.开启spring对注解事务的支持
        3.在需要事务支持的地方使用@Transactional注解
     -->
    <!-- 配置事务管理器 -->              此处
    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"></property>
    </bean>

    <!-- 开启spring对注解事务的支持-->              此处
    <tx:annotation-driven transaction-manager="transactionManager"></tx:annotation-driven>

</beans>
```

修改业务层AccountServiceImpl

```java
package com.itheima.service.impl;

import com.itheima.domain.Account;
import com.itheima.service.IAccountService;
import com.itheima.dao.IAccountDao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

/**
 * 账户的业务层实现类
 * <p>
 * 事物控制应该都是在业务层
 */
@Service("accountService")
@Transactional(propagation = Propagation.SUPPORTS, readOnly = true, rollbackFor = Exception.class)//只读型事务的配置           此处
public class AccountServiceImpl implements IAccountService {

    @Autowired              				此处
    private IAccountDao acoountDao;   				

    @Override
    public Account findAccountById(Integer accountId) {
        return acoountDao.findAccountById(accountId);
    }

    //需要的是读写型事务配置,每个方法都要配置，所以很麻烦，还是xml方便
    @Transactional(propagation = Propagation.REQUIRED,readOnly = false)              此处
    @Override
    public void transfer(String sourceName, String targetName, Float money) {
        System.out.println("transfer......");
            //2.1.根据名称查询转出账户
            Account source = acoountDao.findAccountByName(sourceName);
            //2.2.根据名称查询转入账户
            Account target = acoountDao.findAccountByName(targetName);
            //2.3.转出账户减钱
            source.setMoney(source.getMoney() - money);
            //2.4.转入账户加钱
            target.setMoney(target.getMoney() + money);
            //2.5.更新转出账户
            acoountDao.updateAccount(source);

            int id = 1/0;
            //2.6.更新转入账户
            acoountDao.updateAccount(target);
    }
}

```

修改持久层AccountDaoImpl

```java
package com.itheima.dao.Impl;

import com.itheima.dao.IAccountDao;
import com.itheima.domain.Account;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.support.JdbcDaoSupport;
import org.springframework.stereotype.Repository;

import java.util.List;

/**
 * 账户的持久层实现类
 */
@Repository("accountDao")											此处
public class AccountDaoImpl implements IAccountDao{					此处
    /*
     使用注解不能再继承了需要自己编写一个private
     */
    @Autowired														此处
    private JdbcTemplate jdbcTemplate;                              

    @Override
    public Account findAccountById(Integer accountId) {
        List<Account> account =  jdbcTemplate.query("select * from account where id = ?",new BeanPropertyRowMapper<Account>(Account.class),accountId);
        return account.isEmpty() ? null : account.get(0);
    }

    @Override
    public Account findAccountByName(String accountName) {
        List<Account> account = jdbcTemplate.query("select * from account where name = ?",new BeanPropertyRowMapper<Account>(Account.class),accountName);
        if (account.isEmpty()){
            return null;
        }
        if (account.size()>1){
            throw new RuntimeException("结果集不唯一");
        }
        return account.get(0);
    }

    @Override
    public void updateAccount(Account account) {
        jdbcTemplate.update("update account set name = ?,money = ? where id = ?",account.getName(),account.getMoney(),account.getId());
    }
}
```

### 13_spring基于纯注解的声明式事务控制

项目day04_eesy_07anno_tx_withoutxml

pom.xml依赖与之前相同

创建配置类，这里使用了新注解

```java
package config;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;
import org.springframework.context.annotation.PropertySource;
import org.springframework.transaction.annotation.EnableTransactionManagement;

import javax.annotation.Resource;

/**
 * spring的配置类，相当于bean.xml
 */
@Configuration
@ComponentScan("com.itheima")
@Import({JdbcConfig.class,TransactionConfig.class})
@PropertySource("jdbcConfig.properties")
@EnableTransactionManagement
public class SpringConfiguration {
}
```

修改数据库

```java
package config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.datasource.DriverManagerDataSource;

import javax.sql.DataSource;

/**
 * 和连接数据库相关的配置类
 */
public class JdbcConfig {

    @Value("${jdbc.driver}")
    private String driver;

    @Value("${jdbc.url}")
    private String url;

    @Value("${jdbc.username}")
    private String username;

    @Value("${jdbc.password}")
    private String password;

    /**
     * 创建JdbcTemplate对象
     * @param dataSource
     * @return
     */
    @Bean(name = "jdbcTemplate")
    public JdbcTemplate createJdbcTemplate(DataSource dataSource) {
        return new JdbcTemplate(dataSource);
    }

    /**
     * 创建一个数据源对象
     * @return
     */
    @Bean(name = "dataSource")
    public DataSource createDataSource(){
        DriverManagerDataSource ds = new DriverManagerDataSource();
        ds.setDriverClassName(driver);
        ds.setUrl(url);
        ds.setUsername(username);
        ds.setPassword(password);
        return ds;
    }
}
```

创建JdbcCondig.properties

```xml
jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/eesy
jdbc.username=root
jdbc.password=123456
```

创建事务管理器对象

```java
package config;

import org.springframework.context.annotation.Bean;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.transaction.PlatformTransactionManager;

import javax.sql.DataSource;

public class TransactionConfig {

    /**
     * 用于创建事务管理器对象
     * @param dataSource
     * @return
     */
    @Bean(name = "transactionManager")
    public PlatformTransactionManager createTransactionManager(DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }
}
```

### 14_spring编程式事务控制1-了解

创建day04_eesy_08account_tx 新项目、

pom.xml

<!--配置事务管理器--><!--配置事务模板对象-->

```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">
    <!--配置业务层-->
    <bean id="accounService" class="com.itheima.service.impl.AccountServiceImpl">
        <property name="acoountDao" ref="accountDao"></property>
    </bean>
    <!--配置账户的持久层-->
    <bean id="accountDao" class="com.itheima.dao.Impl.AccountDaoImpl">
        <!--<property name="jdbcTemplate" ref="jdbcTemplate"> </property>-->
        <property name="dataSource" ref="dateSource"> </property>
    </bean>

    <!--配置数据源-->
    <bean id="dateSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
        <property name="driverClassName" value="com.mysql.jdbc.Driver"></property>
        <property name="url" value="jdbc:mysql://localhost:3306/eesy"></property>
        <property name="username" value="root"></property>
        <property name="password" value="123456"></property>
    </bean>

    <!--配置事务管理器-->
    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dateSource"></property>
    </bean>

    <!--配置事务模板对象-->
    <bean id="transactionTemplate" class="org.springframework.transaction.support.TransactionTemplate"></bean>
</beans>
```

### 14_spring编程式事务控制2-了解

![编程式事务](C:/Users/Murphy/Pictures/编程式事务.png)

创建TransactionTemplate

```java
package com.itheima.service.impl;

import com.itheima.domain.Account;
import com.itheima.service.IAccountService;
import com.itheima.dao.IAccountDao;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.TransactionCallback;
import org.springframework.transaction.support.TransactionTemplate;

/**
 * 账户的业务层实现类
 * <p>
 * 事物控制应该都是在业务层
 */
public class AccountServiceImpl implements IAccountService {

    private IAccountDao acoountDao;

    public void setAcoountDao(IAccountDao acoountDao) {
        this.acoountDao = acoountDao;
    }

    private TransactionTemplate transactionTemplate;

    public void setTransactionTemplate(TransactionTemplate transactionTemplate) {
        this.transactionTemplate = transactionTemplate;
    }

    @Override
    public Account findAccountById(Integer accountId) {
       return transactionTemplate.execute(new TransactionCallback<Account>() {

            @Override
            public Account doInTransaction(TransactionStatus transactionStatus) {
                return acoountDao.findAccountById(accountId);
            }
        });
    }

    @Override
    public void transfer(String sourceName, String targetName, Float money) {
        transactionTemplate.execute(new TransactionCallback<Object>() {
            @Override
            public Object doInTransaction(TransactionStatus status) {
                return null;
            }
        });
        System.out.println("transfer......");
        //2.1.根据名称查询转出账户
        Account source = acoountDao.findAccountByName(sourceName);
        //2.2.根据名称查询转入账户
        Account target = acoountDao.findAccountByName(targetName);
        //2.3.转出账户减钱
        source.setMoney(source.getMoney() - money);
        //2.4.转入账户加钱
        target.setMoney(target.getMoney() + money);
        //2.5.更新转出账户
        acoountDao.updateAccount(source);
        //2.6.更新转入账户
        acoountDao.updateAccount(target);
    }
}
```

完善pom.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">
    <!--配置业务层-->
    <bean id="accounService" class="com.itheima.service.impl.AccountServiceImpl">
        <property name="acoountDao" ref="accountDao"></property>
        <property name="transactionTemplate" ref="transactionTemplate"></property>                               此处
    </bean>
    <!--配置账户的持久层-->
    <bean id="accountDao" class="com.itheima.dao.Impl.AccountDaoImpl">
        <!--<property name="jdbcTemplate" ref="jdbcTemplate"> </property>-->
        <property name="dataSource" ref="dateSource"> </property>
    </bean>

    <!--配置数据源-->
    <bean id="dateSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
        <property name="driverClassName" value="com.mysql.jdbc.Driver"></property>
        <property name="url" value="jdbc:mysql://localhost:3306/eesy"></property>
        <property name="username" value="root"></property>
        <property name="password" value="123456"></property>
    </bean>

    <!--配置事务管理器-->
    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dateSource"></property>
    </bean>

    <!--配置事务模板对象-->
    <bean id="transactionTemplate" class="org.springframework.transaction.support.TransactionTemplate">
        <property name="transactionManager" ref="transactionManager"></property>                               此处
    </bean>

</beans>
```

### 15_spring5新特性的介绍



## 表现层:spring mvc

01-三层架构介绍和MVC设计模型介绍

```
	我们的开发架构一般都是基于两种形式，一种是C/S 架构，也就是客户端/服务器，另一种是B/S 架构，也就是浏览器服务器。在JavaEE 开发中，几乎全都是基于B/S 架构的开发。那么在B/S 架构中，系统标准的三层架构包括：表现层、业务层、持久层。三层架构在我们的实际开发中使用的非常多，所以我们课程中的案例也都是基于三层架构设计的。
	三层架构中，每一层各司其职，接下来我们就说说每层都负责哪些方面：
	表现层：
		也就是我们常说的web层。它负责接收客户端请求，向客户端响应结果，通常客户端使用http协议请求web 层，web 需要接收http 请求，完成http 响应。
		表现层包括展示层和控制层：控制层负责接收请求，展示层负责结果的展示。
		表现层依赖业务层，接收到客户端请求一般会调用业务层进行业务处理，并将处理结果响应给客户端。
		表现层的设计一般都使用MVC 模型。（MVC 是表现层的设计模型，和其他层没有关系）
	业务层：
		也就是我们常说的service 层。它负责业务逻辑处理，和我们开发项目的需求息息相关。web 层依赖业务层，但是业务层不依赖web 层。
		业务层在业务处理时可能会依赖持久层，如果要对数据持久化需要保证事务一致性。（也就是我们说的，事务应该放到业务层来控制）
	持久层：
		也就是我们是常说的dao 层。负责数据持久化，包括数据层即数据库和数据访问层，数据库是对数据进行持久化的载体，数据访问层是业务层和持久层交互的接口，业务层需要通过数据访问层将数据持久化到数据库中。通俗的讲，持久层就是和数据库交互，对数据库表进行曾删改查的。
```

```
	MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，是一种用于设计创建 Web 应用程序表现层的模式。MVC 中每个部分各司其职：
	Model（模型）：
		通常指的就是我们的数据模型。作用一般情况下用于封装数据。
	View（视图）：
		通常指的就是我们的jsp 或者html。作用一般就是展示数据的。
		通常视图是依据模型数据创建的。
	Controller（控制器）： 是应用程序中处理用户交互的部分。作用一般就是处理程序逻辑的。
```

![01](C:/Users/Murphy/Pictures/01.bmp)

### 02-SpringMVC框架的介绍

```
	SpringMVC是一种基于Java的实现MVC设计模型的请求驱动类型的轻量级Web框架，属于 Spring FrameWork 的后续产品，已经融合在Spring Web Flow里面。Spring 框架提供了构建 Web 应用程序的全功能 MVC 模块。使用 Spring 可插入的 MVC 架构，从而在使用Spring进行WEB开发时，可以选择使用 Spring 的 Spring MVC 框架或集成其他MVC开发框架，如Struts1(现在一般不用)，Struts2等。 
	SpringMVC已经成为目前最主流的 MVC 框架之一，并且随着Spring3.0的发布，全面超越 Struts2，成为最优秀的 MVC 框架。 
	它通过一套注解，让一个简单的Java类成为处理请求的控制器，而无须实现任何接口。同时它还支持RESTful编程风格的请求。
```

![01三层架构](C:/Users/Murphy/Pictures/01三层架构.png)

```
SpringMVC和Struts2的优略分析 
共同点： 
	它们都是表现层框架，都是基于MVC模型编写的。 
	它们的底层都离不开原始ServletAPI。 
	它们处理请求的机制都是一个核心控制器。 
区别： 
	Spring MVC 的入口是 Servlet, 而 Struts2 是 Filter 
	Spring MVC 是基于方法设计的，而Struts2是基于类，Struts2每次执行都会创建一个动作类。所以Spring MVC 会稍微比 Struts2 快些。 
	Spring MVC 使用更加简洁,同时还支持 JSR303, 处理 ajax 的请求更方便 
	(JSR303 是一套JavaBean参数校验的标准，它定义了很多常用的校验注解，我们可以直接将这些注解加在我们JavaBean的属性上面，就可以在需要校验的时候进行校验了。) 
	Struts2 的OGNL 表达式使页面的开发效率相比Spring MVC 更高些，但执行效率并没有比JSTL提升，尤其是struts2的表单标签，远没有html执行效率高。
```

### 03-入门程序之需求分析

![02](C:/Users/Murphy/Pictures/02.bmp)

### 04-入门程序之搭建开发环境

选择创建新项目，勾选create from archetype

![新maven项目](C:/Users/Murphy/Pictures/新maven项目.png)

填好项目名称next即可

![项目名称](C:/Users/Murphy/Pictures/项目名称.png)

创建jar包

![创建jar包](C:/Users/Murphy/Pictures/创建jar包.png)

pom.xml导入依赖

```xml
<?xml version="1.0" encoding="UTF-8"?>

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>cn.itcast</groupId>
  <artifactId>springmvc_day01_01_start</artifactId>
  <version>1.0-SNAPSHOT</version>
  <packaging>war</packaging>

  <name>springmvc_day01_01_start Maven Webapp</name>
  <!-- FIXME change it to the project's website -->
  <url>http://www.example.com</url>

  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.compiler.source>1.8</maven.compiler.source>
    <maven.compiler.target>1.8</maven.compiler.target>
    <!--版本锁定,修改方便-->
    <spring.version>5.0.2.RELEASE</spring.version>
  </properties>

  <dependencies>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-context</artifactId>
      <version>${spring.version}</version>
    </dependency>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-web</artifactId>
      <version>${spring.version}</version>
    </dependency>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-webmvc</artifactId>
      <version>${spring.version}</version>
    </dependency>
    <dependency>
      <groupId>javax.servlet</groupId>
      <artifactId>servlet-api</artifactId>
      <version>2.5</version>
      <scope>provided</scope>
    </dependency>
    <dependency>
      <groupId>javax.servlet.jsp</groupId>
      <artifactId>jsp-api</artifactId>
      <version>2.0</version>
      <scope>provided</scope>
    </dependency>
  </dependencies>

</project>

```

配置前端，Servlet控制器（基本配置）

![servlet前端控制器](C:/Users/Murphy/Pictures/servlet前端控制器.png)

resources目录下新建配置文件（叫什么没有固定写法）

![beanxml](C:/Users/Murphy/Pictures/beanxml.png)

配置tomcat

### 05-入门程序之入门代码编写

项目springmvc_day01_01_start

完善index.jsp

```jsp
<%--
  Created by IntelliJ IDEA.
  User: Murphy
  Date: 2021-09-30
  Time: 15:57
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    <h3>入门程序</h3>

    <a href="hello">入门程序</a>
</body>
</html>
```

创建控制器类

```java
package cn.itcast.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

/**
 * 控制器类
 */
@Controller
public class HelloController {

    @RequestMapping(path = "/hello")
    public String sayHello(){
        System.out.println("Hello String MVC");
        return "success";
    }

}
```

修改依赖 <!--开启注解扫描--><!--视图解析器--><!--开启spring MVC框架注解的支持-->

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
    http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/mvc
    http://www.springframework.org/schema/mvc/spring-mvc.xsd
    http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context.xsd">
    <!--开启注解扫描-->
    <context:component-scan base-package="cn.itcast"></context:component-scan>

    <!--视图解析器-->
    <bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <property name="prefix" value="/WEB-INF/pages/"/>
        <property name="suffix" value=".jsp"/>
    </bean>

    <!--开启spring MVC框架注解的支持-->
    <mvc:annotation-driven/>

</beans>
```

加载spring配置文件

```jsp
<!DOCTYPE web-app PUBLIC
 "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"
 "http://java.sun.com/dtd/web-app_2_3.dtd" >

<web-app>
  <display-name>Archetype Created Web Application</display-name>

  <servlet>
    <servlet-name>dispatcherServlet</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <init-param>
      <param-name>contextConfigLocation</param-name>                     此处
      <param-value>classpath:springmvc.xml</param-value>                 此处
    </init-param>
  <load-on-startup>1</load-on-startup>                   启动就加载  				此处
  </servlet>
  <servlet-mapping>
    <servlet-name>dispatcherServlet</servlet-name>
    <url-pattern>/</url-pattern>
  </servlet-mapping>
</web-app>
```

WEB-INF/pages/下，创建返回页面sucess,jsp

```jsp
<%--
  Created by IntelliJ IDEA.
  User: Murphy
  Date: 2021-09-30
  Time: 16:12
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    <h3>入门成功</h3>
</body>
</html>
```

### 06-入门案例的流程总结

```
入门案例的执行流程
1. 当启动Tomcat服务器的时候，因为配置了load-on-startup标签，所以会创建DispatcherServlet对象，
就会加载springmvc.xml配置文件
2. 开启了注解扫描，那么HelloController对象就会被创建
3. 从index.jsp发送请求，请求会先到达DispatcherServlet核心控制器，根据配置@RequestMapping注解
找到执行的具体方法
4. 根据执行方法的返回值，再根据配置的视图解析器，去指定的目录下查找指定名称的JSP文件
5. Tomcat服务器渲染页面，做出响应
```

![03](C:/Users/Murphy/Pictures/03.bmp)

### 07-入门案例中使用的组件介绍

![04](C:/Users/Murphy/Pictures/04.bmp)

```
入门案例中的组件分析
1. 前端控制器（DispatcherServlet）
2. 处理器映射器（HandlerMapping）
3. 处理器（Handler）
4. 处理器适配器（HandlAdapter）
5. 视图解析器（View Resolver）
6. 视图（View）
```

### 08-RequestMapping注解的作用

```
作用： 用于建立请求URL和处理请求方法之间的对应关系。 
出现位置： 
类上： 
	请求URL的第一级访问目录。此处不写的话，就相当于应用的根目录。写的话需要以/开头。 
	它出现的目的是为了使我们的URL可以按照模块化管理: 
	例如： 
	账户模块： 
	/account/add 
	/account/update 
	/account/delete ... 
	订单模块： 
	/order/add 
	/order/update 
	/order/delete 
	红色的部分就是把RequsetMappding写在类上，使我们的URL更加精细。 
方法上： 
	 请求URL的第二级访问目录。
```

演示修改代码如下

```java
package cn.itcast.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

/**
 * 控制器类
 */
@Controller
@RequestMapping(path = "/user")
public class HelloController {

    /**
     * 入门案例
     * @return
     */
    @RequestMapping(path = "/hello")
    public String sayHello(){
        System.out.println("Hello String MVC");
        return "success";
    }

    /**
     * RequestMapping注解
     * @return
     */
    @RequestMapping(path = "/testRequestMapping")
    public String  testRequestMapping(){
        System.out.println("测试RequestMapping注解...");
        return "success";
    }
}
```

```jsp
<%--
  Created by IntelliJ IDEA.
  User: Murphy
  Date: 2021-09-30
  Time: 15:57
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    <h3>入门程序</h3>
    <%--
    <a href="hello">入门程序</a>
    --%>
    <a href="user/testRequestMapping">RequestMapping注解</a>
</body>
</html>
```

访问地址就多了user      http://localhost:8080/springmvc_day01_01_start/user/testRequestMapping

### 09-RequestMapping注解的属性

```
属性：
	value：用于指定请求的URL。它和path属性的作用是一样的。 
	method：用于指定请求的方式。 GET/POST
	params：用于指定限制请求参数的条件。它支持简单的表达式。   要求请求参数的key和value必须和配置的一模一样。 
		例如： 
			params = {"accountName"}，表示请求参数必须有accountName 
			params = {"moeny!100"}，表示请求参数中money不能是100。 
	headers：用于指定限制请求消息头的条件。 
注意： 
	以上四个属性只要出现2个或以上时，他们的关系是与的关系。
```

```java
package cn.itcast.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

/**
 * 控制器类
 */
@Controller
@RequestMapping(path = "/user")
public class HelloController {

    /**
     * 入门案例
     * @return
     */
    @RequestMapping(path = "/hello")
    public String sayHello(){
        System.out.println("Hello String MVC");
        return "success";
    }

    /**
     * RequestMapping注解
     * @return
     */
    @RequestMapping(value = "/testRequestMapping",params = {"username=heihei"},headers = {"Accept"})
    public String  testRequestMapping(){
        System.out.println("测试RequestMapping注解...");
        return "success";
    }
}
```

```jsp
<%--
  Created by IntelliJ IDEA.
  User: Murphy
  Date: 2021-09-30
  Time: 15:57
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    <h3>入门程序</h3>
    <%--
    <a href="hello">入门程序</a>
    --%>
    <a href="user/testRequestMapping?username=heihei">RequestMapping注解</a>
</body>
</html>
```

### 10-请求参数绑定入门

```
1. 请求参数的绑定说明
	1. 绑定机制
		1. 表单提交的数据都是k=v格式的 username=haha&password=123
		2. SpringMVC的参数绑定过程是把表单提交的请求参数，作为控制器中方法的参数进行绑定的
		3. 要求：提交表单的name和参数的名称是相同的
	2. 支持的数据类型
		1. 基本数据类型和字符串类型
		2. 实体类型（JavaBean）
		3. 集合数据类型（List、map集合等）
2. 基本数据类型和字符串类型
	1. 提交表单的name和参数的名称是相同的
	2. 区分大小写
```

param.jsp

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    <%--请求参数绑定--%>
    <a href="param/testParam?username=hehe&password=123">请求参数绑定</a>
</body>
</html>
```

ParamController.java

```java
package cn.itcast.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

/**
 * 请求参数绑定
 */
@Controller
@RequestMapping("/param")
public class ParamController {
    /**
     * 请求参数绑定入门
     * @return
     */
    @RequestMapping("/testParam")
    public String testParam(String username,String password){
        System.out.println("执行了");
        System.out.println("你的用户名:"+username);
        System.out.println("你的密码:"+password);
        return "success";
    }
}
```

执行了
你的用户名:hehe
你的密码:123

### 11-请求参数绑定实体类型

```
3. 实体类型（JavaBean）
	1. 提交表单的name和JavaBean中的属性名称需要一致
	2. 如果一个JavaBean类中包含其他的引用类型，那么表单的name属性需要编写成：对象.属性 例如：address.name
```

一、没有引用属性的情况

创建类Account.java

```java
package cn.itcast.domain;

import java.io.Serializable;

public class Account implements Serializable {

    private String username;
    private String password;
    private Double money;

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public Double getMoney() {
        return money;
    }

    public void setMoney(Double money) {
        this.money = money;
    }

    @Override
    public String toString() {
        return "Account{" +
                "username='" + username + '\'' +
                ", password='" + password + '\'' +
                ", money=" + money +
                '}';
    }
}
```

创建页面获取数据param.jsp

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    <%--请求参数绑定--%>
    <%--
    <a href="param/testParam?username=hehe&password=123">请求参数绑定</a>
    --%>

    <form action="param/saveAccount" method="post">
        姓名：<input type="text" value="username"/></br>
        密码：<input type="text" value="password"/></br>
        金额：<input type="text" value="money"/></br>
        <input type="submit" value="提交"/></br>
    </form>
</body>
</html>
```

 创建ParamController.java封装数据

```java
package cn.itcast.controller;

import cn.itcast.domain.Account;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

/**
 * 请求参数绑定
 */
@Controller
@RequestMapping("/param")
public class ParamController {
    /**
     * 请求参数绑定把数据封装到JavaBean的类中
     * @param account
     * @return
     */
    @RequestMapping("/saveAccount")
    public String saveAccount(Account account){
        System.out.println("执行了");
        System.out.println(account);
        return "success";
    }
}
```

二、有引用属性的情况

创建User类，以便于引用

```java
package cn.itcast.domain;

import java.io.Serializable;

public class User implements Serializable {
    private String uname;
    private Integer age;

    public String getUname() {
        return uname;
    }

    public void setUname(String uname) {
        this.uname = uname;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "User{" +
                "uname='" + uname + '\'' +
                ", age=" + age +
                '}';
    }
}
```

修改Account添加引用属性User

```java
package cn.itcast.domain;

import java.io.Serializable;

public class Account implements Serializable {

    private String username;
    private String password;
    private Double money;

    private User user;

    public Account() {
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public Double getMoney() {
        return money;
    }

    public void setMoney(Double money) {
        this.money = money;
    }

    public User getUser() {
        return user;
    }

    public void setUser(User user) {
        this.user = user;
    }

    @Override
    public String toString() {
        return "Account{" +
                "username='" + username + '\'' +
                ", password='" + password + '\'' +
                ", money=" + money +
                ", user=" + user +
                '}';
    }
}
```

创建页面获取数据param.jsp

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    <%--请求参数绑定--%>
    <%--
    <a href="param/testParam?username=hehe&password=123">请求参数绑定</a>
    --%>

    <form action="param/saveAccount" method="post">
        姓名：<input type="text" name="username"/></br>
        密码：<input type="text" name="password"/></br>
        金额：<input type="text" name="money"/></br>

        用户姓名：<input type="text" name="user.uname"/></br>
        用户年龄：<input type="text" name="user.age"/></br>

        <input type="submit" value="提交"/></br>
    </form>
</body>
</html>
```

 创建ParamController.java封装数据

```java
package cn.itcast.controller;

import cn.itcast.domain.Account;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

/**
 * 请求参数绑定
 */
@Controller
@RequestMapping("/param")
public class ParamController {
    /**
     * 请求参数绑定把数据封装到JavaBean的类中
     * @param account
     * @return
     */
    @RequestMapping("/saveAccount")
    public String saveAccount(Account account){
        System.out.println("执行了");
        System.out.println(account);
        return "success";
    }
}
```

二、有引用属性的情况

### 12-配置解决中文乱码的过滤器

web.xml配过滤器解决乱码

```jsp
<!DOCTYPE web-app PUBLIC
 "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"
 "http://java.sun.com/dtd/web-app_2_3.dtd" >

<web-app>
  <display-name>Archetype Created Web Application</display-name>

  <!--配置前端控制器-->
  <servlet>
    <servlet-name>dispatcherServlet</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <init-param>
      <param-name>contextConfigLocation</param-name>
      <param-value>classpath:springmvc.xml</param-value>
    </init-param>
    <load-on-startup>1</load-on-startup>
  </servlet>
  <servlet-mapping>
    <servlet-name>dispatcherServlet</servlet-name>
    <url-pattern>/</url-pattern>
  </servlet-mapping>

  <!--配置解决中文乱码的过滤器-->
  <filter>
    <filter-name>CharacterEncodingFilter</filter-name>
    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
    <init-param>
      <param-name>encoding</param-name>
      <param-value>UTF-8</param-value>
    </init-param>
  </filter>
  <filter-mapping>
    <filter-name>CharacterEncodingFilter</filter-name>
    <url-pattern>/*</url-pattern>
  </filter-mapping>
</web-app>

```

### 13-请求参数绑定集合类型

```
4. 给集合属性数据封装
	1. JSP页面编写方式：list[0].属性
```

创建类,添加集合属性，List和Map

```java
package cn.itcast.domain;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public class Account implements Serializable {

    private String username;
    private String password;
    private Double money;

    private List<User> list;
    
    private Map<String,User> map;

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public Double getMoney() {
        return money;
    }

    public void setMoney(Double money) {
        this.money = money;
    }

    public List<User> getList() {
        return list;
    }

    public void setList(List<User> list) {
        this.list = list;
    }

    public Map<String, User> getMap() {
        return map;
    }

    public void setMap(Map<String, User> map) {
        this.map = map;
    }

    @Override
    public String toString() {
        return "Account{" +
                "username='" + username + '\'' +
                ", password='" + password + '\'' +
                ", money=" + money +
                ", list=" + list +
                ", map=" + map +
                '}';
    }
}
```

创建页面获取数据param.jsp

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>

    <%--把数据封装到Account类中,类中存在list和map集合--%>
    <form action="param/saveAccount" method="post">
        姓名：<input type="text" name="username"/></br>
        密码：<input type="text" name="password"/></br>
        金额：<input type="text" name="money"/></br>

        用户姓名：<input type="text" name="list[0].uname"/></br>
        用户年龄：<input type="text" name="list[0].age"/></br>

        用户姓名：<input type="text" name="map['one'].uname"/></br>
        用户年龄：<input type="text" name="map['one'].age"/></br>
        <input type="submit" value="提交"/></br>
    </form>
</body>
</html>
```

执行结果

```
Account{username='李四', password='54321', money=500.0, list=[User{uname='李思', age=55}], map={one=User{uname='李斯', age=66}}}
```

### 14-自定义类型转换器演示异常

常用数据类型自动转换

其它格式需要自定义转换

### 15-自定义类型转换器代码编写

```
第一步：定义一个类，实现Converter接口，该接口有两个泛型。
第二步：在spring配置文件中配置类型转换器。
		spring配置类型转换器的机制是，将自定义的转换器注册到类型转换服务中去。
第三步：在annotation-driven标签中引用配置的类型转换服务
```

创建utils类，声明接口

```java
package cn.itcast.utils;

import org.springframework.core.convert.converter.Converter;

import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * 把字符串转换日期
 */
public class StringToDateConverter implements Converter<String, Date>{
    /**
     * String source  传入进来字符串
     * @param source
     * @return
     */
    @Override
    public Date convert(String source) {
        //判断
        if (source == null) {
            throw new RuntimeException("请您传入数据");
        }else {
            DateFormat df = new SimpleDateFormat("yyyy-MM-dd");
            try {
                //把字符串转换日期
                return df.parse(source);
            } catch (Exception e) {
                throw new RuntimeException("数据类型转换出现错误 ");
            }
        }
    }
}
```

springmvc.xml <!--配置自定义类型转换器-->注册上述utils类

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
    http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/mvc
    http://www.springframework.org/schema/mvc/spring-mvc.xsd
    http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context.xsd">
    <!--开启注解扫描-->
    <context:component-scan base-package="cn.itcast"></context:component-scan>

    <!--视图解析器-->
    <bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <property name="prefix" value="/WEB-INF/pages/"/>
        <property name="suffix" value=".jsp"/>
    </bean>

    <!--配置自定义类型转换器-->                           此处
    <bean id="conversionService" class="org.springframework.context.support.ConversionServiceFactoryBean">
        <property name="converters">
            <set>
                <bean class="cn.itcast.utils.StringToDateConverter"/>
            </set>
        </property>
    </bean>

    <!--开启spring MVC框架注解的支持-->                      
     <mvc:annotation-driven conversion-service="conversionService"/>         此处

</beans>
```

执行结果

```
User{uname='呵呵', age=20, date=Sat Nov 11 00:00:00 GMT+08:00 2000}
```

### 16-获取Servlet原生的API

```
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    <a href="param/testServlet">Servlet原生的API</a>
</body>
</html>
```

```
package cn.itcast.controller;
/**
 * 请求参数绑定
 */
@Controller
@RequestMapping("/param")
public class ParamController {
    /**
     * 原生的API
     * @return
     */
    @RequestMapping("/testServlet")
    public String testServlet(HttpServletRequest request, HttpServletResponse response){
        System.out.println("执行了、、、");
        System.out.println(request);

        HttpSession session = request.getSession();
        System.out.println(session);

        ServletContext servletContext = session.getServletContext();
        System.out.println(servletContext);

        System.out.println(response);
        return "success";
    }
}
```

### 17-RequestParam注解

```
位置方法参数
作用： 
	把请求中指定名称的参数给控制器中的形参赋值。 
属性： 
	value：请求参数中的名称。 
	required：请求参数中是否必须提供此参数。默认值：true。表示必须提供，如果不提供将报错。
	简单来说就是解决请求参数和控制器参数名称不同的问题。
```

anno.jsp

```jsp
<%--
  Created by IntelliJ IDEA.
  User: Murphy
  Date: 2021-10-12
  Time: 13:52
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    <%--常用的注解--%>
    <a href="anno/testRequestParam?name=哈哈">RequestParam</a>
</body>
</html>
```

 AnnoController.java

```java
package cn.itcast.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;

/**
 * 常用注解
 */
@Controller
@RequestMapping("/anno")
public class AnnoController {

    @RequestMapping("testRequestParam")
    public String testRequestParam(@RequestParam(name = "name") String username){
        System.out.println("执行了");
        System.out.println(username);
        return "success";
    }
}
```

### 18-RequestBody注解

```
作用： 
	用于获取请求体内容。直接使用得到是key=value&key=value...结构的数据。 
	get请求方式不适用。 
属性： 
	required：是否必须有请求体。默认值是:true。当取值为true时,get请求方式会报错。如果取值为false，get请求得到是null。
	异步消息会用到
```

anno.jsp

```jsp
<%--
  Created by IntelliJ IDEA.
  User: Murphy
  Date: 2021-10-12
  Time: 13:52
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    <%----%>
    <form action="anno/testRequestBody" method="post">

        用户姓名：<input type="text" name="username"/></br>
        用户年龄：<input type="text" name="age"/></br>
        用户生日：<input type="text" name="date"/></br>

        <input type="submit" value="提交"/></br>
    </form>
</body>
</html>
```

 AnnoController.java

```java
package cn.itcast.controller;

/**
 * 常用注解
 */
@Controller
@RequestMapping("/anno")
public class AnnoController {

    /**
     * 获取到请求体的内容
     * @return
     */
    @RequestMapping("testRequestBody")
    public String testRequestBody(@RequestBody String body){
        System.out.println("执行了");
        System.out.println(body);
        return "success";
    }
}
```

### 19-PathVariable注解

```
	什么是rest： 
	REST（英文：Representational State Transfer，简称REST）描述了一个架构样式的网络系统，比如 web 应用程序。它首次出现在 2000 年 Roy Fielding 的博士论文中，他是 HTTP 规范的主要编写者之一。在目前主流的三种Web服务交互方案中，REST相比于SOAP（Simple Object Access protocol，简单对象访问协议）以及XML-RPC更加简单明了，无论是对URL的处理还是对Payload的编码，REST都倾向于用更加简单轻量的方法设计和实现。值得注意的是REST并没有一个明确的标准，而更像是一种设计的风格。 
	它本身并没有什么实用性，其核心价值在于如何设计出符合REST风格的网络接口。 
	restful的优点 
	它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。 
	restful的特性： 
	资源（Resources）：网络上的一个实体，或者说是网络上的一个具体信息。 
	它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的存在。可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的 URI 。
	要获取这个资源，访问它的URI就可以，因此 URI 即为每一个资源的独一无二的识别符。 
	表现层（Representation）：把资源具体呈现出来的形式，叫做它的表现层 （Representation）。 
	比如，文本可以用 txt 格式表现，也可以用 HTML 格式、XML 格式、JSON 格式表现，甚至可以采用二进制格式。 
	状态转化（State Transfer）：每 发出一个请求，就代表了客户端和服务器的一次交互过程。 
	HTTP协议，是一个无状态协议，即所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生“状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是 “表现层状态转化”。具体说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源。 
	restful的示例： 
	/account/1       HTTP GET ： 得到 id = 1 的 account 
	/account/1       HTTP DELETE： 删除 id = 1的 account 
	/account/1       HTTP PUT： 更新id = 1的 account
```

```
作用： 
	用于绑定url中的占位符。例如：请求url中 /delete/{id}，这个{id}就是url占位符。 url支持占位符是spring3.0之后加入的。是springmvc支持rest风格URL的一个重要标志。 
属性： 
	value：用于指定url中占位符名称。
	required：是否必须提供占位符。
```

anno.jsp

```jsp
<%--
  Created by IntelliJ IDEA.
  User: Murphy
  Date: 2021-10-12
  Time: 13:52
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    <a href="anno/testPathVariable/100">PathVariable</a>
</body>
</html>
```

 AnnoController.java

```java
package cn.itcast.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;

/**
 * 常用注解
 */
@Controller
@RequestMapping("/anno")
public class AnnoController {

    /**
     * PathVariable注解
     * @param id
     * @return
     */
    @RequestMapping("testPathVariable/{sid}")
    public String testPathVariable(@PathVariable(name = "sid") String id){
        System.out.println("执行了");
        System.out.println(id);
        return "success";
    }
}
```

### 20-HiddentHttpMethodFilter过滤器

了解

学习WebService技术的时候

WebClient使用静态方法发送请求，模拟各种请求

```
作用： 
	由于浏览器 form 表单只支持 GET 与 POST 请求，而DELETE、PUT 等 method 并不支持，Spring3.0 添加了一个过滤器，可以将浏览器请求改为指定的请求方式，发送给我们的控制器方法，使得支持 GET、POST、PUT 与DELETE 请求。 
	使用方法： 
		第一步：在web.xml中配置该过滤器。 
		第二步：请求方式必须使用post请求。 
		第三步：按照要求提供_method请求参数，该参数的取值就是我们需要的请求方式。
```

### 21-RequestHeader注解

```
作用:
	用于获取请求消息头。 
属性:
	value：提供消息头名称
	required：是否必须有此消息头 
	注： 在实际开发中一般不怎么用。
```

anno.jsp

```jsp
<%--
  Created by IntelliJ IDEA.
  User: Murphy
  Date: 2021-10-12
  Time: 13:52
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    <a href="anno/testRequestHeader">RequestHeader</a>
</body>
</html>
```

 AnnoController.java

```java
package cn.itcast.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

/**
 * 常用注解
 */
@Controller
@RequestMapping("/anno")
public class AnnoController {

    /**
     * RequestHeader注解
     * @param header
     * @return
     */
    @RequestMapping("testRequestHeader")
    public String testRequestHeader(@RequestHeader(value = "Accept") String header){
        System.out.println("执行了");
        System.out.println(header);
        return "success";
    }
}
```

执行结果,这里只选了Accept的结果

```
执行了
text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
```

### 22-CookieValue注解

```
作用: 
	用于把指定cookie名称的值传入控制器方法参数。 
属性:
	value：指定cookie的名称。 
	required：是否必须有此cookie。
```

anno.jsp

```jsp
<%--
  Created by IntelliJ IDEA.
  User: Murphy
  Date: 2021-10-12
  Time: 13:52
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    <a href="anno/testCookieValue">CookieValue</a>
</body>
</html>
```

 AnnoController.java

```java
package cn.itcast.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

/**
 * 常用注解
 */
@Controller
@RequestMapping("/anno")
public class AnnoController {

    /**
     * CookieValue注解
     * @param cookieValue
     * @return
     */
    @RequestMapping("testCookieValue")
    public String testCookieValue(@CookieValue(value = "JSESSIONID") String cookieValue){
        System.out.println("执行了");
        System.out.println(cookieValue);
        return "success";
    }
}
```

执行结果

```
执行了
E9C1DA980325C2B4813745B4B56904F8
```

### 23-ModelAttribute注解

```
作用： 
	该注解是SpringMVC4.3版本以后新加入的。它可以用于修饰方法和参数。 
	出现在方法上，表示当前方法会在控制器的方法执行之前，先执行。它可以修饰没有返回值的方法，也可以修饰有具体返回值的方法。 出现在参数上，获取指定的数据给参数赋值。 
	属性： 
	value：用于获取数据的key。key可以是POJO的属性名称，也可以是map结构的key。 
	应用场景： 
	当表单提交数据不是完整的实体类数据时，保证没有提交数据的字段使用数据库对象原来的数据。 
	例如： 
		我们在编辑一个用户时，用户有一个创建信息字段，该字段的值是不允许被修改的。在提交表单数据是肯定没有此字段的内容，一旦更新会把该字段内容置为null，此时就可以使用此注解解决问题。
```

一、先执行演示

anno.jsp

```jsp
<%--
  Created by IntelliJ IDEA.
  User: Murphy
  Date: 2021-10-12
  Time: 13:52
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>

    <form action="anno/testModelAttribute" method="post">

        用户姓名：<input type="text" name="username"/></br>
        用户年龄：<input type="text" name="age"/></br>
        用户生日：<input type="text" name="date"/></br>

        <input type="submit" value="提交"/></br>
    </form>
</body>
</html>
```

 AnnoController.java

```java
package cn.itcast.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

/**
 * 常用注解
 */
@Controller
@RequestMapping("/anno")
public class AnnoController {

    /**
     * ModelAttribute注解
     * @return
     */
    @RequestMapping("testModelAttribute")
    public String testModelAttribute(){
        System.out.println("testModelAttribute执行了");
        return "success";
    }

    @ModelAttribute
    public void showUser(){
        System.out.println("showUser执行了");
    }
}
```

执行结果

```
showUser执行了
testModelAttribute执行了
```

二、演示模拟数据提交不全场景-有返回值

anno.jsp

```jsp
<%--
  Created by IntelliJ IDEA.
  User: Murphy
  Date: 2021-10-12
  Time: 13:52
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>

    <form action="anno/testModelAttribute" method="post">

        用户姓名：<input type="text" name="uname"/></br>
        用户年龄：<input type="text" name="age"/></br>

        <input type="submit" value="提交"/></br>
    </form>
</body>
</html>
```

 AnnoController.java

```java
package cn.itcast.controller;

import cn.itcast.domain.User;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

import java.util.Date;

/**
 * 常用注解
 */
@Controller
@RequestMapping("/anno")
public class AnnoController {

    /**
     * ModelAttribute注解
     * @return
     */
    @RequestMapping("testModelAttribute")
    public String testModelAttribute(User user){
        System.out.println("testModelAttribute执行了");
        System.out.println(user);
        return "success";
    }

    /**
     * 该方法会先执行
     */
    @ModelAttribute
    public User showUser(String uname,Integer age){
        System.out.println("showUser执行了");
        //通过用户名查询数据库(模拟)
        User user = new User();
        user.setUname(uname);
        user.setAge(20);
        user.setDate(new Date());
        return user;
    }
}
```

运行结果

```
showUser执行了
testModelAttribute执行了
User{uname='呵呵', age=20, date=Thu Oct 14 17:24:13 GMT+08:00 2021}
```

二、演示模拟数据提交不全场景-无返回值

anno.jsp

```jsp
<%--
  Created by IntelliJ IDEA.
  User: Murphy
  Date: 2021-10-12
  Time: 13:52
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>

    <form action="anno/testModelAttribute" method="post">

        用户姓名：<input type="text" name="uname"/></br>
        用户年龄：<input type="text" name="age"/></br>

        <input type="submit" value="提交"/></br>
    </form>
</body>
</html>
```

 AnnoController.java

```java
package cn.itcast.controller;

import cn.itcast.domain.User;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

import java.util.Date;
import java.util.Map;

/**
 * 常用注解
 */
@Controller
@RequestMapping("/anno")
public class AnnoController {

    /**
     * ModelAttribute注解
     * @return
     */
    @RequestMapping("testModelAttribute")
    public String testModelAttribute(@ModelAttribute("abc") User user){
        System.out.println("testModelAttribute执行了");
        System.out.println(user);
        return "success";
    }

    /**
     * 该方法会先执行
     */
    @ModelAttribute
    public void showUser(String uname, Map<String,User> map){
        System.out.println("showUser执行了");
        User user = new User();
        user.setUname(uname);
        user.setAge(20);
        user.setDate(new Date());
        map.put("abc",user);
    }

}
```

### 24-SessionAttributes注解

```
作用:
	用于多次执行控制器方法间的参数共享。 
属性:
	value：用于指定存入的属性名称 
	type：用于指定存入的数据类型。
```

测试

anno.jsp

```jsp
<%--
  Created by IntelliJ IDEA.
  User: Murphy
  Date: 2021-10-12
  Time: 13:52
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java"  %>
<html>
<head>
    <title>Title</title>
</head>
<body>

    <a href="anno/testSessionAttributes">SessionAttributes</a>
</body>
</html>
```

success.jsp设置isELIgnored="false"否则不能解析域对象

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" isELIgnored="false"%>
<html>
<head>
    <title>Title</title>
</head>
<body>
    <h3>入门成功</h3>
    ${requestScope}
</body>
</html>
```

AnnoController.java

```java
package cn.itcast.controller;

import cn.itcast.domain.User;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import java.util.Date;
import java.util.Map;

/**
 * 常用注解
 */
@Controller
@RequestMapping("/anno")
public class AnnoController {

    /**
     * SessionAttributes 注解
     * @return
     */
    @RequestMapping("testSessionAttributes")
    public String testSessionAttributes(Model model){
        System.out.println("testSessionAttributes执行了");
        //底层会存储到request域对象中(直接使用HttpServletRequest就会和Servlet API的耦合过高，spring mvc提供了Model接口解决这个问题)
        model.addAttribute("msg","美美");
        return "success";
    }
}
```

1.存值

```java
package cn.itcast.controller;

import cn.itcast.domain.User;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.ui.ModelMap;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import java.util.Date;
import java.util.Map;

/**
 * 常用注解
 */
@Controller
@RequestMapping("/anno")
@SessionAttributes(value = {"msg"})//把msg=美美存入到session域对象中             此处
public class AnnoController {

    /**
     * SessionAttributes 注解
     * @return
     */
    @RequestMapping("testSessionAttributes")
    public String testSessionAttributes(Model model){
        System.out.println("testSessionAttributes执行了");
        model.addAttribute("msg","美美");
        return "success";
    }
}
```

在jsp显示值

success.jsp

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" isELIgnored="false"%>
<html>
<head>
    <title>Title</title>
</head>
<body>
    <h3>入门成功</h3>
    ${requestScope.msg}
    ${sessionScope}
</body>
</html>
```

jspj结果

```
入门成功
美美 {msg=美美}
```

2.取值

```java
@RequestMapping("getSessionAttributes")
public String getSessionAttributes(ModelMap modelMap){
    System.out.println("getSessionAttributes执行了");
    String msg = (String) modelMap.get("msg");
    System.out.println(msg);
    return "success";
}
```

控制台输出结果

```
getSessionAttributes执行了
美美
```

3.删值

```java
/**
 * 清除
 * @param status
 * @return
 */
@RequestMapping("delSessionAttributes")
public String delSessionAttributes(SessionStatus status){
    System.out.println("delSessionAttributes执行了");
    //底层会存储到request域对象中
    status.setComplete();
    return "success";
}
```

### ----------------------

### 第二部分

### 01-搭建环境

项目      springmvc_day02_01_response

pom.xml延续使用上个项目

```xml
<?xml version="1.0" encoding="UTF-8"?>

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>cn.itcast</groupId>
  <artifactId>springmvc_day02_01_response</artifactId>
  <version>1.0-SNAPSHOT</version>
  <packaging>war</packaging>

  <name>springmvc_day02_01_response Maven Webapp</name>
  <!-- FIXME change it to the project's website -->
  <url>http://www.example.com</url>

  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.compiler.source>1.8</maven.compiler.source>
    <maven.compiler.target>1.8</maven.compiler.target>
    <!--版本锁定-->
    <spring.version>5.0.2.RELEASE</spring.version>
  </properties>

  <dependencies>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-context</artifactId>
      <version>${spring.version}</version>
    </dependency>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-web</artifactId>
      <version>${spring.version}</version>
    </dependency>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-webmvc</artifactId>
      <version>${spring.version}</version>
    </dependency>
    <dependency>
      <groupId>javax.servlet</groupId>
      <artifactId>servlet-api</artifactId>
      <version>2.5</version>
      <scope>provided</scope>
    </dependency>
    <dependency>
      <groupId>javax.servlet.jsp</groupId>
      <artifactId>jsp-api</artifactId>
      <version>2.0</version>
      <scope>provided</scope>
    </dependency>
  </dependencies>

  <build>
    <finalName>springmvc_day02_01_response</finalName>
    <pluginManagement><!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) -->
      <plugins>
        <plugin>
          <artifactId>maven-clean-plugin</artifactId>
          <version>3.1.0</version>
        </plugin>
        <!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging -->
        <plugin>
          <artifactId>maven-resources-plugin</artifactId>
          <version>3.0.2</version>
        </plugin>
        <plugin>
          <artifactId>maven-compiler-plugin</artifactId>
          <version>3.8.0</version>
        </plugin>
        <plugin>
          <artifactId>maven-surefire-plugin</artifactId>
          <version>2.22.1</version>
        </plugin>
        <plugin>
          <artifactId>maven-war-plugin</artifactId>
          <version>3.2.2</version>
        </plugin>
        <plugin>
          <artifactId>maven-install-plugin</artifactId>
          <version>2.5.2</version>
        </plugin>
        <plugin>
          <artifactId>maven-deploy-plugin</artifactId>
          <version>2.8.2</version>
        </plugin>
      </plugins>
    </pluginManagement>
  </build>
</project>
```

web.xml引入前端控制器

```jsp
<!DOCTYPE web-app PUBLIC
 "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"
 "http://java.sun.com/dtd/web-app_2_3.dtd" >

<web-app>
  <display-name>Archetype Created Web Application</display-name>

  <!--配置前端控制器-->
  <servlet>
    <servlet-name>dispatcherServlet</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <init-param>
      <param-name>contextConfigLocation</param-name>
      <param-value>classpath:springmvc.xml</param-value>
    </init-param>
    <load-on-startup>1</load-on-startup>
  </servlet>
  <servlet-mapping>
    <servlet-name>dispatcherServlet</servlet-name>
    <url-pattern>/</url-pattern>
  </servlet-mapping>

  <!--配置解决中文乱码的过滤器-->
  <filter>
    <filter-name>characterEncodingFilter</filter-name>
    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
    <init-param>
      <param-name>encoding</param-name>
      <param-value>UTF-8</param-value>
    </init-param>
  </filter>
  <filter-mapping>
    <filter-name>characterEncodingFilter</filter-name>
    <url-pattern>/*</url-pattern>
  </filter-mapping>
</web-app>
```

main文件夹下，创建java文件夹、resource文件夹，resource文件夹下创建springmvc.xml文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
    http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/mvc
    http://www.springframework.org/schema/mvc/spring-mvc.xsd
    http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context.xsd">
    <!--开启注解扫描-->
    <context:component-scan base-package="cn.itcast"></context:component-scan>

    <!--视图解析器-->
    <bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <property name="prefix" value="/WEB-INF/pages/"/>
        <property name="suffix" value=".jsp"/>
    </bean>

    <!--开启spring MVC框架注解的支持-->
    <mvc:annotation-driven />

</beans>
```

WEB-INF/pages/下、创建pages文件夹，创建success.jsp用于返回成功

```jsp
<%--
  Created by IntelliJ IDEA.
  User: Murphy
  Date: 2021-10-19
  Time: 16:50
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    <h3>执行成功</h3>
</body>
</html>
```

### 02-响应之返回值是String类型

创建链接

```jsp
<%--
  Created by IntelliJ IDEA.
  User: Murphy
  Date: 2021-10-19
  Time: 18:02
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    
</head>
<body>
	<a href="user/testString">testString</a>
</body>
</html>
```

创建user；类

```java
package cn.itcast.domain;

import java.io.Serializable;

public class User implements Serializable {
    private String username;
    private String password;
    private Integer age;

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "User{" +
                "username='" + username + '\'' +
                ", password='" + password + '\'' +
                ", age=" + age +
                '}';
    }
}
```

创建控制类

```java
package cn.itcast.controller;

import cn.itcast.domain.User;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
@RequestMapping("/user")
public class UserController {

     /**
     * 返回值类型是字符串
     * @param model
     * @return
     */
    @RequestMapping("/testString")
    public String testString(Model model){
        System.out.println("testString执行了");
        //模拟从数据库中查出对象

        User user = new User();
        user.setUsername("美美");
        user.setPassword("123");
        user.setAge(3);
        //model对象

        model.addAttribute("user",user);
        return "success";
    }
}
```

确认springmvc.xml视图解析器可用

创建success.jsp

```jsp
<%--
  Created by IntelliJ IDEA.
  User: Murphy
  Date: 2021-10-19
  Time: 16:50
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" isELIgnored="false" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    <h3>执行成功</h3>
    ${user.username}
    ${user.password}
    ${user.age}
</body>
</html>
```

执行结果，web页面显示数据

```
执行成功
美美 123 3
```

### 03-响应之返回值是void类型

响应方法一，跳转

返回值是void类型默认返回页面是当前请求的路径名.jsp

![testVoid](C:/Users/Murphy/Pictures/testVoid.png)



```
如果要跳转到其它页面就需要手动转发
手动调用转发方法，不会执行视图解析器
```

```java
/**
 * 返回值类型是void
 * 请求转发一次请求，不用写项目的名称
 * @param request
 * @param response
 * @throws Exception
 */
@RequestMapping("/testVoid")
public void testVoid(HttpServletRequest request, HttpServletResponse response) throws Exception {
    System.out.println("testVoid执行了");
    //编写请求转发的程序
    request.getRequestDispatcher("/WEB-INF/pages/success.jsp").forward(request, response);
    return;
}
```

点击后web页面跳转到success.jsp

响应方法二，重定向

重定向相当于重新发了个请求,重定向不能访问WEB-INF下的内容

```java
/**
 * 返回值类型是void
 * 请求转发一次请求，不用写项目的名称
 * @param request
 * @param response
 * @throws Exception
 */
@RequestMapping("/testVoid")
public void testVoid(HttpServletRequest request, HttpServletResponse response) throws Exception {
    System.out.println("testVoid执行了");

    //重定向
    response.sendRedirect(request.getContextPath() + "/index.jsp");

    return;
}
```

点击后web页面跳转到index.jsp

响应方法三，直接响应

直接响应

```java
    /**
     * 返回值类型是void
     * 请求转发一次请求，不用写项目的名称
     * @param request
     * @param response
     * @throws Exception
     */
    @RequestMapping("/testVoid")
    public void testVoid(HttpServletRequest request, HttpServletResponse response) throws Exception {
        System.out.println("testVoid执行了");

        //解决中文乱码
        response.setCharacterEncoding("UTF-8");
        response.setContentType("text/html;charset=utf-8");
        //直接响应
        response.getWriter().print("你好");

        return;
    }
```

点击后web页面显示你好

### 04-响应之返回值是ModelAndView类型

跟返回字符串类似，只是写法不同

```java
/**
 * 返回类型是ModelAndView
 */
@RequestMapping("/testModelAndView")
public ModelAndView testModelAndView(){
    //创建ModelAndView对象
    ModelAndView mv = new ModelAndView();
    System.out.println("testModelAndView执行了");

    //模拟从数据库中查出对象

    User user = new User();
    user.setUsername("丑丑");
    user.setPassword("123");
    user.setAge(3);

    //把user对象存储到mv对象中，也会把user对象存入到request对象
    mv.addObject("user",user);

    //跳转到那个页面
    mv.setViewName("success");

    return mv;
}
```

```
执行成功
丑丑 123 3
```

### 05-响应之使用forward和redirect进行页面跳转

```
使用关键字forward和redirect是不能使用视图解析器的
```

使用关键字forward转发

```java
/**
 * 使用关键字forward和redirect进行转发和重定向
 * @return
 */
@RequestMapping("/testForwardOrRedirect")
public String testForwardOrRedirect(){
    System.out.println("testForwardOrRedirect执行了...");
    //请求的转发
    return "forward:/WEB-INF/pages/success.jsp";
}
```

使用关键字redirect重定向        

一般情况下重定向需要加项目名获取方式request.getContextPath()      这里是框架自动加了

```java
/**
 * 使用关键字forward和redirect进行转发和重定向
 * @return
 */
@RequestMapping("/testForwardOrRedirect")
public String testForwardOrRedirect(){
    System.out.println("testForwardOrRedirect执行了...");
    //重定向
    return "redirect:/index.jsp";
}
```

### 06-响应json数据之过滤静态资源

1. DispatcherServlet会拦截到所有的资源，导致一个问题就是静态资源（img、css、js）也会被拦截到，从而
    不能被使用。解决问题就是需要配置静态资源不进行拦截，在springmvc.xml配置文件添加如下配置
  1. mvc:resources标签配置不过滤
     1. location元素表示webapp目录下的包下的所有文件
     2. mapping元素表示以/static开头的所有请求路径，如/static/a 或者/static/a/b

```
<!-- 设置静态资源不过滤 -->
<mvc:resources location="/css/" mapping="/css/**"/> <!-- 样式 -->
<mvc:resources location="/images/" mapping="/images/**"/> <!-- 图片 -->
<mvc:resources location="/js/" mapping="/js/**"/> <!-- javascript -->
```

创建引入ajax，编写js

```jsp
<%--
  Created by IntelliJ IDEA.
  User: Murphy
  Date: 2021-10-19
  Time: 18:02
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
    <script src="js/jquery.min.js"></script>

    <script>
        //页面加载,绑定单击事件
        $(function(){
           $("#btn").click(function(){
               alert("hello btn");
            });
        });
    </script>
</head>
<body>

    <button id="btn">发送ajax的请求</button>
</body>
</html>
```

设置过滤

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
    http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/mvc
    http://www.springframework.org/schema/mvc/spring-mvc.xsd
    http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context.xsd">
    <!--开启注解扫描-->
    <context:component-scan base-package="cn.itcast"></context:component-scan>

    <!--视图解析器-->
    <bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <property name="prefix" value="/WEB-INF/pages/"/>
        <property name="suffix" value=".jsp"/>
    </bean>

    <!--前端控制器，哪些静态资源不拦截-->
    <mvc:resources location="/css/" mapping="/css/**"/><!-- 样式 -->
    <mvc:resources location="/images/" mapping="/images/**"/><!-- 图片 -->
    <mvc:resources location="/js/" mapping="/js/**"/><!-- javascript -->

    <!--开启spring MVC框架注解的支持-->
    <mvc:annotation-driven />

</beans>
```

注：这里如果jQuery有问题，也会导致不能弹窗，按F12提示jquery $ is not defined at xxx.jsp

### 07-响应json数据之发送ajax的请求

前台

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>主页</title>
    <script type="text/javascript" src="js/jquery.min.js"></script>

    <script type="text/javascript">
        //页面加载，绑定单机事件
        $(function(){
            $("#btn").click(function(){
                //alert("hello btn");
                //发送ajax请求
                $.ajax({
                    //编写json格式，设置属性和值
                    url:"user/testAjax",
                    contentType:"application/json;charset=UTF-8",
                    data:'{"username":"hehe","password":"123","age":"30"}',
                    dataType:"json",
                    type:"post",
                    success:function (data) {
                        //data服务器端响应的json的数据，进行解析

                    }
                });
            });
        });
    </script>

</head>
<body>
    <button id="btn">提交</button>
</body>
</html>
```

后台获取数据                   位置UserController.java

```java
/**
 * 模拟异步请求和响应
 * @return
 */
@RequestMapping("/testAjax")
public void testAjax(@RequestBody String body){
    System.out.println("testAjax执行了...");
    System.out.println(body);

}
```

### 08-响应json数据之响应json格式数据

```
需求： 
	使用@ResponseBody注解实现将controller方法返回对象转换为json响应给客户端。 
前置知识点： 
	Springmvc默认用MappingJacksonHttpMessageConverter对json数据进行转换，需要加入jackson的包。如图
```

![image-20211021114059657](C:/Users/Murphy/Pictures/image-20211021114059657.png)

在pom.xml引入

```xml
	<dependency>
      <groupId>com.fasterxml.jackson.core</groupId>
      <artifactId>jackson-databind</artifactId>
      <version>2.9.0</version>
    </dependency>
    <dependency>
      <groupId>com.fasterxml.jackson.core</groupId>
      <artifactId>jackson-core</artifactId>
      <version>2.9.0</version>
    </dependency>
    <dependency>
      <groupId>com.fasterxml.jackson.core</groupId>
      <artifactId>jackson-annotations</artifactId>
      <version>2.9.0</version>
    </dependency>
```

框架就会自动封装数据到对象       直接使用User即可

```java
/**
 * 模拟异步请求和响应
 * @return
 */
@RequestMapping("/testAjax")
public @ResponseBody User testAjax(@RequestBody User user){
    System.out.println("testAjax执行了...");
    //客户端发送ajax的请求，传的是json字符串，后端把json字符串封装到user对象中
    System.out.println(user);
    //作响应，模拟查询数据库
    user.setUsername("haha");
    user.setAge(40);
    //做响应
    return user;
}
```

### 09-文件上传之上传原理分析和搭建环境

项目      springmvc_day02_02_fileupload

文件上传的前提

```
A form表单的enctype取值必须是：multipart/form-data 
		(默认值是:application/x-www-form-urlencoded) 
		enctype:是表单请求正文的类型 
B method属性取值必须是Post 
C 提供一个文件选择域<input type=”file” />
```

文件上传的原理分析

```
当form表单的enctype取值不是默认值后，request.getParameter()将失效。 
enctype=”application/x-www-form-urlencoded”时，form表单的正文内容是：
key=value&key=value&key=value 
当form表单的enctype取值为Mutilpart/form-data时，请求正文内容就变成： 
每一部分都是MIME类型描述的正文
-----------------------------7de1a433602ac        分界符 
Content-Disposition: form-data; name="userName"   协议头
aaa                                               协议的正文 
-----------------------------7de1a433602ac 		  分界符 
Content-Disposition: form-data; name="file"; 
filename="C:\Users\zhy\Desktop\fileupload_demofile\b.txt" 
Content-Type: text/plain 						  协议的类型（MIME类型）

bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
-----------------------------7de1a433602ac--
```

解析过于麻烦所以借助于第三方组件

借助第三方组件实现文件上传

```
	使用Commons-fileupload组件实现文件上传，需要导入该组件相应的支撑jar包：Commons-fileupload和commons-io。commons-io 不属于文件上传组件的开发jar文件，但Commons-fileupload 组件从1.1 版本开始，它工作时需要commons-io包的支持。
```

![image-20211021152823778](C:/Users/Murphy/Pictures/image-20211021152823778.png)

需要在pom.xml添加依赖

```
<dependency>
	<groupId>commons-fileupload</groupId>
	<artifactId>commons-fileupload</artifactId>
	<version>1.3.1</version>
</dependency>
<dependency>
	<groupId>commons-io</groupId>
	<artifactId>commons-io</artifactId>
	<version>2.4</version>
</dependency>
```

创建新项目 springmvc_day02_02_fileupload，与之前项目类似

### 10-文件上传之传统方式上传代码回顾

创建表单

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    <h3>文件上传</h3>

    <form action="user/fileupload1" method="post" enctype="multipart/form-data">
        选择文件：<input type="file" name="upload"/><br>
        <input type="submit" value="上传">
    </form>
</body>
</html>
```

添加文件上传依赖jar包

```xml
<dependency>
	<groupId>commons-fileupload</groupId>
	<artifactId>commons-fileupload</artifactId>
	<version>1.3.1</version>
</dependency>
<dependency>
	<groupId>commons-io</groupId>
	<artifactId>commons-io</artifactId>
	<version>2.4</version>
</dependency>
```

控制方法

```java
/**
 * 文件上传
 * @return
 */
@RequestMapping("/fileupload1")
public String fileuoload1(HttpServletRequest request) throws Exception {
    System.out.println("文件上传...");

    // 使用fileupload组件完成文件上传
    // 上传的位置
    String path = request.getSession().getServletContext().getRealPath("/uploads/");
    // 判断，该路径是否存在
    File file = new File(path);
    if(!file.exists()){
        // 创建该文件夹
        file.mkdirs();
    }

    // 解析request对象，获取上传文件项
    DiskFileItemFactory factory = new DiskFileItemFactory();
    ServletFileUpload upload = new ServletFileUpload(factory);
    // 解析request
    List<FileItem> items = upload.parseRequest(request);
    // 遍历
    for(FileItem item:items){
        // 进行判断，当前item对象是否是上传文件项
        if(item.isFormField()){
            // 说明普通表单向
        }else{
            // 说明上传文件项
            // 获取上传文件的名称
            String filename = item.getName();
            // 把文件的名称设置唯一值，uuid
            String uuid = UUID.randomUUID().toString().replace("-", "");
            filename = uuid+"_"+filename;
            // 完成文件上传
            item.write(new File(path,filename));
            // 删除临时文件
            item.delete();
        }
    }

    return "success";
}
```

测试显示404，已确认代码没问题，此问题已经解决，注意action="user/fileupload1"   user前无/   但是经过测试文件并未写入，原因未知

### 11-文件上传之Springmvc方式上传原理分析

```
SpringMVC框架提供了MultipartFile对象，该对象表示上传的文件，要求变量名称必须和表单file标签的
name属性名称相同
```

```
<!-- 配置文件解析器对象，要求id名称必须是multipartResolver -->
<bean id="multipartResolver"
class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
<property name="maxUploadSize" value="10485760"/>
</bean>
```

![03-原理](C:/Users/Murphy/Pictures/03-原理.bmp)

### 12-文件上传之Springmvc方式上传代码

springmvc.xml配置文件解析器

```xml
<!--配置文件解析器对象-->
<bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
    <property name="maxUploadSize" value="10485760" />
</bean>
```

后台控制器

```java
/**
 * SpringMVC文件上传
 *
 * @return
 */
@RequestMapping("/fileupload2")
public String fileuoload2(HttpServletRequest request, MultipartFile upload) throws Exception {
    System.out.println("springmvc文件上传...");

    // 使用fileupload组件完成文件上传
    // 上传的位置
    String path = request.getSession().getServletContext().getRealPath("/uploads/");
    // 判断，该路径是否存在
    File file = new File(path);
    if (!file.exists()) {
        // 创建该文件夹
        file.mkdirs();
    }

    // 说明上传文件项
    // 获取上传文件的名称
    String filename = upload.getOriginalFilename();
    // 把文件的名称设置唯一值，uuid
    String uuid = UUID.randomUUID().toString().replace("-", "");
    filename = uuid + "_" + filename;
    // 完成文件上传
    upload.transferTo(new File(path, filename));

    return "success";
}
```

### 13-文件上传之跨服务器上传分析和搭建环境

```
在实际开发中，我们会有很多处理不同功能的服务器。
例如： 
	应用服务器：负责部署我们的应用 
	数据库服务器：运行我们的数据库 
	缓存和消息服务器：负责处理大并发访问的缓存和消息 
	文件服务器：负责存储用户上传文件的服务器。
```

![04](C:/Users/Murphy/Pictures/04-16351675637531.bmp)

实现SpringMVC跨服务器方式文件上传

1.导入开发需要的jar包

![image-20211025211729676](C:/Users/Murphy/Pictures/image-20211025211729676.png)

pom.xml导入依赖

```
<dependency>
	<groupId>com.sun.jersey</groupId>
	<artifactId>jersey-core</artifactId>
	<version>1.18.1</version>
</dependency>
<dependency>
	<groupId>com.sun.jersey</groupId>
	<artifactId>jersey-client</artifactId>
	<version>1.18.1</version>
</dependency>
```

14-文件上传之跨服务器上传代码

前端

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>

<h3>跨服务器文件上传</h3>

<form action="user/fileupload3" method="post" enctype="multipart/form-data">
    选择文件：<input type="file" name="upload" /><br/>
    <input type="submit" value="上传" />
</form>

</body>
</html>
```

后台

```java
/**
 * 跨服务器文件上传
 *
 * @return
 */
@RequestMapping("/fileupload3")
public String fileuoload3(MultipartFile upload) throws Exception {
    System.out.println("跨服务器文件上传...");

    // 定义上传文件服务器路径
    String path = "http://localhost:9090/uploads/";

    // 说明上传文件项
    // 获取上传文件的名称
    String filename = upload.getOriginalFilename();
    // 把文件的名称设置唯一值，uuid
    String uuid = UUID.randomUUID().toString().replace("-", "");
    filename = uuid + "_" + filename;

    // 创建客户端的对象
    Client client = Client.create();

    // 和图片服务器进行连接
    WebResource webResource = client.resource(path + filename);

    // 上传文件
    webResource.put(upload.getBytes());

    return "success";
}
```

### 15-SpringMVC异常处理之分析和搭建环境

项目springmvc_day02_03_exception

```
异常处理思路
1. Controller调用service，service调用dao，异常都是向上抛出的，最终有DispatcherServlet找异常处理器进
行异常的处理。
```

![05](C:/Users/Murphy/Pictures/05.bmp)

### 16-SpringMVC异常处理之演示程序异常

异常抛出

```
package cn.itcast.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
@RequestMapping("/user")
public class Usercontroller {

    @RequestMapping("/testException")
    public String testException() throws Exception{
        System.out.println("testException执行了");
        //模拟异常
        int a = 10/0;
        return "success";
    }
}
```

web页面显示500

![500](C:/Users/Murphy/Pictures/500.png)

### 17-SpringMVC异常处理之异常处理代码编写

```
1.编写自定义异常类（做提示信息的）
2.编写异常处理器
	需要实现接口      HandlerExceptionResolver
3.配置异常处理器（跳转到提示页面）
```

1.编写自定义异常类（做提示信息的）

```java
package cn.itcast.exception;

/**
 * 自定义异常类
 */
public class SysException extends Exception{

    //存储提示信息的
    private String message;

    @Override
    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }

    //构造方法，用异常对象的时候必须传入提示信息
    public SysException(String message) {
        this.message = message;
    }
}
```

改造方法

```java
package cn.itcast.controller;

import cn.itcast.exception.SysException;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
@RequestMapping("/user")
public class Usercontroller {

    @RequestMapping("/testException")
    public String testException() throws SysException{
        System.out.println("testException执行了");

        try {
            //模拟异常
            int a = 10/0;
        } catch (Exception e) {
            //打印异常
            e.printStackTrace();
            //抛出自定义异常信息
            throw new SysException("查询所有用户出现错误了");
        }

        return "success";
    }
}
```

2.编写异常处理器

```java
package cn.itcast.exception;

import org.springframework.web.servlet.HandlerExceptionResolver;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * 异常处理器
 */
public class SysExceptionResolver implements HandlerExceptionResolver {
    /**
     *  处理异常业务逻辑
     * @param request
     * @param response
     * @param o
     * @param e
     * @return
     */
    @Override
    public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {
        //准备获取到异常对象
        SysException e = null;
        if (ex instanceof SysException){
            e = (SysException) ex;
        }else {
            e = new SysException("系统正在维护");
        }
        //创建ModelAndView对象
        ModelAndView mv = new ModelAndView();
        mv.addObject("errorMsg",e.getMessage());
        mv.setViewName("error");
        return mv;
    }
}
```

3.springmvc.xml,配置异常处理器

```xml
<!--配置异常处理器-->
<bean id="SysExceptionResolver" class="cn.itcast.exception.SysExceptionResolver"></bean>
```

其它，错误页面

```jsp
<%--
  Created by IntelliJ IDEA.
  User: Murphy
  Date: 2021-10-26
  Time: 16:32
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" isELIgnored="false" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    ${errorMsg}
</body>
</html>
```

### 18-SpringMVC拦截器之介绍和搭建环境

创建新项目springmvc_day02_04_interceptor

```
	Spring MVC 的处理器拦截器类似于Servlet开发中的过滤器Filter，用于对处理器进行预处理和后处理。 
	用户可以自己定义一些拦截器来实现特定的功能。
		过滤器是servlet规范中的一部分，任何java web工程都可以使用。 
	拦截器是SpringMVC框架自己的，只有使用了SpringMVC框架的工程才能用。 
		过滤器在url-pattern中配置了/*之后，可以对所有要访问的资源拦截。 
	拦截器它是只会拦截访问的控制器方法，如果访问的是jsp，html,css,image或者js是不会进行拦截的。 
		它也是AOP思想的具体应用。 
		我们要想自定义拦截器， 要求必须实现：HandlerInterceptor接口。
```

![05](C:/Users/Murphy/Pictures/05-16352383345582.bmp)

### 19-SpringMVC拦截器之编写controller

环境与之前基本相同

前端

```
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>

    <h3>拦截器</h3>

    <a href="user/testInterceptor">拦截器</a>
</body>
</html>
```

后端

```
package cn.itcast.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
@RequestMapping("/user")
public class Usercontroller {

    @RequestMapping("/testInterceptor")
    public String testInterceptor(){
        System.out.println("testInterceptor执行了");

        return "success";
    }
}
```

![06](C:/Users/Murphy/Pictures/06.bmp)

### 20-SpringMVC拦截器之拦截器入门代码

1.编写拦截器

```java
package cn.itcast.Interceptor;

import org.springframework.web.servlet.HandlerInterceptor;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * 自定义拦截器
 */
public class Interceptor1 implements HandlerInterceptor {
    /**
     * 预处理，controller方法执行前
     * return true放行，执行下一个拦截器，如果没有，执行controller中的方法
     * return false不放行,
     * @param request
     * @param response
     * @param handler
     * @return
     * @throws Exception
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("MyInterceptor执行了。。。");
        return true;
    }
}
```

2.springmvc.xml配置拦截器

```xml
<!--配置拦截器-->
<mvc:interceptors>
    <!--配置拦截器-->
    <mvc:interceptor>
        <!-- 要拦截的具体的方法-->
        <mvc:mapping path="/user/*"/>
        <!--不要拦截的具体的方法-->
        <!--<mvc:exclude-mapping path=""/>-->
        <!--配置拦截器对象-->
        <bean class="cn.itcast.Interceptor.Interceptor1"/>
    </mvc:interceptor>
</mvc:interceptors>
```

返回

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    <h3>执行成功</h3>
    <%System.out.println("success.jsp执行了...");%>
</body>
</html>
```

### 21-SpringMVC拦截器之拦截器接口方法演示

```java
package cn.itcast.controller.Interceptor;

import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * 自定义拦截器
 */
public class Interceptor1 implements HandlerInterceptor {
    /**
     * 预处理，controller方法执行前
     * return true放行，执行下一个拦截器，如果没有，执行controller中的方法
     * return false不放行,
     * @param request
     * @param response
     * @param handler
     * @return
     * @throws Exception
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("MyInterceptor执行了。。。前");
        //request.getRequestDispatcher("/WEB-INF/pages/error.jsp").forward(request, response);
        return true;
    }

    /**
     * 后处理方法，controller方法执行后，success.jsp执行之前
     * @param request
     * @param response
     * @param handler
     * @param modelAndView
     * @throws Exception
     */
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println("MyInterceptor执行了。。。后");
        //request.getRequestDispatcher("/WEB-INF/pages/error.jsp").forward(request, response);
        /*预处理 return true; request.getRequestDispatcher("/WEB-INF/pages/error.jsp").forward(request, response);
        输出结果（success.jsp也会执行):
        MyInterceptor执行了。。。前
        testInterceptor执行了
        MyInterceptor执行了。。。后
        success.jsp执行了...
        * */
    }

    /**
     * success.jsp页面执行后，该方法会执行
     * @param request
     * @param response
     * @param handler
     * @param ex
     * @throws Exception
     */
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println("MyInterceptor执行了。。。最后");
        /*执行结果
        MyInterceptor执行了。。。前
        testInterceptor执行了
        MyInterceptor执行了。。。后
        success.jsp执行了...
        MyInterceptor执行了。。。最后
        */
    }
}
```

```
作用
preHandle预处理      逻辑判断：判断登录
postHandle后处理     方法执行后
afterCompletion		释放资源，关闭流
```

当拦截器配两个时，按照图上的流程走

```
MyInterceptor执行了。。。前111
MyInterceptor执行了。。。前222
testInterceptor执行了
MyInterceptor执行了。。。后222
MyInterceptor执行了。。。后111
success.jsp执行了...
MyInterceptor执行了。。。最后222
MyInterceptor执行了。。。最后111
```

### ----------------------

### 第三部分

### 01-ssm整合说明

整合方向：用Spring去整合其它

![01](C:/Users/Murphy/Pictures/01-16353397346441.bmp)

### 02-ssm整合之搭建环境

```
1.整合说明：SSM整合可以使用多种方式，选择XML + 注解的方式
```

```
2.整合的思路
	1. 先搭建整合的环境
	2. 先把Spring的配置搭建完成
	3. 再使用Spring整合SpringMVC框架
	4. 最后使用Spring整合MyBatis框架
```

```
3.创建数据库和表结构
	1. 语句
	create database ssm;
		use ssm;
		create table account(
		id int primary key auto_increment,
		name varchar(20),
		money double
	);
```

```
4创建maven的工程（今天会使用到工程的聚合和拆分的概念，这个技术maven高级会讲）
	※1. 创建ssm_parent父工程（打包方式选择pom，必须的）
	2. 创建ssm_web子模块（打包方式是war包）
	※3. 创建ssm_service子模块（打包方式是jar包）
	※4. 创建ssm_dao子模块（打包方式是jar包）
	※5. 创建ssm_domain子模块（打包方式是jar包）
	※6. web依赖于service，service依赖于dao，dao依赖于domain
	※7. 在ssm_parent的pom.xml文件中引入坐标依赖
	※8. 部署ssm_web的项目，只要把ssm_web项目加入到tomcat服务器中即可
```

### 03-ssm整合之编写Spring框架

※1. 在ssm_web项目中创建applicationContext.xml的配置文件，编写具体的配置信息。

完整配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context.xsd
    http://www.springframework.org/schema/aop
    http://www.springframework.org/schema/aop/spring-aop.xsd
    http://www.springframework.org/schema/tx
    http://www.springframework.org/schema/tx/spring-tx.xsd">

    <!--开启注解的扫描,希望处理service和dao；controller不要Spring框架去处理-->
    <context:component-scan base-package="cn.itcast">
        <!--配置哪些注解不扫描-->
        <context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/>
    </context:component-scan>


</beans>
```

​		创建接口

```java
package cn.itcast.service;

import cn.itcast.dao.AccountDao;

import java.util.List;

public interface AccountService {
    //查询所有账户
    public List<Account> findAll();

    //
    public void saveAccount(Account account);
}

```

​		创建类继承接口

```java
package cn.itcast.service.impl;

import cn.itcast.dao.AccountDao;
import cn.itcast.service.AccountService;
import org.springframework.stereotype.Service;

import java.util.List;

@Service("accountService")
public class AccountServiceImpl implements AccountService {

    public List<Account> findAll() {
        System.out.println("业务层：查询所有账户...");
        return null;
    }


    public void saveAccount(Account account) {
        System.out.println("业务层：保存账户...");
    }
}
```

2. 在ssm_web项目中编写测试方法，进行测试

```java

package cn.itcast.test;

import cn.itcast.service.AccountService;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class testSpring {

    @Test
    public void run1() {
        //加载配置文件
        ApplicationContext ac = new ClassPathXmlApplicationContext("classpath:applicationContext.xml");
        //获取对象
        AccountService as = (AccountService) ac.getBean("accountService");
        //调用方法
        as.findAll();
    }
}
```

### 04-ssm整合之编写SpringMVC框架

1. 在web.xml中配置DispatcherServlet前端控制器
2. 在web.xml中配置DispatcherServlet过滤器解决中文乱码

```jsp
<!DOCTYPE web-app PUBLIC
 "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"
 "http://java.sun.com/dtd/web-app_2_3.dtd" >

<web-app>
  <display-name>Archetype Created Web Application</display-name>
  <!--配置前端控制器-->
  <servlet>
    <servlet-name>dispatcherServlet</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <!--加载springmvc.xml配置文件-->
    <init-param>
      <param-name>contextConfigLocation</param-name>
      <param-value>classpath:springmvc.xml</param-value>
    </init-param>
    <!--启动服务器-->
    <load-on-startup>1</load-on-startup>
  </servlet>
  <servlet-mapping>
    <servlet-name>dispatcherServlet</servlet-name>
    <url-pattern>/</url-pattern>
  </servlet-mapping>

  <!--解决中文乱码的过滤器-->
  <filter>
    <filter-name>characterEncodingFilter</filter-name>
    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
    <init-param>
      <param-name>encoding</param-name>
      <param-value>UTF-8</param-value>
    </init-param>
  </filter>
  <filter-mapping>
    <filter-name>characterEncodingFilter</filter-name>
    <url-pattern>/*</url-pattern>
  </filter-mapping>
</web-app>

```

3.创建springmvc.xml的配置文件，编写配置文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
    http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/mvc
    http://www.springframework.org/schema/mvc/spring-mvc.xsd
    http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context.xsd">

    <!--开启注解扫描，只扫描Controller注解-->
    <context:component-scan base-package="cn.itcast">
        <context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/>
    </context:component-scan>
    <!--配置视图解析器对象-->
    <bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <property name="prefix" value="/WEB-INF/pages/"></property>
        <property name="suffix" value=".jsp"></property>
    </bean>

    <!--过滤静态资源-->
    <mvc:resources location="/css/" mapping="/css/**" />
    <mvc:resources location="/images/" mapping="/images/**" />
    <mvc:resources location="/js/" mapping="/js/**" />

    <!--开启SpringMVC注解的支持-->
    <mvc:annotation-driven/>
</beans>
```

4.测试SpringMVC的框架搭建是否成功

​		1.编写index.jsp和list.jsp编写，超链接

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    <a href="account/findAll">测试</a>
</body>
</html>

```

​		2.创建AccountController类，编写方法，进行测试

```java
package cn.itcast.controller;

import cn.itcast.service.AccountService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

/**
 * 账户web
 */
@Controller
@RequestMapping("/account")
public class AccountController {

    @RequestMapping("findAll")
    public String findAl(){
        System.out.println("表现层：查询所有账户...");
        return "list";
    }
}
```

### 05-ssm整合之Spring整合SpringMVC的框架

![02](C:/Users/Murphy/Pictures/02-16354307875932.bmp)

依赖坐标是spring-web，自动整合

1.目的：在controller中能成功的调用service对象中的方法。

2.在项目启动的时候，就去加载applicationContext.xml的配置文件，在web.xml中配置
ContextLoaderListener监听器（该监听器只能加载WEB-INF目录下的applicationContext.xml的配置文
件）。

整合后的web.xml

```xml
<!DOCTYPE web-app PUBLIC
 "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"
 "http://java.sun.com/dtd/web-app_2_3.dtd" >

<web-app>
  <display-name>Archetype Created Web Application</display-name>

  <!--配置Spring的监听器,默认只加载WEB-INF下的applicationContex.xml配置文件-->
  <listener>
    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
  </listener>
  <!--设置配置文件的路径,监听器就知道找类路径下的文件-->
  <context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>classpath:applicationContext.xml</param-value>
  </context-param>

  <!--配置前端控制器-->
  <servlet>
    <servlet-name>dispatcherServlet</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <!--加载springmvc.xml配置文件-->
    <init-param>
      <param-name>contextConfigLocation</param-name>
      <param-value>classpath:springmvc.xml</param-value>
    </init-param>
    <!--启动服务器-->
    <load-on-startup>1</load-on-startup>
  </servlet>
  <servlet-mapping>
    <servlet-name>dispatcherServlet</servlet-name>
    <url-pattern>/</url-pattern>
  </servlet-mapping>

  <!--解决中文乱码的过滤器-->
  <filter>
    <filter-name>characterEncodingFilter</filter-name>
    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
    <init-param>
      <param-name>encoding</param-name>
      <param-value>UTF-8</param-value>
    </init-param>
  </filter>
  <filter-mapping>
    <filter-name>characterEncodingFilter</filter-name>
    <url-pattern>/*</url-pattern>
  </filter-mapping>
</web-app>
```

3.在controller中注入service对象，调用service对象的方法进行测试

```java
package cn.itcast.controller;

import cn.itcast.service.AccountService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

/**
 * 账户web
 */
@Controller
@RequestMapping("/account")
public class AccountController {

    @Autowired
    private AccountService accountService;

    @RequestMapping("findAll")
    public String findAl(){
        System.out.println("表现层：查询所有账户...");
        //调用service的方法
        accountService.findAll();
        return "list";
    }
}
```

执行结果

```
web输出
查询所有账户
```

```
控制台输出
表现层：查询所有账户...
业务层：查询所有账户...
```

### 06-ssm整合之编写MyBatis框架

1.在web项目中编写SqlMapConfig.xml的配置文件，编写核心配置文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>

    <!--配置环境-->
    <environments default="mysql">
        <environment id="mysql">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="com.mysql.jdbc.Driver"/>
                <property name="url" value="jdbc:mysql:///ssm"/>
                <property name="username" value="root"/>
                <property name="password" value="123456"/>
            </dataSource>
        </environment>
    </environments>

    <!-- 引入映射配置文件 -->
    <mappers>
        <!-- <mapper class="cn.itcast.dao.AccountDao"/> -->
        <!-- 该包下所有的dao接口都可以使用 -->
        <package name="cn.itcast.dao"/>
    </mappers>
</configuration>
```

2.在AccountDao接口的方法上添加注解，编写SQL语句

```java
package cn.itcast.dao;

import cn.itcast.domain.Account;
import org.apache.ibatis.annotations.Insert;
import org.apache.ibatis.annotations.Select;

import java.util.List;

/**
 * 账户dao接口
 */
public interface AccountDao {

    //查询所有账户
    @Select("select * from account")
    public List<Account> findAll();

    //保存账户信息
    @Insert("insert into account (name,money) values (#{name},#{money})")
    public void saveAccount(Account account);
}
```

3.编写测试的方法

```java
package cn.itcast.test;

import cn.itcast.dao.AccountDao;
import cn.itcast.domain.Account;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.Test;

import java.io.InputStream;
import java.util.List;

public class testMyBatis {
    @Test
    public void run1() throws Exception {
        //加载MyBatis配置文件
        InputStream in = Resources.getResourceAsStream("SqlMapConfig.xml");
        //创建SqlSessionFactory对象
        SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in);
        //创建SQLSession对象
        SqlSession session = factory.openSession();
        //获取到代理对象
        AccountDao dao = session.getMapper(AccountDao.class);
        //查询所有数据
        List<Account> list = dao.findAll();
        for (Account account : list) {
            System.out.println(account);
        }
        //关闭资源
        session.close();
        in.close();;
    }
}
```

### 07-ssm整合之编写MyBatis框架测试保存的方法

注意增删改用session.commit()提交事务

```java
/**
 * 测试保存
 * @throws Exception
 */
@Test
public void run2() throws Exception {

    Account account = new Account();
    account.setName("熊大");
    account.setMoney(100d);

    //加载MyBatis配置文件
    InputStream in = Resources.getResourceAsStream("SqlMapConfig.xml");
    //创建SqlSessionFactory对象
    SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in);
    //创建SQLSession对象
    SqlSession session = factory.openSession();
    //获取到代理对象
    AccountDao dao = session.getMapper(AccountDao.class);

    //保存
    dao.saveAccount(account);

    //提交事务
    session.commit();

    //关闭资源
    session.close();
    in.close();;
}
```

### 08-ssm整合之Spring整合MyBatis框架

1.把SqlMapConfig.xml配置文件中的内容配置到applicationContext.xml配置文件中

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context.xsd
    http://www.springframework.org/schema/aop
    http://www.springframework.org/schema/aop/spring-aop.xsd
    http://www.springframework.org/schema/tx
    http://www.springframework.org/schema/tx/spring-tx.xsd">

    <!--开启注解的扫描,希望处理service和dao；controller不要Spring框架去处理-->
    <context:component-scan base-package="cn.itcast">
        <!--配置哪些注解不扫描-->
        <context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/>
    </context:component-scan>

    <!--Spring整合MyBatis框架-->
    <!--配置连接池-->
    <bean id="DataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
        <property name="driverClass" value="com.mysql.jdbc.Driver"></property>
        <property name="jdbcUrl" value="jdbc:mysql:///ssm"></property>
        <property name="user" value="root"></property>
        <property name="password" value="123456"></property>
    </bean>

    <!--配置SqlSessionFactory工厂-->
    <bean id="SqlSessionFactoryBean" class="org.mybatis.spring.SqlSessionFactoryBean">
        <property name="dataSource" ref="DataSource"/>
    </bean>

    <!--配置AccountDao接口所在包-->
    <bean id="MapperScanner" class="org.mybatis.spring.mapper.MapperScannerConfigurer">
        <property name="basePackage" value="cn.itcast.dao"/>
    </bean>
</beans>
```

2.在AccountDao接口中添加@Repository注解

```java
package cn.itcast.dao;

import cn.itcast.domain.Account;
import org.apache.ibatis.annotations.Insert;
import org.apache.ibatis.annotations.Select;
import org.springframework.stereotype.Repository;

import java.util.List;

/**
 * 账户dao接口
 */
@Repository
public interface AccountDao {

    //查询所有账户
    @Select("select * from account")
    public List<Account> findAll();

    //保存账户信息
    @Insert("insert into account (name,money) values (#{name},#{money})")
    public void saveAccount(Account account);
}
```

3.在service中注入dao对象，进行测试

```java
@Autowired
private AccountDao accountDao;

public List<Account> findAll() {
    System.out.println("业务层：查询所有账户...");
    return accountDao.findAll();
}
```

controller

```java
@Autowired
private AccountService accountService;

@RequestMapping("findAll")
public String findAl(Model model){
    System.out.println("表现层：查询所有账户...");
    //调用service的方法
    List<Account> list = accountService.findAll();
    model.addAttribute("list",list);
    return "list";
}
```

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" isELIgnored="false" %>
<%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    <h3>查询所有的账户</h3>
    <c:forEach items="${list}" var="account">
        ${account.name}
    </c:forEach>
</body>
</html>
```

### 09-ssm整合之Spring整合MyBatis框架配置事务

applicationContext.xml

5.配置Spring的声明式事务管理

```xml
<!--配置Spring框架声明式事务管理-->
<!--配置事务管理器-->
<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    <property name="dataSource" ref="dataSource" />
</bean>

<!--配置事务通知-->
<tx:advice id="txAdvice" transaction-manager="transactionManager">
    <tx:attributes>
        <tx:method name="find*" read-only="true"/>
        <tx:method name="*" isolation="DEFAULT"/>
    </tx:attributes>
</tx:advice>

<!--配置AOP增强-->
<aop:config>
    <aop:advisor advice-ref="txAdvice" pointcut="execution(* cn.itcast.service.impl.*ServiceImpl.*(..))"/>
</aop:config>
```

前端编写form表单

```jsp
<h3>测试保存</h3>
<form action="account/save" method="post">
    姓名:<input type="text" name="name"/><br>
    金额:<input type="text" name="money"/><br>
    <input type="submit" value="保存"/><br>
</form>
```

后台controller

```java
/**
 * 保存
 * @param account
 * @param request
 * @param response
 * @throws Exception
 */
@RequestMapping("/save")
public void save(Account account, HttpServletRequest request, HttpServletResponse response) throws IOException {
    accountService.saveAccount(account);
    response.sendRedirect(request.getContextPath() + "/account/findAll");
    return;
}
```

 AccountServiceImpl

```java
package cn.itcast.service.impl;

import cn.itcast.dao.AccountDao;
import cn.itcast.domain.Account;
import cn.itcast.service.AccountService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

@Service("accountService")
public class AccountServiceImpl implements AccountService {

    @Autowired
    private AccountDao accountDao;

    public void saveAccount(Account account) {
        System.out.println("业务层：保存账户...");
        accountDao.saveAccount(account);
    }
}

```

确认AccountDao无误

```java
package cn.itcast.dao;

import cn.itcast.domain.Account;
import org.apache.ibatis.annotations.Insert;
import org.apache.ibatis.annotations.Select;
import org.springframework.stereotype.Repository;

import java.util.List;

/**
 * 账户dao接口
 */
@Repository
public interface AccountDao {

    //保存账户信息
    @Insert("insert into account (name,money) values (#{name},#{money})")
    public void saveAccount(Account account);
}

```

测试成功

# 关系型数据库:oracle

```
--创建表空间
create tablespace itheima
datafile 'c:\itheima.dbf'
size 100m
autoextend on
next 10m;
--删除表空间
drop tablespace itheima;

--创建用户
create user itheima
identified by itheima
default tablespace itheima;

--给用户授权
--oracle数据库中常用角色
connect--连接角色，基本角色
resource--开发者角色
dba--超级管理员角色
--给itheima用户授予dba角色
grant dba to itheima;

---切换到itheima用户下

---创建一个person表
create table person(
       pid number(20),
       pname varchar2(10)
);

---修改表结构
---添加一列
alter table person add (gender number(1));
---修改列类型
alter table person modify gender char(1);
---修改列名称
alter table person rename column gender to sex;
---删除一列
alter table person drop column sex;

---查询表中记录
select * from person;
----添加一条记录
insert into person (pid, pname) values (1, '小明');
commit;
----修改一条记录
update person set pname = '小马' where pid = 1;
commit;

----三个删除
--删除表中全部记录
delete from person;
--删除表结构
drop table person;
--先删除表，再次创建表。效果等同于删除表中全部记录。
--在数据量大的情况下，尤其在表中带有索引的情况下，该操作效率高。
--索引可以提供查询效率，但是会影响增删改效率。
truncate table person;


----序列不真的属于任何一张表，但是可以逻辑和表做绑定。
----序列：默认从1开始，依次递增，主要用来给主键赋值使用。
----dual：虚表，只是为了补全语法，没有任何意义。
create sequence s_person;
select s_person.nextval from dual;
----添加一条记录
insert into person (pid, pname) values (s_person.nextval, '小明');
commit;
select * from person;

----scott用户，密码tiger。
--解锁scott用户
alter user scott account unlock;
--解锁scott用户的密码【此句也可以用来重置密码】
alter user scott identified by tiger;
--切换到scott用户下

--单行函数：作用于一行，返回一个值。
---字符函数
select upper('yes') from dual;--YES
select lower('YES') from dual;--yes
----数值函数
select round(56.16, -2) from dual;---四舍五入，后面的参数表示保留的位数
select trunc(56.16, -1) from dual;---直接截取，不在看后面位数的数字是否大于5.
select mod(10, 3) from dual;---求余数
----日期函数
----查询出emp表中所有员工入职距离现在几天。
select sysdate-e.hiredate from emp e;
----算出明天此刻
select sysdate+1 from dual;
----查询出emp表中所有员工入职距离现在几月。
select months_between(sysdate,e.hiredate) from emp e;
----查询出emp表中所有员工入职距离现在几年。
select months_between(sysdate,e.hiredate)/12 from emp e;
----查询出emp表中所有员工入职距离现在几周。
select round((sysdate-e.hiredate)/7) from emp e;
----转换函数
---日期转字符串
select to_char(sysdate, 'fm yyyy-mm-dd hh24:mi:ss') from dual;
---字符串转日期
select to_date('2018-6-7 16:39:50', 'fm yyyy-mm-dd hh24:mi:ss') from dual;
----通用函数
---算出emp表中所有员工的年薪
----奖金里面有null值，如果null值和任意数字做算术运算，结果都是null。
select e.sal*12+nvl(e.comm, 0) from emp e;

---条件表达式
---条件表达式的通用写法，mysql和oracle通用
---给emp表中员工起中文名
select e.ename, 
       case e.ename
         when 'SMITH' then '曹贼'
           when 'ALLEN' then '大耳贼'
             when 'WARD' then '诸葛小儿'
               --else '无名'
                 end
from emp e;
---判断emp表中员工工资，如果高于3000显示高收入，如果高于1500低于3000显示中等收入，
-----其余显示低收入
select e.sal, 
       case 
         when e.sal>3000 then '高收入'
           when e.sal>1500 then '中等收入'
               else '低收入'
                 end
from emp e;
----oracle中除了起别名，都用单引号。
----oracle专用条件表达式
select e.ename, 
        decode(e.ename,
          'SMITH',  '曹贼',
            'ALLEN',  '大耳贼',
              'WARD',  '诸葛小儿',
                '无名') "中文名"             
from emp e;

--多行函数【聚合函数】：作用于多行，返回一个值。
select count(1) from emp;---查询总数量
select sum(sal) from emp;---工资总和
select max(sal) from emp;---最大工资
select min(sal) from emp;---最低工资
select avg(sal) from emp;---平均工资


---分组查询
---查询出每个部门的平均工资
---分组查询中，出现在group by后面的原始列，才能出现在select后面
---没有出现在group by后面的列，想在select后面，必须加上聚合函数。
---聚合函数有一个特性，可以把多行记录变成一个值。
select e.deptno, avg(e.sal)--, e.ename
from emp e
group by e.deptno;
---查询出平均工资高于2000的部门信息
select e.deptno, avg(e.sal) asal
from emp e
group by e.deptno
having avg(e.sal)>2000;
---所有条件都不能使用别名来判断。
--比如下面的条件语句也不能使用别名当条件
select ename, sal s from emp where sal>1500;

---查询出每个部门工资高于800的员工的平均工资
select e.deptno, avg(e.sal) asal
from emp e
where e.sal>800
group by e.deptno;
----where是过滤分组前的数据，having是过滤分组后的数据。
---表现形式：where必须在group by之前，having是在group by之后。
---查询出每个部门工资高于800的员工的平均工资
---然后再查询出平均工资高于2000的部门
select e.deptno, avg(e.sal) asal
from emp e
where e.sal>800
group by e.deptno
having avg(e.sal)>2000;


---多表查询中的一些概念
---笛卡尔积
select *
from emp e, dept d;
---等值连接
select *
from emp e, dept d
where e.deptno=d.deptno;
---内连接
select *
from emp e inner join dept d
on e.deptno = d.deptno;
---查询出所有部门，以及部门下的员工信息。【外连接】
select *
from emp e right join dept d
on e.deptno=d.deptno;
---查询所有员工信息，以及员工所属部门
select *
from emp e left join dept d
on e.deptno=d.deptno;
---oracle中专用外连接
select *
from emp e, dept d
where e.deptno(+) = d.deptno;

select * from emp;
---查询出员工姓名，员工领导姓名
---自连接：自连接其实就是站在不同的角度把一张表看成多张表。
select e1.ename, e2.ename
from emp e1, emp e2
where e1.mgr = e2.empno;
------查询出员工姓名，员工部门名称，员工领导姓名，员工领导部门名称
select e1.ename, d1.dname, e2.ename, d2.dname
from emp e1, emp e2, dept d1, dept d2
where e1.mgr = e2.empno
and e1.deptno=d1.deptno
and e2.deptno=d2.deptno;

---子查询
---子查询返回一个值
---查询出工资和SCOTT一样的员工信息
select * from emp where sal in
(select sal from emp where ename = 'SCOTT')
---子查询返回一个集合
---查询出工资和10号部门任意员工一样的员工信息
select * from emp where sal in
(select sal from emp where deptno = 10);
---子查询返回一张表
---查询出每个部门最低工资，和最低工资员工姓名，和该员工所在部门名称
---1，先查询出每个部门最低工资
select deptno, min(sal) msal
from emp 
group by deptno;
---2，三表联查，得到最终结果。
select t.deptno, t.msal, e.ename, d.dname
from (select deptno, min(sal) msal
      from emp 
      group by deptno) t, emp e, dept d
where t.deptno = e.deptno
and t.msal = e.sal
and e.deptno = d.deptno;


----oracle中的分页
---rownum行号：当我们做select操作的时候，
--每查询出一行记录，就会在该行上加上一个行号，
--行号从1开始，依次递增，不能跳着走。

----排序操作会影响rownum的顺序
select rownum, e.* from emp e order by e.sal desc
----如果涉及到排序，但是还要使用rownum的话，我们可以再次嵌套查询。
select rownum, t.* from(
select rownum, e.* from emp e order by e.sal desc) t;


----emp表工资倒叙排列后，每页五条记录，查询第二页。
----rownum行号不能写上大于一个正数。
select * from(
    select rownum rn, tt.* from(
          select * from emp order by sal desc
    ) tt where rownum<11
) where rn>5
```

```
---视图
---视图的概念：视图就是提供一个查询的窗口，所有数据来自于原表。

---查询语句创建表
create table emp as select * from scott.emp;
select * from emp;
---创建视图【必须有dba权限】
create view v_emp as select ename, job from emp;
---查询视图
select * from v_emp;
---修改视图[不推荐]
update v_emp set job='CLERK' where ename='ALLEN';
commit;
---创建只读视图
create view v_emp1 as select ename, job from emp with read only;
---视图的作用？
---第一：视图可以屏蔽掉一些敏感字段。
---第二：保证总部和分部数据及时统一。


---索引
--索引的概念：索引就是在表的列上构建一个二叉树
----达到大幅度提高查询效率的目的，但是索引会影响增删改的效率。
---单列索引
---创建单列索引
create index idx_ename on emp(ename);
---单列索引触发规则，条件必须是索引列中的原始值。
---单行函数，模糊查询，都会影响索引的触发。
select * from emp where ename='SCOTT'
---复合索引
---创建复合索引
create index idx_enamejob on emp(ename, job);
---复合索引中第一列为优先检索列
---如果要触发复合索引，必须包含有优先检索列中的原始值。
select * from emp where ename='SCOTT' and job='xx';---触发复合索引
select * from emp where ename='SCOTT' or job='xx';---不触发索引
select * from emp where ename='SCOTT';---触发单列索引。


---pl/sql编程语言
---pl/sql编程语言是对sql语言的扩展，使得sql语言具有过程化编程的特性。
---pl/sql编程语言比一般的过程化编程语言，更加灵活高效。
---pl/sql编程语言主要用来编写存储过程和存储函数等。

---声明方法
---赋值操作可以使用:=也可以使用into查询语句赋值
declare
    i number(2) := 10;
    s varchar2(10) := '小明';
    ena emp.ename%type;---引用型变量
    emprow emp%rowtype;---记录型变量
begin
    dbms_output.put_line(i);
    dbms_output.put_line(s);
    select ename into ena from emp where empno = 7788;
    dbms_output.put_line(ena);
    select * into emprow from emp where empno = 7788;
    dbms_output.put_line(emprow.ename || '的工作为：' || emprow.job);
end;


---pl/sql中的if判断
---输入小于18的数字，输出未成年
---输入大于18小于40的数字，输出中年人
---输入大于40的数字，输出老年人
declare
  i number(3) := &ii;
begin
  if i<18 then
    dbms_output.put_line('未成年');
  elsif i<40 then
    dbms_output.put_line('中年人');
  else
    dbms_output.put_line('老年人');
  end if;
end;

---pl/sql中的loop循环
---用三种方式输出1到10是个数字
---while循环
declare
  i number(2) := 1;
begin
  while i<11 loop
     dbms_output.put_line(i);
     i := i+1;
  end loop;  
end;
---exit循环
declare
  i number(2) := 1;
begin
  loop
    exit when i>10;
    dbms_output.put_line(i);
    i := i+1;
  end loop;
end;
---for循环
declare

begin
  for i in 1..10 loop
     dbms_output.put_line(i);  
  end loop;
end;

---游标：可以存放多个对象，多行记录。
---输出emp表中所有员工的姓名
declare
  cursor c1 is select * from emp;
  emprow emp%rowtype;
begin
  open c1;
     loop
         fetch c1 into emprow;
         exit when c1%notfound;
         dbms_output.put_line(emprow.ename);
     end loop;
  close c1;
end;

-----给指定部门员工涨工资
declare
  cursor c2(eno emp.deptno%type) 
  is select empno from emp where deptno = eno;
  en emp.empno%type;
begin
  open c2(10);
     loop
        fetch c2 into en;
        exit when c2%notfound;
        update emp set sal=sal+100 where empno=en;
        commit;
     end loop;  
  close c2;
end;
----查询10号部门员工信息
select * from emp where deptno = 10;


---存储过程
--存储过程：存储过程就是提前已经编译好的一段pl/sql语言，放置在数据库端
--------可以直接被调用。这一段pl/sql一般都是固定步骤的业务。
----给指定员工涨100块钱
create or replace procedure p1(eno emp.empno%type)
is

begin
   update emp set sal=sal+100 where empno = eno;
   commit;
end;

select * from emp where empno = 7788;
----测试p1
declare

begin
  p1(7788);
end;

----通过存储函数实现计算指定员工的年薪
----存储过程和存储函数的参数都不能带长度
----存储函数的返回值类型不能带长度
create or replace function f_yearsal(eno emp.empno%type) return number
is
  s number(10);     
begin
  select sal*12+nvl(comm, 0) into s from emp where empno = eno;
  return s;
end;

----测试f_yearsal
----存储函数在调用的时候，返回值需要接收。
declare
  s number(10); 
begin
  s := f_yearsal(7788);
  dbms_output.put_line(s);
end;

---out类型参数如何使用
---使用存储过程来算年薪
create or replace procedure p_yearsal(eno emp.empno%type, yearsal out number)
is
   s number(10);
   c emp.comm%type;
begin
   select sal*12, nvl(comm, 0) into s, c from emp where empno = eno;
   yearsal := s+c;
end;

---测试p_yearsal
declare
  yearsal number(10);
begin
  p_yearsal(7788, yearsal);
  dbms_output.put_line(yearsal);
end;

----in和out类型参数的区别是什么？
---凡是涉及到into查询语句赋值或者:=赋值操作的参数，都必须使用out来修饰。


---存储过程和存储函数的区别
---语法区别：关键字不一样，
------------存储函数比存储过程多了两个return。
---本质区别：存储函数有返回值，而存储过程没有返回值。
----------如果存储过程想实现有返回值的业务，我们就必须使用out类型的参数。
----------即便是存储过程使用了out类型的参数，起本质也不是真的有了返回值，
----------而是在存储过程内部给out类型参数赋值，在执行完毕后，我们直接拿到输出类型参数的值。

----我们可以使用存储函数有返回值的特性，来自定义函数。
----而存储过程不能用来自定义函数。
----案例需求：查询出员工姓名，员工所在部门名称。
----案例准备工作：把scott用户下的dept表复制到当前用户下。
create table dept as select * from scott.dept;
----使用传统方式来实现案例需求
select e.ename, d.dname
from emp e, dept d
where e.deptno=d.deptno;
----使用存储函数来实现提供一个部门编号，输出一个部门名称。
create or replace function fdna(dno dept.deptno%type) return dept.dname%type
is
  dna dept.dname%type;
begin
  select dname into dna from dept where deptno = dno;
  return dna;
end;
---使用fdna存储函数来实现案例需求：查询出员工姓名，员工所在部门名称。
select e.ename, fdna(e.deptno)
from emp e;


---触发器，就是制定一个规则，在我们做增删改操作的时候，
----只要满足该规则，自动触发，无需调用。
----语句级触发器：不包含有for each row的触发器。
----行级触发器：包含有for each row的就是行级触发器。
-----------加for each row是为了使用:old或者:new对象或者一行记录。

---语句级触发器
----插入一条记录，输出一个新员工入职
create or replace trigger t1
after
insert
on person
declare

begin
  dbms_output.put_line('一个新员工入职');
end;
---触发t1
insert into person values (1, '小红');
commit;
select * from person;

---行级别触发器
---不能给员工降薪
---raise_application_error(-20001~-20999之间, '错误提示信息');
create or replace trigger t2
before
update
on emp
for each row
declare

begin
  if :old.sal>:new.sal then
     raise_application_error(-20001, '不能给员工降薪');
  end if;
end;
----触发t2
select * from emp where empno = 7788;
update emp set sal=sal-1 where empno = 7788;
commit;


----触发器实现主键自增。【行级触发器】
---分析：在用户做插入操作的之前，拿到即将插入的数据，
------给该数据中的主键列赋值。
create or replace trigger auid
before
insert
on person
for each row
declare

begin
  select s_person.nextval into :new.pid from dual;
end;
--查询person表数据
select * from person;
---使用auid实现主键自增
insert into person (pname) values ('a');
commit;
insert into person values (1, 'b');
commit;


----oracle10g    ojdbc14.jar
----oracle11g    ojdbc6.jar
```



# 项目管理

## 项目管理:maven高级

 

## 项目管理:git

Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。

# 轻量级:springboot

### 01.springboot介绍

SpringBoot的特点

```
Spring Boot 主要特征是：

- 创建独立的spring应用程序
- 直接内嵌tomcat、jetty和undertow（不需要打包成war包部署）
- 提供了固定化的“starter”配置，以简化构建配置
- 尽可能的自动配置spring和第三方库
- 提供产品级的功能，如：安全指标、运行状况监测和外部化配置等
- 绝对不会生成代码，并且不需要XML配置
```

为什么要学习SpringBoot

```
java一直被人诟病的一点就是臃肿、麻烦。当我们还在辛苦的搭建项目时，可能Python程序员已经把功能写好了，究其原因主要是两点：

- 复杂的配置

  项目各种配置其实是开发时的损耗， 因为在思考 Spring 特性配置和解决业务问题之间需要进行思维切换，所以写配置挤占了写应用程序逻辑的时间。

- 混乱的依赖管理

  项目的依赖管理也是件吃力不讨好的事情。决定项目里要用哪些库就已经够让人头痛的了，你还要知道这些库的哪个版本和其他库不会有冲突，这也是件棘手的问题。并且，依赖管理也是一种损耗，添加依赖不是写应用程序代码。一旦选错了依赖的版本，随之而来的不兼容问题毫无疑问会是生产力杀手。

而SpringBoot让这一切成为过去
```

```
面试，什么是springboot，有什么特点
内置tomcat，提供了自动配置，搭建spring应用的脚手架
特点：解决了两大问题，复杂的配置，混乱的依赖管理
```

### 02.springboot入门

2.0.6版本文档地址https://docs.spring.io/spring-boot/docs/2.0.6.RELEASE/reference/htmlsingle/

环境要求：

![image-20211101160927807](C:/Users/Murphy/Pictures/image-20211101160927807.png)

1.创建工程

我们先新建一个空的demo工程，如下：

![image-20211101160946857](C:/Users/Murphy/Pictures/image-20211101160946857.png)

![image-20211101160957962](C:/Users/Murphy/Pictures/image-20211101160957962.png)

创建以moduel：

![image-20211101161015017](C:/Users/Murphy/Pictures/image-20211101161015017.png)

![image-20211101161021815](C:/Users/Murphy/Pictures/image-20211101161021815.png)

填写坐标信息：

![image-20211101161038603](C:/Users/Murphy/Pictures/image-20211101161038603.png)

目录结构：

![image-20211101161053230](C:/Users/Murphy/Pictures/image-20211101161053230.png)

创建完成后的目录结构：

![image-20211101161104990](C:/Users/Murphy/Pictures/image-20211101161104990.png)

2.引入依赖

pom.xml引入依赖

为了让SpringBoot帮我们完成各种自动配置，我们必须引入SpringBoot提供的自动配置依赖，我们称为`启动器`。spring-boot-starter-parent工程将依赖关系声明为一个或者多个启动器，我们可以根据项目需求引入相应的启动器，因为我们是web项目，这里我们引入web启动器

```
需要注意的是，我们并没有在这里指定版本信息。因为SpringBoot的父工程已经对版本进行了管理了。

这个时候，我们会发现项目中多出了大量的依赖：
这些都是SpringBoot根据spring-boot-starter-web这个依赖自动引入的，而且所有的版本都已经管理好，不会出现冲突。
总结，SpringBoot内部对大量的第三方库或Spring内部库进行了默认配置，这些配置是否生效，取决于我们是否引入了对应库所需的依赖，如果有那么默认配置就会生效。
所以，我们使用SpringBoot构建一个项目，只需要引入所需依赖，配置就可以交给SpringBoot处理了。
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>cn.itcast</groupId>
    <artifactId>itcast-srpingboot</artifactId>
    <version>1.0.0-SNAPSHOT</version>

    <!--所有的springboot应用都要以该工程为父工程-->
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.0.6.RELEASE</version>
    </parent>

    <dependencies>
        <!--启动器：每一个启动器背后都是一堆的依赖。web启动器-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
    </dependencies>
</project>
```

3.编写HelloController

![image-20211101161310640](C:/Users/Murphy/Pictures/image-20211101161310640.png)

```java
@RestController
@RequestMapping("hello")
@EnableAutoConfiguration//启用自动配置
public class HelloController {

    @RequestMapping("show")
    public String test() {
        return "helllo springboot 1";
    }

    public static void main(String[] args) {
        SpringApplication.run(HelloController.class, args);
    }
}

```

4.启动测试

![image-20211101161512779](C:/Users/Murphy/Pictures/image-20211101161512779.png)

![image-20211101161529174](C:/Users/Murphy/Pictures/image-20211101161529174.png)

![springboot1](C:/Users/Murphy/Pictures/springboot1.png)

访问成功！

入门工程中：pom.xml里引入了启动器的概念以@EnableAutoConfiguration注解。

### 03.优化入门程序

现在工程中只有一个Controller，可以这么玩；那么如果有多个Controller，怎么办呢？

添加Hello2Controller：

```java
@RestController
@RequestMapping("hello2")
public class Hello2Controller {

    @RequestMapping("show")
    public String test() {
        return "helllo springboot 2";
    }

}
```

```
难道要在每一个Controller中都添加一个main方法和@EnableAutoConfiguration注解，这样启动一个springboot程序也太麻烦了。也无法同时启动多个Controller，因为每个main方法都监听8080端口。所以，一个springboot程序应该只有一个springboot的main方法。

所以，springboot程序引入了一个全局的引导类。
```

1.添加引导类

通常请求下，我们在一个springboot工程中都会在基包下创建一个引导类，一些springboot的全局注解（@EnableAutoConfiguration注解）以及springboot程序的入口main方法都放在该类中。

在springboot的程序的基包下（引导类和Controller包在同级目录下），创建TestApplication.class：

![image-20211101164555522](C:/Users/Murphy/Pictures/image-20211101164555522.png)

```java
/**
 * 引导类：springboot应用的入口
 */
@EnableAutoConfiguration//启用springboot应用的自动配置
@ComponentScan//类似于<context:component-scan base-package=">扫描该类所在的包以及它的子子孙孙
public class TestApplication  {
    public static void main(String[] args) {
        SpringApplication.run(TestApplication.class, args);
    }
}
```

并修改HelloController，去掉main方法及@EnableAutoConfiguration：

```java
@RestController
@RequestMapping("hello")
public class HelloController {

    @RequestMapping("show")
    public String test() {
        return "helllo springboot 1";
    }

}
```

```
其它：
如果直接复制，发现所有的Controller都不能访问，为什么？
回想以前程序，我们在配置文件中添加了注解扫描，它能扫描指定包下的所有Controller，而现在并没有。怎么解决——@ComponentScan注解

2.@ComponentScan
spring框架除了提供配置方式的注解扫描`<context:component-scan />`，还提供了注解方式的注解扫描`@ComponentScan`。
在TestApplication.class中，使用@ComponentScan注解：
@ComponentScan注解声明的类就是main函数所在的启动类，因此扫描的包是该类所在包及其子包。**一般启动类会放在一个比较浅的包目录中。**

3.@SpringBootApplication
我们现在的引导类中使用了@EnableAutoConfiguration和@ComponentScan注解，有点麻烦。springboot提供了一种简便的玩法：@SpringBootApplication注解
使用@SpringBootApplication改造TestApplication：
```

```java
@SpringBootApplication
public class TestApplication {

    public static void main(String[] args) {
        SpringApplication.run(TestApplication.class, args);
    }

}
```

```
4.@SpringBootConfiguration
这个注解的作用就是声明当前类是一个配置类，然后Spring会自动扫描到添加了`@Configuration`的类，并且读取其中的配置信息。而`@SpringBootConfiguration`是来声明当前类是SpringBoot应用的配置类，项目中只能有一个。所以一般我们无需自己添加。
```

### 04.java配置

springboot的默认配置方式和我们之前玩的配置方式不太一样，没有任何的xml。那么如果自己要新增配置该怎么办？比如我们要配置一个数据库连接池，以前会这么玩：

```
<!-- 配置连接池 -->
<bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"
      init-method="init" destroy-method="close">
    <property name="url" value="${jdbc.url}" />
    <property name="username" value="${jdbc.username}" />
    <property name="password" value="${jdbc.password}" />
</bean>
```

现在该怎么做呢?

1.回顾历史

```
事实上，在Spring3.0开始，Spring官方就已经开始推荐使用java配置来代替传统的xml配置了，我们不妨来回顾一下Spring的历史：
- Spring1.0时代
  在此时因为jdk1.5刚刚出来，注解开发并未盛行，因此一切Spring配置都是xml格式，想象一下所有的bean都用xml配置，细思极恐啊，心疼那个时候的程序员2秒
- Spring2.0时代
  Spring引入了注解开发，但是因为并不完善，因此并未完全替代xml，此时的程序员往往是把xml与注解进行结合，貌似我们之前都是这种方式。
- Spring3.0及以后
  3.0以后Spring的注解已经非常完善了，因此Spring推荐大家使用完全的java配置来代替以前的xml，不过似乎在国内并未推广盛行。然后当SpringBoot来临，人们才慢慢认识到java配置的优雅。
```

2.尝试java配置

java配置主要靠java类和一些注解来达到和xml配置一样的效果，比较常用的注解有：

- `@Configuration`：声明一个类作为配置类，代替xml文件
- `@Bean`：声明在方法上，将方法的返回值加入Bean容器，代替`<bean>`标签
- `@Value`：属性注入 
- `@PropertySource`：指定外部属性文件。

我们接下来用java配置来尝试实现连接池配置

![image-20211101212428887](C:/Users/Murphy/Pictures/image-20211101212428887.png)

1.引入依赖

首先在pom.xml中，引入Druid连接池依赖：

```xml
<dependency>
    <groupId>com.github.drtrang</groupId>
    <artifactId>druid-spring-boot2-starter</artifactId>
    <version>1.1.10</version>
</dependency>
```

2.添加jdbc.properties

```
jdbc.driverClassName=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://127.0.0.1:3306/leyou
jdbc.username=root
jdbc.password=123456
```

配置数据源

创建JdbcConfiguration类：

```java
@Configuration //声明一个类是一个java配置类，相当于项目量配置文件
@PropertySource("classpath:jdbc.properties")//读取资源文件
public class JdbcConfigration {

    @Value("${jdbc.driverClassName}")
    private String driverClassName;
    @Value("jdbc.url")
    private String url;
    @Value("jdbc.username")
    private String username;
    @Value("jdbc.password=123456")
    private String password;

    @Bean//把方法的返回值注入到spring容器
    public DataSource dataSource() {
        DruidDataSource dataSource = new DruidDataSource();
        dataSource.setDriverClassName(this.driverClassName);//加this区分局部和全局
        dataSource.setUrl(this.url);
        dataSource.setUsername(this.username);
        dataSource.setPassword(this.password);
        return dataSource;
    }
}
```

解读：

- `@Configuration`：声明`JdbcConfiguration`是一个配置类。
- `@PropertySource`：指定属性文件的路径是:`classpath:jdbc.properties`
- 通过`@Value`为属性注入值。
- 通过@Bean将 `dataSource()`方法声明为一个注册Bean的方法，Spring会自动调用该方法，将方法的返回值加入Spring容器中。相当于以前的bean标签

然后就可以在任意位置通过`@Autowired`注入DataSource了

### 05.springboot属性注入

在上面的案例中，我们实验了java配置方式。不过属性注入使用的是@Value注解。这种方式虽然可行，但是不够强大，因为它只能注入基本类型值。

在SpringBoot中，提供了一种新的属性注入方式，支持各种java基本数据类型及复杂类型的注入。

1）新建`JdbcProperties`，用来进行属性注入：

![image-20211101222224771](C:/Users/Murphy/Pictures/image-20211101222224771.png)

```java
@ConfigurationProperties(prefix = "jdbc")
public class JdbcProperties {
    private String driverClassName;
    private String url;
    private String username;
    private String password;

    public String getDriverClassName() {
        return driverClassName;
    }

    public void setDriverClassName(String driverClassName) {
        this.driverClassName = driverClassName;
    }

    public String getUrl() {
        return url;
    }

    public void setUrl(String url) {
        this.url = url;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}
```

- 在类上通过@ConfigurationProperties注解声明当前类为属性读取类
- `prefix="jdbc"`读取属性文件中，前缀为jdbc的值。
- 在类上定义各个属性，名称必须与属性文件中`jdbc.`后面部分一致，并且必须具有getter和setter方法
- 需要注意的是，这里我们并没有指定属性文件的地址，SpringBoot默认会读取文件名为application.properties的资源文件，所以我们**把jdbc.properties名称改为application.properties**

2）在JdbcConfiguration中使用这个属性：

通过`@EnableConfigurationProperties(JdbcProperties.class)`来声明要使用`JdbcProperties`这个类的对象

然后你可以通过以下方式在JdbcConfiguration类中注入JdbcProperties：

1.@Autowired注入

```java
@Configuration
@EnableConfigurationProperties(JdbcProperties.class)
public class JdbcConfiguration {

    @Autowired
    private JdbcProperties jdbcProperties;

    @Bean//把方法的返回值注入到spring容器
    public DataSource dataSource() {
        DruidDataSource dataSource = new DruidDataSource();
        dataSource.setUrl(this.jdbcProperties.getUrl());
        dataSource.setDriverClassName(this.jdbcProperties.getDriverClassName());
        dataSource.setUsername(this.jdbcProperties.getUsername());
        dataSource.setPassword(this.jdbcProperties.getPassword());
        return dataSource;
    }

}
```

2.构造方法注入

```java
@Configuration
@EnableConfigurationProperties(JdbcProperties.class)
public class JdbcConfiguration {

    private JdbcProperties jdbcProperties;

    public JdbcConfiguration(JdbcProperties jdbcProperties){
        this.jdbcProperties = jdbcProperties;
    }

    @Bean//把方法的返回值注入到spring容器
    public DataSource dataSource() {
       DruidDataSource dataSource = new DruidDataSource();
        dataSource.setUrl(this.jdbcProperties.getUrl());
        dataSource.setDriverClassName(this.jdbcProperties.getDriverClassName());
        dataSource.setUsername(this.jdbcProperties.getUsername());
        dataSource.setPassword(this.jdbcProperties.getPassword());
        return dataSource;
    }

}
```

3.@Bean方法的参数注入

```java
@Configuration
@EnableConfigurationProperties(JdbcProperties.class)
public class JdbcConfiguration {

    @Bean//把方法的返回值注入到spring容器
    public DataSource dataSource(JdbcProperties jdbcProperties) {
       DruidDataSource dataSource = new DruidDataSource();
        dataSource.setUrl(this.jdbcProperties.getUrl());
        dataSource.setDriverClassName(this.jdbcProperties.getDriverClassName());
        dataSource.setUsername(this.jdbcProperties.getUsername());
        dataSource.setPassword(this.jdbcProperties.getPassword());
        return dataSource;
    }
}
```
4.直接在@Bean方法上使用@ConfigurationProperties(prefix = "jdbc")

```java
@Configuration
public class JdbcConfiguration {
    
    @Bean
    // 声明要注入的属性前缀，SpringBoot会自动把相关属性通过set方法注入到DataSource中
    @ConfigurationProperties(prefix = "jdbc")
    public DataSource dataSource() {
        DruidDataSource dataSource = new DruidDataSource();
        return dataSource;
    }
}
```

事实上，如果一段属性只有一个Bean需要使用，我们无需将其注入到一个类（JdbcProperties）中。而是直接在需要的地方声明即可：

我们直接把`@ConfigurationProperties(prefix = "jdbc")`声明在需要使用的`@Bean`的方法上，然后SpringBoot就会自动调用这个Bean（此处是DataSource）的set方法，然后完成注入。使用的前提是：**该类必须有对应属性的set方法！**

### 06.springboot四种属性注入小结

一般用的多的是第一种

### 07.springboot的自动配置原理

通过刚才的学习，我们知道@EnableAutoConfiguration会开启SpringBoot的自动配置，并且根据你引入的依赖来生效对应的默认配置。那么问题来了：

- 这些默认配置是怎么配置的，在哪里配置的呢？
- 为何依赖引入就会触发配置呢？
- 这些默认配置的属性来自哪里呢？

其实在我们的项目中，已经引入了一个依赖：spring-boot-autoconfigure，其中定义了大量自动配置类

### 08.整合springMVC

#### 1.1创建工程

![image-20211102164705012](C:/Users/Murphy/Pictures/image-20211102164705012.png)

![image-20211102164715316](C:/Users/Murphy/Pictures/image-20211102164715316.png)

![image-20211102164722466](C:/Users/Murphy/Pictures/image-20211102164722466.png)

#### 2.1编写基本代码

pom.xml:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>cn.itcast.user</groupId>
    <artifactId>itcast-user</artifactId>
    <version>1.0.0-SNAPSHOT</version>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.0.6.RELEASE</version>
    </parent>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
    </dependencies>
</project>
```

参照上边的项目，编写引导类：

```java
package cn.itcast.user;

import cn.itcast.user.controller.UserController;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class UserApplication {
    public static void main(String[] args) {
        SpringApplication.run(UserApplication.class, args);
    }
}
```

编写UserController：

```java
package cn.itcast.user.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
@RequestMapping("user")
public class UserController {

    @RequestMapping("test")
    @ResponseBody//响应JSON数据
    public String test(){
        return "hello user!";
    }
}
```

#### 3整合SpringMvc

#### 3.1修改端口

虽然默认配置已经可以使用SpringMVC了，不过我们有时候需要进行自定义配置。

![image-20211102164537759](C:/Users/Murphy/Pictures/image-20211102164537759.png)

端口通过以下方式配置

![image-20211102164557249](C:/Users/Murphy/Pictures/image-20211102164557249.png)

重启服务后测试：

![image-20211102164618002](C:/Users/Murphy/Pictures/image-20211102164618002.png)

![image-20211102164638195](C:/Users/Murphy/Pictures/image-20211102164638195.png)

#### 3.2.访问静态资源

现在，我们的项目是一个jar工程，那么就没有webapp，我们的静态资源该放哪里呢？

回顾我们上面看的源码，有一个叫做ResourceProperties的类，里面就定义了静态资源的默认查找路径： ![1528096892588](../../assets/1528096892588.png)

默认的静态资源路径为：

- classpath:/META-INF/resources/
- classpath:/resources/
- classpath:/static/
- classpath:/public/

只要静态资源放在这些目录中任何一个，SpringMVC都会帮我们处理。

我们习惯会把静态资源放在`classpath:/static/`目录下。我们创建目录，并且添加一些静态资源：

![image-20211102212415557](C:/Users/Murphy/Pictures/image-20211102212415557.png)

重启项目后测试：

![image-20211102212433155](C:/Users/Murphy/Pictures/image-20211102212433155.png)

#### 3.3.添加拦截器

通过实现`WebMvcConfigurer`并添加`@Configuration`注解来实现自定义部分SpringMvc配置。

实现如下：

![image-20211102212758465](C:/Users/Murphy/Pictures/image-20211102212758465.png)

首先我们定义一个拦截器：

```java
@Component//将拦截器放入容器中
public class MyInterceptor implements HandlerInterceptor {

    /**
     * 前置方法，在Handler方法执行之前执行
     * @param request
     * @param response
     * @param handler
     * @return
     * @throws Exception
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("前置方法正在执行");
        return true;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println("后置方法正在执行");
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println("完成方法正在执行");
    }
}
```

然后定义配置类，注册拦截器：

```java
/**
 * 配置拦截器
 * 1.声明该类是一个java配置类
 * 2.实现WebMvcConfigurer接口
 */
@Configuration
public class WebMvcConfigration implements WebMvcConfigurer {

    @Autowired
    private MyInterceptor myInterceptor;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(myInterceptor).addPathPatterns("/**");
    }
}
```

接下来运行并查看日志：

```
preHandle method is running!
postHandle method is running!
afterCompletion method is running!
```

你会发现日志中只有这些打印信息，springMVC的日志信息都没有，因为springMVC记录的log级别是debug，springboot默认是显示info以上，我们需要进行配置。

SpringBoot通过`logging.level.*=debug`来配置日志级别，*填写包名

所以修改application.properties，添加如下一段

```xml
# 设置org.springframework包的日志级别为debug
logging.level.org.springframework=debug
```

### 09.整合数据源

jdbc连接池是spring配置中的重要一环，在SpringBoot中该如何处理呢？

答案是不需要处理，我们只要找到SpringBoot提供的启动器即可：

在pom.xml中引入jdbc的启动器：

```xml
<!--jdbc的启动器，默认使用HikariCP连接池-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-jdbc</artifactId>
</dependency>
<!--不要忘记数据库驱动，因为springboot不知道我们使用的什么数据库，这里选择mysql-->
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
</dependency>
```

SpringBoot已经自动帮我们引入了一个连接池：

![image-20211102214847141](C:/Users/Murphy/Pictures/image-20211102214847141.png)

HikariCP应该是目前速度最快的连接池了，可以百度看看它与c3p0的对比：

因此，我们只需要指定连接池参数即可：

```xml
# 连接四大参数
spring.datasource.url=jdbc:mysql://localhost:3306/heima
spring.datasource.username=root
spring.datasource.password=root
# 驱动可省略，SpringBoot自动推断
spring.datasource.driverClassName=com.mysql.jdbc.Driver

spring.datasource.hikari.idle-timeout=60000
spring.datasource.hikari.maximum-pool-size=30
spring.datasource.hikari.minimum-idle=10
```

当然，如果你更喜欢Druid连接池，也可以使用Druid官方提供的启动器：

```xml
<!-- Druid连接池 -->
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid-spring-boot-starter</artifactId>
    <version>1.1.6</version>
</dependency>
```

而连接信息的配置与上面是类似的，只不过在连接池特有属性上，方式略有不同：

```xml
#初始化连接数
spring.datasource.druid.initial-size=1
#最小空闲连接
spring.datasource.druid.min-idle=1
#最大活动连接
spring.datasource.druid.max-active=20
#获取连接时测试是否可用
spring.datasource.druid.test-on-borrow=true
#监控页面启动
spring.datasource.druid.stat-view-servlet.allow=true
```

### 10.整合mybatis

#### 1.mybatis

SpringBoot官方并没有提供Mybatis的启动器，不过Mybatis[官方](https://github.com/mybatis/spring-boot-starter)自己实现了：

```xml
<!--mybatis -->
<dependency>
    <groupId>org.mybatis.spring.boot</groupId>
    <artifactId>mybatis-spring-boot-starter</artifactId>
    <version>1.3.2</version>
</dependency>
```

配置，基本没有需要配置的：

```xml
# mybatis 别名扫描
mybatis.type-aliases-package=cn.itcast.pojo
# mapper.xml文件位置,如果没有映射文件，请注释掉
mybatis.mapper-locations=classpath:mappers/*.xml
```

需要注意，这里没有配置mapper接口扫描包，因此我们需要给每一个Mapper接口添加`@Mapper`注解，才能被识别。

![image-20211103170423785](C:/Users/Murphy/Pictures/image-20211103170423785.png)

```
@Mapper
public interface UserMapper {
}
```

user对象参照课前资料，需要通用mapper的注解：

![image-20211103170458873](C:/Users/Murphy/Pictures/image-20211103170458873.png)

```java

@Table(name = "tb_user")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String userName;

    private String password;

    private String name;

    private Integer age;

    private Integer sex;

    private Date birthday;

    private Date created;

    private Date updated;

	//Getter和Setter已省略

    @Override
    public String toString() {
        return "User{" +
                "id=" + id +
                ", userName='" + userName + '\'' +
                ", password='" + password + '\'' +
                ", name='" + name + '\'' +
                ", age=" + age +
                ", sex=" + sex +
                ", birthday=" + birthday +
                ", created=" + created +
                ", updated=" + updated +
                '}';
    }
}
```

接下来，就去集成通用mapper。

#### 2.通用mapper

通用Mapper的作者也为自己的插件编写了启动器，我们直接引入即可：

```xml
<!-- 通用mapper -->
<dependency>
    <groupId>tk.mybatis</groupId>
    <artifactId>mapper-spring-boot-starter</artifactId>
    <version>2.0.2</version>
</dependency>
```

不需要做任何配置就可以使用了。

```java
@Mapper
public interface UserMapper extends tk.mybatis.mapper.common.Mapper<User>{
}
```

### 11.整合事务及测试

其实，我们引入jdbc或者web的启动器，就已经引入事务相关的依赖及默认配置了

![image-20211103174553976](C:/Users/Murphy/Pictures/image-20211103174553976.png)

至于事务，SpringBoot中通过注解来控制。就是我们熟知的`@Transactional`

```java
@Service
public class UserService {

    @Autowired
    private UserMapper userMapper;

    public User queryById(Long id){
        return this.userMapper.selectByPrimaryKey(id);
    }

    @Transactional
    public void deleteById(Long id){
        this.userMapper.deleteByPrimaryKey(id);
    }
}
```

启动测试

在UserController中添加测试方法，内容：

```java
@RestController
@RequestMapping("user")
public class UserController {

    @Autowired
    private UserService userService;

    @GetMapping("{id}")
    public User queryUserById(@PathVariable("id")Long id){
        return this.userService.queryById(id);
    }

    @GetMapping("hello")
    public String test(){
        return "hello ssm";
    }
}
```

我们启动项目，查看：

![image-20211103175351152](C:/Users/Murphy/Pictures/image-20211103175351152.png)

完整项目结构

![image-20211103175408164](C:/Users/Murphy/Pictures/image-20211103175408164.png)

完整的pom.xml：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">

    <modelVersion>4.0.0</modelVersion>

    <groupId>cn.itcast.user</groupId>
    <artifactId>itcast-user</artifactId>
    <version>1.0-SNAPSHOT</version>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.0.6.RELEASE</version>
    </parent>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <!--jdbc的启动器，默认使用HikariCP连接池-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-jdbc</artifactId>
        </dependency>
        <!--不要忘记数据库驱动，因为springboot不知道我们使用的什么数据库，这里选择mysql-->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
        </dependency>

        <!--mybatis -->
        <dependency>
            <groupId>org.mybatis.spring.boot</groupId>
            <artifactId>mybatis-spring-boot-starter</artifactId>
            <version>1.3.2</version>
        </dependency>

        <!-- 通用mapper -->
        <dependency>
            <groupId>tk.mybatis</groupId>
            <artifactId>mapper-spring-boot-starter</artifactId>
            <version>2.0.2</version>
        </dependency>
    </dependencies>

</project>
```

完整的application.properties：

```xml
server.port=80

logging.level.org.springframework=debug

spring.datasource.url=jdbc:mysql://localhost:3306/heima
spring.datasource.username=root
spring.datasource.password=root

# mybatis 别名扫描
mybatis.type-aliases-package=cn.itcast.pojo
# mapper.xml文件位置,如果没有映射文件，请注释掉
# mybatis.mapper-locations=classpath:mappers/*.xml
```

### 12.springboot实战总结

![总结](C:/Users/Murphy/Pictures/总结.png)

### 13.thymeleaf体验

SpringBoot并不推荐使用jsp，但是支持一些模板引擎技术：

![image-20211103205446961](C:/Users/Murphy/Pictures/image-20211103205446961.png)

以前大家用的比较多的是Freemarker，但是我们今天的主角是Thymeleaf！

#### 1.为什么是Thymeleaf？

简单说， Thymeleaf 是一个跟 Velocity、FreeMarker 类似的模板引擎，它可以完全替代 JSP 。相较于其他的模板引擎，它有如下四个极吸引人的特点：

- 动静结合：Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。这是由于它支持 html 原型，然后在 html 标签里增加额外的属性来达到模板+数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。
- 开箱即用：它提供标准和spring标准两种方言，可以直接套用模板实现JSTL、 OGNL表达式效果，避免每天套模板、改jstl、改标签的困扰。同时开发人员也可以扩展和创建自定义的方言。
- 多方言支持：Thymeleaf 提供spring标准方言和一个与 SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。
- 与SpringBoot完美整合，SpringBoot提供了Thymeleaf的默认配置，并且为Thymeleaf设置了视图解析器，我们可以像以前操作jsp一样来操作Thymeleaf。代码几乎没有任何区别，就是在模板语法上有区别。



接下来，我们就通过入门案例来体会Thymeleaf的魅力：

#### 2.提供数据

编写一个controller方法，返回一些用户数据，放入模型中，将来在页面渲染

```java
@GetMapping("/all")
public String all(ModelMap model) {
    // 查询用户
    List<User> users = this.userService.queryAll();
    // 放入模型
    model.addAttribute("users", users);
    // 返回模板名称（就是classpath:/templates/目录下的html文件名）
    return "users";
}
```

#### 3.引入启动器

直接引入启动器：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-thymeleaf</artifactId>
</dependency>
```

SpringBoot会自动为Thymeleaf注册一个视图解析器：

![image-20211103213257732](C:/Users/Murphy/Pictures/image-20211103213257732.png)

与解析JSP的InternalViewResolver类似，Thymeleaf也会根据前缀和后缀来确定模板文件的位置：

![image-20211103213311651](C:/Users/Murphy/Pictures/image-20211103213311651.png)

- 默认前缀：`classpath:/templates/`
- 默认后缀：`.html`

所以如果我们返回视图：`users`，会指向到 `classpath:/templates/users.html`

一般我们无需进行修改，默认即可。

#### 4.静态页面

根据上面的文档介绍，模板默认放在classpath下的templates文件夹，我们新建一个html文件放入其中：

![image-20211103213342602](C:/Users/Murphy/Pictures/image-20211103213342602.png)

编写html模板，渲染模型中的数据：

注意，把html 的名称空间，改成：`xmlns:th="http://www.thymeleaf.org"` 会有语法提示

```html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>首页</title>
    <style type="text/css">
        table {border-collapse: collapse; font-size: 14px; width: 80%; margin: auto}
        table, th, td {border: 1px solid darkslategray;padding: 10px}
    </style>
</head>
<body>
<div style="text-align: center">
    <span style="color: darkslategray; font-size: 30px">欢迎光临！</span>
    <hr/>
    <table class="list">
        <tr>
            <th>id</th>
            <th>姓名</th>
            <th>用户名</th>
            <th>年龄</th>
            <th>性别</th>
            <th>生日</th>
        </tr>
        <tr th:each="user : ${users}">
            <td th:text="${user.id}">1</td>
            <td th:text="${user.name}">张三</td>
            <td th:text="${user.userName}">zhangsan</td>
            <td th:text="${user.age}">20</td>
            <td th:text="${user.sex}">男</td>
            <td th:text="${user.birthday}">1980-02-30</td>
        </tr>
    </table>
</div>
</body>
</html>
```

我们看到这里使用了以下语法：

- `${}` ：这个类似与el表达式，但其实是ognl的语法，比el表达式更加强大
- `th-`指令：`th-`是利用了Html5中的自定义属性来实现的。如果不支持H5，可以用`data-th-`来代替
  - `th:each`：类似于`c:foreach`  遍历集合，但是语法更加简洁
  - `th:text`：声明标签中的文本
    - 例如`<td th-text='${user.id}'>1</td>`，如果user.id有值，会覆盖默认的1
    - 如果没有值，则会显示td中默认的1。这正是thymeleaf能够动静结合的原因，模板解析失败不影响页面的显示效果，因为会显示默认值！

#### 5.测试

接下来，我们打开页面测试一下：

![image-20211103213453472](C:/Users/Murphy/Pictures/image-20211103213453472.png)

#### 6.模板缓存

Thymeleaf会在第一次对模板解析之后进行缓存，极大的提高了并发处理能力。但是这给我们开发带来了不便，修改页面后并不会立刻看到效果，我们开发阶段可以关掉缓存使用：

```
# 开发阶段关闭thymeleaf的模板缓存
spring.thymeleaf.cache=false
```

**注意**：

```
在Idea中，我们需要在修改页面后按快捷键：`Ctrl + Shift + F9` 对项目进行rebuild才可以。
```

### 14.总结

![springboot总结1](C:/Users/Murphy/Pictures/springboot总结1.png)

![springboot总结2](C:/Users/Murphy/Pictures/springboot总结2.png)

-------------------------------

# 微服务spring cloud

### 01.架构的演变

#### 1.集中式架构

当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是影响项目开发的关键。

![image-20211103221128553](C:/Users/Murphy/Pictures/image-20211103221128553.png)

存在的问题：

- 代码耦合，开发维护困难
- 无法针对不同模块进行针对性优化
- 无法水平扩展
- 单点容错率低，并发能力差

#### 2.垂直拆分

当访问量逐渐增大，单一应用无法满足需求，此时为了应对更高的并发和业务需求，我们根据业务功能对系统进行拆分：

![image-20211103221428810](C:/Users/Murphy/Pictures/image-20211103221428810.png)

优点：

- 系统拆分实现了流量分担，解决了并发问题
- 可以针对不同模块进行优化
- 方便水平扩展，负载均衡，容错率提高

缺点：

- 系统间相互独立，会有很多重复开发工作，影响开发效率

#### 3.分布式服务

当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式调用是关键。

![image-20211103221520080](C:/Users/Murphy/Pictures/image-20211103221520080.png)

优点：

- 将基础服务进行了抽取，系统间相互调用，提高了代码复用和开发效率

缺点：

- 系统间耦合度变高，调用关系错综复杂，难以维护

#### 4.流动计算架构（SOA）

SOA ：面向服务的架构

当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键

![image-20211103224248741](C:/Users/Murphy/Pictures/image-20211103224248741.png)

以前出现了什么问题？

- 服务越来越多，需要管理每个服务的地址
- 调用关系错综复杂，难以理清依赖关系
- 服务过多，服务状态难以管理，无法根据服务情况动态管理

服务治理要做什么？

- 服务注册中心，实现服务自动注册和发现，无需人为记录服务地址
- 服务自动订阅，服务列表自动推送，服务调用透明化，无需关心依赖关系
- 动态监控服务状态监控报告，人为控制服务状态

缺点：

- 服务间会有依赖关系，一旦某个环节出错会影响较大
- 服务关系复杂，运维、测试部署困难，不符合DevOps思想

#### 5.微服务

前面说的SOA，英文翻译过来是面向服务。微服务，似乎也是服务，都是对系统进行拆分。因此两者非常容易混淆，但其实却有一些差别：

微服务的特点：

- 单一职责：微服务中每一个服务都对应唯一的业务能力，做到单一职责
- 微：微服务的服务拆分粒度很小，例如一个用户管理就可以作为一个服务。每个服务虽小，但“五脏俱全”。
- 面向服务：面向服务是说每个服务都要对外暴露Rest风格服务接口API。并不关心服务的技术实现，做到与平台和语言无关，也不限定用什么技术实现，只要提供Rest的接口即可。
- 自治：自治是说服务间互相独立，互不干扰
  - 团队独立：每个服务都是一个独立的开发团队，人数不能过多。
  - 技术独立：因为是面向服务，提供Rest接口，使用什么技术没有别人干涉
  - 前后端分离：采用前后端分离开发，提供统一Rest接口，后端不用再为PC、移动段开发不同接口
  - 数据库分离：每个服务都使用自己的数据源
  - 部署独立，服务间虽然有调用，但要做到服务重启不影响其它服务。有利于持续集成和持续交付。每个服务都是独立的组件，可复用，可替换，降低耦合，易维护



微服务结构图：

![image-20211103224339688](C:/Users/Murphy/Pictures/image-20211103224339688.png)

### 02.rpc和http

无论是微服务还是SOA，都面临着服务间的远程调用。那么服务间的远程调用方式有哪些呢？

常见的远程调用方式有以下2种：

- RPC：Remote Produce Call远程过程调用，类似的还有RMI。自定义数据格式，基于原生TCP通信，速度快，效率高。早期的webservice，现在热门的dubbo，都是RPC的典型代表

- Http：http其实是一种网络传输协议，基于TCP，规定了数据传输的格式。现在客户端浏览器与服务端通信基本都是采用Http协议，也可以用来进行远程服务调用。缺点是消息封装臃肿，优势是对服务的提供和调用方没有任何技术限定，自由灵活，更符合微服务理念。

  现在热门的Rest风格，就可以通过http协议来实现。



如果你们公司全部采用Java技术栈，那么使用Dubbo作为微服务架构是一个不错的选择。

相反，如果公司的技术栈多样化，而且你更青睐Spring家族，那么SpringCloud搭建微服务是不二之选。在我们的项目中，我们会选择SpringCloud套件，因此我们会使用Http方式来实现服务间调用。



### 03.http客户端

既然微服务选择了Http，那么我们就需要考虑自己来实现对请求和响应的处理。不过开源世界已经有很多的http客户端工具，能够帮助我们做这些事情，例如：

- HttpClient
- OKHttp
- URLConnection

接下来，不过这些不同的客户端，API各不相同

#### 1.Spring的RestTemplate

Spring提供了一个RestTemplate模板工具类，对基于Http的客户端进行了封装，并且实现了对象与json的序列化和反序列化，非常方便。RestTemplate并没有限定Http的客户端类型，而是进行了抽象，目前常用的3种都有支持：

- HttpClient
- OkHttp
- JDK原生的URLConnection（默认的）



我们导入课前资料提供的demo工程：

![1534812923451](C:/Users/Murphy/Pictures/1534812923451.png)



首先在项目中注册一个`RestTemplate`对象，可以在启动类位置注册：

```java
@SpringBootApplication
public class HttpDemoApplication {

	public static void main(String[] args) {
		SpringApplication.run(HttpDemoApplication.class, args);
	}

	@Bean
	public RestTemplate restTemplate() {
   
		return new RestTemplate();
	}
}
```

在测试类中直接`@Autowired`注入：

```java
@RunWith(SpringRunner.class)
@SpringBootTest(classes = HttpDemoApplication.class)
public class HttpDemoApplicationTests {

	@Autowired
	private RestTemplate restTemplate;

	@Test
	public void httpGet() {
        // 调用springboot案例中的rest接口
		User user = this.restTemplate.getForObject("http://localhost/user/1", User.class);
		System.out.println(user);
	}
}
```

- 通过RestTemplate的getForObject()方法，传递url地址及实体类的字节码，RestTemplate会自动发起请求，接收响应，并且帮我们对响应结果进行反序列化。

![1525573702492](C:/Users/Murphy/Pictures/1525573702492.png)

学习完了Http客户端工具，接下来就可以正式学习微服务了。

### 04.初始springCloud

微服务是一种架构方式，最终肯定需要技术架构去实施。

微服务的实现方式很多，但是最火的莫过于Spring Cloud了。为什么？

- 后台硬：作为Spring家族的一员，有整个Spring全家桶靠山，背景十分强大。
- 技术强：Spring作为Java领域的前辈，可以说是功力深厚。有强力的技术团队支撑，一般人还真比不了
- 群众基础好：可以说大多数程序员的成长都伴随着Spring框架，试问：现在有几家公司开发不用Spring？SpringCloud与Spring的各个框架无缝整合，对大家来说一切都是熟悉的配方，熟悉的味道。
- 使用方便：相信大家都体会到了SpringBoot给我们开发带来的便利，而SpringCloud完全支持SpringBoot的开发，用很少的配置就能完成微服务框架的搭建

#### 1.简介

SpringCloud是Spring旗下的项目之一，[官网地址：http://projects.spring.io/spring-cloud/](http://projects.spring.io/spring-cloud/)

Spring最擅长的就是集成，把世界上最好的框架拿过来，集成到自己的项目中。

SpringCloud也是一样，它将现在非常流行的一些技术整合到一起，实现了诸如：配置管理，服务发现，智能路由，负载均衡，熔断器，控制总线，集群状态等等功能。其主要涉及的组件包括：

- Eureka：服务治理组件，包含服务注册中心，服务注册与发现机制的实现。（服务治理，服务注册/发现） 
- Zuul：网关组件，提供智能路由，访问过滤功能 
- Ribbon：客户端负载均衡的服务调用组件（客户端负载） 
- Feign：服务调用，给予Ribbon和Hystrix的声明式服务调用组件 （声明式服务调用） 
- Hystrix：容错管理组件，实现断路器模式，帮助服务依赖中出现的延迟和为故障提供强大的容错能力。(熔断、断路器，容错) 

#### 2.版本

因为Spring Cloud不同其他独立项目，它拥有很多子项目的大项目。所以它的版本是版本名+版本号 （如Angel.SR6）。  

版本名：是伦敦的地铁名  

版本号：SR（Service Releases）是固定的 ,大概意思是稳定版本。后面会有一个递增的数字。 

所以 Edgware.SR3就是Edgware的第3个Release版本。  



我们在项目中，会是以Finchley的版本。

其中包含的组件，也都有各自的版本

### 05.搭建服务提供方

#### 微服务场景模拟

首先，我们需要模拟一个服务调用的场景，搭建两个工程：itcast-service-provider（服务提供方）和itcast-service-consumer（服务调用方）。方便后面学习微服务架构

服务提供方：使用mybatis操作数据库，实现对数据的增删改查；并对外提供rest接口服务。

服务消费方：使用restTemplate远程调用服务提供方的rest接口服务，获取数据。

#### 服务提供者

我们新建一个项目：itcast-service-provider，对外提供根据id查询用户的服务。

#### 1.Spring脚手架创建工程

借助于Spring提供的快速搭建工具：

![1528266515225](C:/Users/Murphy/Pictures/1528266515225.png)

next-->填写项目信息：

![1528266803455](C:/Users/Murphy/Pictures/1528266803455.png)

next -->  添加web依赖：

![1528266923967](C:/Users/Murphy/Pictures/1528266923967.png)

添加mybatis依赖：

![1528267588935](C:/Users/Murphy/Pictures/1528267588935.png)

Next -->  填写项目位置：

![1528267665004](C:/Users/Murphy/Pictures/1528267665004.png)

生成的项目结构，已经包含了引导类（itcastServiceProviderApplication）：

 ![1528267830854](C:/Users/Murphy/Pictures/1528267830854.png)

依赖也已经全部自动引入：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>cn.itcast.service</groupId>
    <artifactId>itcast-service-provider</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <packaging>jar</packaging>

    <name>itcast-service-provider</name>
    <description>Demo project for Spring Boot</description>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.0.6.RELEASE</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
        <java.version>1.8</java.version>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-jdbc</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.mybatis.spring.boot</groupId>
            <artifactId>mybatis-spring-boot-starter</artifactId>
            <version>1.3.2</version>
        </dependency>

        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <!-- 需要手动引入通用mapper的启动器，spring没有收录该依赖 -->
        <dependency>
            <groupId>tk.mybatis</groupId>
            <artifactId>mapper-spring-boot-starter</artifactId>
            <version>2.0.4</version>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>
```

当然，因为要使用通用mapper，所以我们**需要手动加一条依赖**：

```xml
<dependency>
    <groupId>tk.mybatis</groupId>
    <artifactId>mapper-spring-boot-starter</artifactId>
    <version>2.0.4</version>
</dependency>
```

非常快捷啊！



#### 2.编写代码

 ![1535671376231](C:/Users/Murphy/Pictures/1535671376231.png)

2.1.配置

属性文件,这里我们采用了yaml语法，而不是properties：

```yaml
server:
  port: 8081
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/mybatis #你学习mybatis时，使用的数据库地址
    username: root
    password: root
mybatis:
  type-aliases-package: cn.itcast.service.pojo
```



2.2.实体类

```java
@Table(name = "tb_user")
public class User implements Serializable {

    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // 用户名
    private String userName;

    // 密码
    private String password;

    // 姓名
    private String name;

    // 年龄
    private Integer age;

    // 性别，1男性，2女性
    private Integer sex;

    // 出生日期
    private Date birthday;

    // 创建时间
    private Date created;

    // 更新时间
    private Date updated;

    //Getter、Setter、toString已省略
}
```

2.3.UserMapper

```java
@Mapper
public interface UserMapper extends tk.mybatis.mapper.common.Mapper<User>{
}
```

2.4.UserService

```java
@Service
public class UserService {

    @Autowired
    private UserMapper userMapper;

    public User queryById(Long id) {
        return this.userMapper.selectByPrimaryKey(id);
    }
}
```

2.5.UserController

添加一个对外查询的接口：

```java
@RestController
@RequestMapping("user")
public class UserController {

    @Autowired
    private UserService userService;

    @GetMapping("{id}")
    public User queryById(@PathVariable("id") Long id) {
        return this.userService.queryById(id);
    }
}
```



#### 3.启动并测试

启动项目，访问接口：http://localhost:8081/user/1

![1528272537927](C:/Users/Murphy/Pictures/1528272537927.png)



### 06.搭建服务调用方

搭建itcast-service-consumer服务消费方工程。

#### 4.2.1.创建工程

与上面类似，这里不再赘述，需要注意的是，我们调用itcast-service-provider的解耦获取数据，因此不需要mybatis相关依赖了。

![1528272829384](C:/Users/Murphy/Pictures/1528272829384.png)

![1528272875502](C:/Users/Murphy/Pictures/1528272875502.png)

![1528273029361](C:/Users/Murphy/Pictures/1528273029361.png)

pom：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>cn.itcast.service</groupId>
    <artifactId>itcast-service-consumer</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <packaging>jar</packaging>

    <name>itcast-service-consumer</name>
    <description>Demo project for Spring Boot</description>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.0.4.RELEASE</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
        <java.version>1.8</java.version>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>


</project>

```



#### 4.2.2.编写代码

 ![1540643087305](C:/Users/Murphy/Pictures/1540643087305.png)

首先在引导类中注册`RestTemplate`：

```java
@SpringBootApplication
public class ItcastServiceConsumerApplication {

    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }

    public static void main(String[] args) {
        SpringApplication.run(ItcastServiceConsumerApplication.class, args);
    }
}
```

编写配置（application.yml）：

```
server:
  port: 80
```

编写UserController：

```java
@Controller
@RequestMapping("consumer/user")
public class UserController {

    @Autowired
    private RestTemplate restTemplate;

    @GetMapping
    @ResponseBody
    public User queryUserById(@RequestParam("id") Long id){
        User user = this.restTemplate.getForObject("http://localhost:8081/user/" + id, User.class);
        return user;
    }

}
```

pojo对象（User）：

```java
public class User implements Serializable {

    private static final long serialVersionUID = 1L;

    private Long id;

    // 用户名
    private String userName;

    // 密码
    private String password;

    // 姓名
    private String name;

    // 年龄
    private Integer age;

    // 性别，1男性，2女性
    private Integer sex;

    // 出生日期
    private Date birthday;

    // 创建时间
    private Date created;

    // 更新时间
    private Date updated;

	 //Getter、Setter、toString已省略    
}
```



#### 4.2.3.启动测试

因为我们没有配置端口，那么默认就是8080，我们访问：http://localhost/consumer/user?id=1

![1535587919022](C:/Users/Murphy/Pictures/1535587919022.png)

一个简单的远程服务调用案例就实现了。

### 07.搭建eureka注册中心

#### 1.搭建EurekaServer

接下来我们创建一个项目，启动一个EurekaServer：

依然使用spring提供的快速搭建工具：

![1528295484808](C:/Users/Murphy/Pictures/1528295484808.png)

选择依赖：EurekaServer-服务注册中心依赖，Eureka Discovery-服务提供方和服务消费方。因为，对于eureka来说：服务提供方和服务消费方都属于客户端

![1528295612501](C:/Users/Murphy/Pictures/1528295612501.png)

![1528295690203](C:/Users/Murphy/Pictures/1528295690203.png)

完整的Pom文件：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>cn.itcast.eureka</groupId>
    <artifactId>itcast-eureka</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <packaging>jar</packaging>

    <name>itcast-eureka</name>
    <description>Demo project for Spring Boot</description>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.0.6.RELEASE</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
        <java.version>1.8</java.version>
        <spring-cloud.version>Finchley.RC2</spring-cloud.version>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
        </dependency>

    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>
```

编写application.yml配置：

```yaml
server:
  port: 10086 # 端口
spring:
  application:
    name: eureka-server # 应用名称，会在Eureka中显示
eureka:
  client:
    service-url: # EurekaServer的地址，现在是自己的地址，如果是集群，需要加上其它Server的地址。
      defaultZone: http://127.0.0.1:${server.port}/eureka
```

修改引导类，在类上添加@EnableEurekaServer注解：

```java
@SpringBootApplication
@EnableEurekaServer // 声明当前springboot应用是一个eureka服务中心
public class ItcastEurekaApplication {

    public static void main(String[] args) {
        SpringApplication.run(ItcastEurekaApplication.class, args);
    }
}
```

启动服务，并访问：http://127.0.0.1:10086

![1525604959508](../../assets/1525604959508.png)

![1533793804268](C:/Users/Murphy/Pictures/1533793804268.png)

### 08.改造微服务注册到eureka注册中心

#### 2.注册到Eureka

注册服务，就是在服务上添加Eureka的客户端依赖，客户端代码会自动把服务注册到EurekaServer中。

修改itcast-service-provider工程

1. 在pom.xml中，添加springcloud的相关依赖。
2. 在application.yml中，添加springcloud的相关依赖。
3. 在引导类上添加注解，把服务注入到eureka注册中心。

具体操作

2.1.pom.xml

参照itcast-eureka，先添加SpringCloud依赖：

```xml
<!-- SpringCloud的依赖 -->
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>Finchley.SR2</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```

然后是Eureka客户端：

```xml
<!-- Eureka客户端 -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>
```

完整pom.xml:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>cn.itcast.service</groupId>
    <artifactId>itcast-service-provider</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <packaging>jar</packaging>

    <name>itcast-service-provider</name>
    <description>Demo project for Spring Boot</description>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.0.6.RELEASE</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
        <java.version>1.8</java.version>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-jdbc</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.mybatis.spring.boot</groupId>
            <artifactId>mybatis-spring-boot-starter</artifactId>
            <version>1.3.2</version>
        </dependency>

        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>tk.mybatis</groupId>
            <artifactId>mapper-spring-boot-starter</artifactId>
            <version>2.0.4</version>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>Finchley.SR1</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

</project>
```

2.2.application.yml

```yaml
server:
  port: 8081
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/heima
    username: root
    password: root
    driverClassName: com.mysql.jdbc.Driver
  application:
    name: service-provider # 应用名称，注册到eureka后的服务名称
mybatis:
  type-aliases-package: cn.itcast.service.pojo
eureka:
  client:
    service-url: # EurekaServer地址
      defaultZone: http://127.0.0.1:10086/eureka
```

注意：

- 这里我们添加了spring.application.name属性来指定应用名称，将来会作为应用的id使用。

2.3.引导类

在引导类上开启Eureka客户端功能

通过添加`@EnableDiscoveryClient`来开启Eureka客户端功能

```java
@SpringBootApplication
@EnableDiscoveryClient
public class ItcastServiceProviderApplication {

    public static void main(String[] args) {
        SpringApplication.run(ItcastServiceApplication.class, args);
    }
}
```



> 重启项目，访问[Eureka监控页面](http://127.0.0.1:10086)查看

![1545178177947](C:/Users/Murphy/Pictures/1545178177947.png)

我们发现service-provider服务已经注册成功了

#### 3.从Eureka获取服务

接下来我们修改itcast-service-consumer，尝试从EurekaServer获取服务。

方法与消费者类似，只需要在项目中添加EurekaClient依赖，就可以通过服务名称来获取信息了！

1. pom.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>cn.itcast.service</groupId>
    <artifactId>itcast-service-consumer</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <packaging>jar</packaging>

    <name>itcast-service-consumer</name>
    <description>Demo project for Spring Boot</description>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.0.6.RELEASE</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
        <java.version>1.8</java.version>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <!-- Eureka客户端 -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

    <!-- SpringCloud的依赖 -->
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>Finchley.SR2</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
</project>

```

2. 修改配置

```yaml
server:
  port: 80
spring:
  application:
    name: service-consumer
eureka:
  client:
    service-url:
      defaultZone: http://localhost:10086/eureka
```

3. 在启动类开启Eureka客户端

```java
@SpringBootApplication
@EnableDiscoveryClient // 开启Eureka客户端
public class ItcastServiceConsumerApplication {

    @Bean
    public RestTemplate restTemplate(){
        return new RestTemplate();
    }

    public static void main(String[] args) {
        SpringApplication.run(ItcastServiceConsumerApplication.class, args);
    }
}
```

4. 修改UserController代码，用DiscoveryClient类的方法，根据服务名称，获取服务实例：

```java
@Controller
@RequestMapping("consumer/user")
public class UserController {

    @Autowired
    private RestTemplate restTemplate;

    @Autowired
    private DiscoveryClient discoveryClient; // eureka客户端，可以获取到eureka中服务的信息

    @GetMapping
    @ResponseBody
    public User queryUserById(@RequestParam("id") Long id){
        // 根据服务名称，获取服务实例。有可能是集群，所以是service实例集合
        List<ServiceInstance> instances = discoveryClient.getInstances("service-provider");
        // 因为只有一个Service-provider。所以获取第一个实例
        ServiceInstance instance = instances.get(0);
        // 获取ip和端口信息，拼接成服务地址
        String baseUrl = "http://" + instance.getHost() + ":" + instance.getPort() + "/user/" + id;
        User user = this.restTemplate.getForObject(baseUrl, User.class);
        return user;
    }

}
```



5）Debug跟踪运行：

![1528534110188](C:/Users/Murphy/Pictures/1528534110188.png)

生成的URL：

![1528534148651](C:/Users/Murphy/Pictures/1528534148651.png)

访问结果：

![1535674665806](C:/Users/Murphy/Pictures/1535674665806.png)

### 09.改造消费方解决地址硬编码问题

如上使用DiscoveryClient类

要注意导入的包 org.springframework.cloud.client.discovery.DiscoveryClient;

### 10.高可用的eureka

#### 1.基础架构

Eureka架构中的三个核心角色：

- 服务注册中心

  Eureka的服务端应用，提供服务注册和发现功能，就是刚刚我们建立的itcast-eureka。

- 服务提供者

  提供服务的应用，可以是SpringBoot应用，也可以是其它任意技术实现，只要对外提供的是Rest风格服务即可。本例中就是我们实现的itcast-service-provider。

- 服务消费者

  消费应用从注册中心获取服务列表，从而得知每个服务方的信息，知道去哪里调用服务方。本例中就是我们实现的itcast-service-consumer。

#### 2.高可用的Eureka Server

Eureka Server即服务的注册中心，在刚才的案例中，我们只有一个EurekaServer，事实上EurekaServer也可以是一个集群，形成高可用的Eureka中心。

> 服务同步

多个Eureka Server之间也会互相注册为服务，当服务提供者注册到Eureka Server集群中的某个节点时，该节点会把服务的信息同步给集群中的每个节点，从而实现**数据同步**。因此，无论客户端访问到Eureka Server集群中的任意一个节点，都可以获取到完整的服务列表信息。



> 动手搭建高可用的EurekaServer

我们假设要运行两个EurekaServer的集群，端口分别为：10086和10087。只需要把itcast-eureka启动两次即可。

1）启动第一个eurekaServer，我们修改原来的EurekaServer配置：

```yaml
server:
  port: 10086 # 端口
spring:
  application:
    name: eureka-server # 应用名称，会在Eureka中显示
eureka:
  client:
    service-url: # 配置其他Eureka服务的地址，而不是自己，比如10087
      defaultZone: http://127.0.0.1:10087/eureka
```

所谓的高可用注册中心，其实就是把EurekaServer自己也作为一个服务进行注册，这样多个EurekaServer之间就能互相发现对方，从而形成集群。因此我们做了以下修改：

- 把service-url的值改成了另外一台EurekaServer的地址，而不是自己

启动报错，很正常。因为10087服务没有启动：

![1528691515859](C:/Users/Murphy/Pictures/1528691515859.png)

2）启动第二个eurekaServer，再次修改itcast-eureka的配置：

```yaml
server:
  port: 10087 # 端口
spring:
  application:
    name: eureka-server # 应用名称，会在Eureka中显示
eureka:
  client:
    service-url: # 配置其他Eureka服务的地址，而不是自己，比如10087
      defaultZone: http://127.0.0.1:10086/eureka
```

注意：idea中一个应用不能启动两次，我们需要重新配置一个启动器：

![1528540668018](C:/Users/Murphy/Pictures/1528540668018.png)

![1528691728618](C:/Users/Murphy/Pictures/1528691728618.png)

![1528693484031](C:/Users/Murphy/Pictures/1528693484031.png)

然后启动即可。

3）访问集群，测试：

![1528693648200](C:/Users/Murphy/Pictures/1528693648200.png)

4）客户端注册服务到集群

因为EurekaServer不止一个，因此注册服务的时候，service-url参数需要变化：

```yaml
eureka:
  client:
    service-url: # EurekaServer地址,多个地址以','隔开
      defaultZone: http://127.0.0.1:10086/eureka,http://127.0.0.1:10087/eureka
```

也可以不注册，如果10086宕机，服务会自动传递。10087还是能够看到注册到10086的客户端和消费者，如下图

![image-20211105113616801](C:/Users/Murphy/Pictures/image-20211105113616801.png)

不宕机的时候，可以互相看到

10086：

![1528693943950](C:/Users/Murphy/Pictures/1528693943950.png)

10087：

![1528693979654](C:/Users/Murphy/Pictures/1528693979654.png)



### 11.eureka详解

#### 3.服务提供者

服务提供者要向EurekaServer注册服务，并且完成服务续约等工作。

> 服务注册

服务提供者在启动时，会检测配置属性中的：`eureka.client.register-with-eureka=true`参数是否正确，事实上默认就是true。如果值确实为true，则会向EurekaServer发起一个Rest请求，并携带自己的元数据信息，Eureka Server会把这些信息保存到一个双层Map结构中。

- 第一层Map的Key就是服务id，一般是配置中的`spring.application.name`属性
- 第二层Map的key是服务的实例id。一般host+ serviceId + port，例如：`locahost:service-provider:8081`
- 值则是服务的实例对象，也就是说一个服务，可以同时启动多个不同实例，形成集群。

> 服务续约

在注册服务完成以后，服务提供者会维持一个心跳（定时向EurekaServer发起Rest请求），告诉EurekaServer：“我还活着”。这个我们称为服务的续约（renew）；

有两个重要参数可以修改服务续约的行为：

```yaml
eureka:
  instance:
    lease-expiration-duration-in-seconds: 90
    lease-renewal-interval-in-seconds: 30
```

- lease-renewal-interval-in-seconds：服务续约(renew)的间隔，默认为30秒
- lease-expiration-duration-in-seconds：服务失效时间，默认值90秒

也就是说，默认情况下每个30秒服务会向注册中心发送一次心跳，证明自己还活着。如果超过90秒没有发送心跳，EurekaServer就会认为该服务宕机，会从服务列表中移除，这两个值在生产环境不要修改，默认即可。

但是在开发时，这个值有点太长了，经常我们关掉一个服务，会发现Eureka依然认为服务在活着。所以我们在开发阶段可以适当调小。

```yaml
eureka:
  instance:
    lease-expiration-duration-in-seconds: 10 # 10秒即过期
    lease-renewal-interval-in-seconds: 5 # 5秒一次心跳
```



#### 4.服务消费者

> 获取服务列表

当服务消费者启动时，会检测`eureka.client.fetch-registry=true`参数的值，如果为true，则会拉取Eureka Server服务的列表只读备份，然后缓存在本地。并且`每隔30秒`会重新获取并更新数据。我们可以通过下面的参数来修改：

```yaml
eureka:
  client:
    registry-fetch-interval-seconds: 5
```

生产环境中，我们不需要修改这个值。

但是为了开发环境下，能够快速得到服务的最新状态，我们可以将其设置小一点。



#### 5.失效剔除和自我保护

> 服务下线

当服务进行正常关闭操作时，它会触发一个服务下线的REST请求给Eureka Server，告诉服务注册中心：“我要下线了”。服务中心接受到请求之后，将该服务置为下线状态。

> 失效剔除

有些时候，我们的服务提供方并不一定会正常下线，可能因为内存溢出、网络故障等原因导致服务无法正常工作。Eureka Server需要将这样的服务剔除出服务列表。因此它会开启一个定时任务，每隔60秒对所有失效的服务（超过90秒未响应）进行剔除。

可以通过`eureka.server.eviction-interval-timer-in-ms`参数对其进行修改，单位是毫秒，生产环境不要修改。

这个会对我们开发带来极大的不变，你对服务重启，隔了60秒Eureka才反应过来。开发阶段可以适当调整，比如：10秒

![1528696142799](C:/Users/Murphy/Pictures/1528696142799.png)



> 自我保护

我们关停一个服务，就会在Eureka面板看到一条警告：

![1525618396076](../../assets/1525618396076.png)

这是触发了Eureka的自我保护机制。当一个服务未按时进行心跳续约时，Eureka会统计最近15分钟心跳失败的服务实例的比例是否超过了85%。在生产环境下，因为网络延迟等原因，心跳失败实例的比例很有可能超标，但是此时就把服务剔除列表并不妥当，因为服务可能没有宕机。Eureka就会把当前实例的注册信息保护起来，不予剔除。生产环境下这很有效，保证了大多数服务依然可用。

但是这给我们的开发带来了麻烦， 因此开发阶段我们都会关闭自我保护模式：（itcast-eureka）

```yaml
eureka:
  server:
    enable-self-preservation: false # 关闭自我保护模式（缺省为打开）
    eviction-interval-timer-in-ms: 1000 # 扫描失效服务的间隔时间（缺省为60*1000ms）
```

### 12.总结

```
1.架构的演变
传统架构-->水平拆分-->垂直拆分（最早的分布式）-->soa(dubbo)-->微服务(springCloud)

2.远程调用技术：rpc http
rpc协议：自定义数据格式，限定技术，传输速度快，效率高 tcp，dubbo
http协议：统一的数据格式，不限定技术 rest接口  tcp协议 springCloud

3.什么是springCloud
微服务架构的解决方案，是很多组件的集合
eureka：注册中心，服务的注册与发现
zull：网关协议，路由请求，过滤器（ribbon hystrix）
ribbon：负载均衡组件
hystrix：熔断组件
feign：远程调用组件(ribbon hystrix)

*4.eureka
注册中心：itcast-eureka（1.引入启动器， 2.配置spring.application.name=itcast-eureka 3.在引导类上@EnableEurekaServer）
客户端：itcast-service-provider itcast-service-consumer
	（1.引入启动器 2.配置spring.application.name eureka.client.service-url.defaultZone=http://localhost:10086/eureka 3.@EnableDiscoveryClient(启用eure客户端)）
```

### 13.ribbon负载均衡

在刚才的案例中，我们启动了一个itcast-service-provider，然后通过DiscoveryClient来获取服务实例信息，然后获取ip和端口来访问。

但是实际环境中，我们往往会开启很多个itcast-service-provider的集群。此时我们获取的服务列表中就会有多个，到底该访问哪一个呢？

一般这种情况下我们就需要编写负载均衡算法，在多个实例列表中进行选择。

不过Eureka中已经帮我们集成了负载均衡组件：Ribbon，简单修改代码即可使用。

什么是Ribbon：

![image-20211105212623855](C:/Users/Murphy/Pictures/image-20211105212623855.png)

接下来，我们就来使用Ribbon实现负载均衡。



#### 6.1.启动两个服务实例

首先参照itcast-eureka启动两个ItcastServiceProviderApplication实例，一个8081，一个8082。

 ![1540644966386](C:/Users/Murphy/Pictures/1540644966386.png)

Eureka监控面板：

![1540645032363](C:/Users/Murphy/Pictures/1540645032363.png)



#### 6.2.开启负载均衡

因为Eureka中已经集成了Ribbon，所以我们无需引入新的依赖，直接修改代码。

修改itcast-service-consumer的引导类，在RestTemplate的配置方法上添加`@LoadBalanced`注解：

```java
@Bean
@LoadBalanced
public RestTemplate restTemplate() {
    return new RestTemplate();
}
```



修改调用方式，不再手动获取ip和端口，而是直接通过服务名称调用：

```java
@Controller
@RequestMapping("consumer/user")
public class UserController {

    @Autowired
    private RestTemplate restTemplate;

    //@Autowired
    //private DiscoveryClient discoveryClient; // 注入discoveryClient，通过该客户端获取服务列表

    @GetMapping
    @ResponseBody
    public User queryUserById(@RequestParam("id") Long id){
        // 通过client获取服务提供方的服务列表，这里我们只有一个
        // ServiceInstance instance = discoveryClient.getInstances("service-provider").get(0);
        String baseUrl = "http://service-provider/user/" + id;
        User user = this.restTemplate.getForObject(baseUrl, User.class);
        return user;
    }

}
```

访问页面，查看结果：

![1535674665806](C:/Users/Murphy/Pictures/1535674665806-16361186903474.png)

完美！



#### 6.3.源码跟踪

为什么我们只输入了service名称就可以访问了呢？之前还要获取ip和端口。

显然有人帮我们根据service名称，获取到了服务实例的ip和端口。它就是`LoadBalancerInterceptor`

在如下代码打断点：

![1528774637934](C:/Users/Murphy/Pictures/1528774637934.png)

一路源码跟踪：RestTemplate.getForObject --> RestTemplate.execute --> RestTemplate.doExecute：

![1528776129378](C:/Users/Murphy/Pictures/1528776129378.png)

点击进入AbstractClientHttpRequest.execute --> AbstractBufferingClientHttpRequest.executeInternal --> InterceptingClientHttpRequest.executeInternal --> InterceptingClientHttpRequest.execute:

![1528776489965](C:/Users/Murphy/Pictures/1528776489965.png)

继续跟入：LoadBalancerInterceptor.intercept方法

![1528775270103](C:/Users/Murphy/Pictures/1528775270103.png)

继续跟入execute方法：发现获取了8082端口的服务

![1528775890956](C:/Users/Murphy/Pictures/1528775890956.png)

再跟下一次，发现获取的是8081：

![1528775845812](C:/Users/Murphy/Pictures/1528775845812.png)



#### 6.4.负载均衡策略

Ribbon默认的负载均衡策略是简单的轮询，我们可以测试一下：

编写测试类，在刚才的源码中我们看到拦截中是使用

RibbonLoadBalanceClient来进行负载均衡的，其中有一个choose方法，找到choose方法的接口方法，是这样介绍的：

 ![1525622320277](C:/Users/Murphy/Pictures/1525622320277.png)

现在这个就是负载均衡获取实例的方法。

我们注入这个类的对象，然后对其测试：

 ![1528780835917](C:/Users/Murphy/Pictures/1528780835917.png)

测试内容：

```java
@RunWith(SpringRunner.class)
@SpringBootTest(classes = ItcastServiceConsumerApplication.class)
public class LoadBalanceTest {

    @Autowired
    private RibbonLoadBalancerClient client;

    @Test
    public void testLoadBalance(){
        for (int i = 0; i < 100; i++) {
            ServiceInstance instance = this.client.choose("service-provider");
            System.out.println(instance.getHost() + ":" +instance.getPort());
        }
    }
}

```

结果：

![1535338345659](C:/Users/Murphy/Pictures/1535338345659.png)

符合了我们的预期推测，确实是轮询方式。



我们是否可以修改负载均衡的策略呢？

继续跟踪源码，发现这么一段代码：

 ![1525622652849](C:/Users/Murphy/Pictures/1525622652849.png)

我们看看这个rule是谁：

 ![1525622699666](C:/Users/Murphy/Pictures/1525622699666.png)

这里的rule默认值是一个`RoundRobinRule`，看类的介绍：

 ![1525622754316](C:/Users/Murphy/Pictures/1525622754316.png)

这不就是轮询的意思嘛。

我们注意到，这个类其实是实现了接口IRule的，查看一下：

 ![1525622817451](C:/Users/Murphy/Pictures/1525622817451.png)

定义负载均衡的规则接口。

它有以下实现：

 ![1528782624098](C:/Users/Murphy/Pictures/1528782624098.png)

SpringBoot也帮我们提供了修改负载均衡规则的配置入口，在itcast-service-consumer的application.yml中添加如下配置：

```yaml
server:
  port: 80
spring:
  application:
    name: service-consumer
eureka:
  client:
    service-url:
      defaultZone: http://127.0.0.1:10086/eureka
service-provider:
  ribbon:
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule
```

格式是：`{服务名称}.ribbon.NFLoadBalancerRuleClassName`，值就是IRule的实现类。



再次测试，发现结果变成了随机：

![1528782514987](C:/Users/Murphy/Pictures/1528782514987.png)

### 14.hystrix简介

#### 1.简介

Hystrix,英文意思是豪猪，全身是刺，看起来就不好惹，是一种保护机制。

Hystrix也是Netflix公司的一款组件。

主页：https://github.com/Netflix/Hystrix/

![1525658740266](C:/Users/Murphy/Pictures/1525658740266.png)

那么Hystix的作用是什么呢？具体要保护什么呢？

Hystix是Netflix开源的一个延迟和容错库，用于隔离访问远程服务、第三方库，防止出现级联失败。



#### 2.雪崩问题

微服务中，服务间调用关系错综复杂，一个请求，可能需要调用多个微服务接口才能实现，会形成非常复杂的调用链路：

 ![1533829099748](C:/Users/Murphy/Pictures/1533829099748.png)

如图，一次业务请求，需要调用A、P、H、I四个服务，这四个服务又可能调用其它服务。

如果此时，某个服务出现异常：

 ![1533829198240](C:/Users/Murphy/Pictures/1533829198240.png)

例如微服务I发生异常，请求阻塞，用户不会得到响应，则tomcat的这个线程不会释放，于是越来越多的用户请求到来，越来越多的线程会阻塞：

 ![1533829307389](C:/Users/Murphy/Pictures/1533829307389.png)

服务器支持的线程和并发数有限，请求一直阻塞，会导致服务器资源耗尽，从而导致所有其它服务都不可用，形成雪崩效应。

这就好比，一个汽车生产线，生产不同的汽车，需要使用不同的零件，如果某个零件因为种种原因无法使用，那么就会造成整台车无法装配，陷入等待零件的状态，直到零件到位，才能继续组装。  此时如果有很多个车型都需要这个零件，那么整个工厂都将陷入等待的状态，导致所有生产都陷入瘫痪。一个零件的波及范围不断扩大。 



Hystix解决雪崩问题的手段有两个：

- 线程隔离
- 服务熔断

### 15.hystrix服务降级

#### 3.线程隔离，服务降级

3.1.原理

线程隔离示意图：

 ![1533829598310](C:/Users/Murphy/Pictures/1533829598310.png)

解读：

Hystrix为每个依赖服务调用分配一个小的线程池，如果线程池已满调用将被立即拒绝，默认不采用排队.加速失败判定时间。

用户的请求将不再直接访问服务，而是通过线程池中的空闲线程来访问服务，如果**线程池已满**，或者**请求超时**，则会进行降级处理，什么是服务降级？

> 服务降级：优先保证核心服务，而非核心服务不可用或弱可用。

用户的请求故障时，不会被阻塞，更不会无休止的等待或者看到系统崩溃，至少可以看到一个执行结果（例如返回友好的提示信息） 。

服务降级虽然会导致请求失败，但是不会导致阻塞，而且最多会影响这个依赖服务对应的线程池中的资源，对其它服务没有响应。

触发Hystix服务降级的情况：

- 线程池已满
- 请求超时

#### 3.2.动手实践

2.1.引入依赖

首先在itcast-service-consumer的pom.xml中引入Hystrix依赖：

### 16.hystrix之熔断

#### 1.引入依赖

首先在itcast-service-consumer的pom.xml中引入Hystrix依赖：

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>
</dependency>
```

#### 2.开启熔断

![1535341341482](C:/Users/Murphy/Pictures/1535341341482.png)

可以看到，我们类上的注解越来越多，在微服务中，经常会引入上面的三个注解，于是Spring就提供了一个组合注解：@SpringCloudApplication

![1535341390087](C:/Users/Murphy/Pictures/1535341390087.png)

因此，我们可以使用这个组合注解来代替之前的3个注解。

```java
@SpringCloudApplication
public class ItcastServiceConsumerApplication {

    @Bean
    @LoadBalanced
    public RestTemplate restTemplate(){
        return new RestTemplate();
    }

    public static void main(String[] args) {
        SpringApplication.run(ItcastServiceConsumerApplication.class, args);
    }
}
```

#### 3.编写降级逻辑

我们改造itcast-service-consumer，当目标服务的调用出现故障，我们希望快速失败，给用户一个友好提示。因此需要提前编写好失败时的降级处理逻辑，要使用HystixCommond来完成：

```java
@Controller
@RequestMapping("consumer/user")
public class UserController {

    @Autowired
    private RestTemplate restTemplate;

    @GetMapping
    @ResponseBody
    @HystrixCommand(fallbackMethod = "queryUserByIdFallBack")
    public String queryUserById(@RequestParam("id") Long id) {
        String user = this.restTemplate.getForObject("http://service-provider/user/" + id, String.class);
        return user;
    }

    public String queryUserByIdFallBack(Long id){
        return "请求繁忙，请稍后再试！";
    }
}
```

要注意，因为熔断的降级逻辑方法必须跟正常逻辑方法保证：**相同的参数列表和返回值声明**。失败逻辑中返回User对象没有太大意义，一般会返回友好提示。所以我们把queryById的方法改造为返回String，反正也是Json数据。这样失败逻辑中返回一个错误说明，会比较方便。

说明：

- @HystrixCommand(fallbackMethod = "queryByIdFallBack")：用来声明一个降级逻辑的方法

测试：

当itcast-service-provder正常提供服务时，访问与以前一致。但是当我们将itcast-service-provider停机时，会发现页面返回了降级处理信息：

![1535852634763](C:/Users/Murphy/Pictures/1535852634763.png)

#### 4.默认FallBack

我们刚才把fallback写在了某个业务方法上，如果这样的方法很多，那岂不是要写很多。所以我们可以把Fallback配置加在类上，实现默认fallback：

```java
@Controller
@RequestMapping("consumer/user")
@DefaultProperties(defaultFallback = "fallBackMethod") // 指定一个类的全局熔断方法
public class UserController {

    @Autowired
    private RestTemplate restTemplate;

    @GetMapping
    @ResponseBody
    @HystrixCommand // 标记该方法需要熔断
    public String queryUserById(@RequestParam("id") Long id) {
        String user = this.restTemplate.getForObject("http://service-provider/user/" + id, String.class);
        return user;
    }

    /**
     * 熔断方法
     * 返回值要和被熔断的方法的返回值一致
     * 熔断方法不需要参数
     * @return
     */
    public String fallBackMethod(){
        return "请求繁忙，请稍后再试！";
    }
}
```

- @DefaultProperties(defaultFallback = "defaultFallBack")：在类上指明统一的失败降级方法
- @HystrixCommand：在方法上直接使用该注解，使用默认的剪辑方法。
- defaultFallback：默认降级方法，不用任何参数，以匹配更多方法，但是返回值一定一致

![1535852634763](C:/Users/Murphy/Pictures/1535852634763.png)

#### 5.设置超时

在之前的案例中，请求在超过1秒后都会返回错误信息，这是因为Hystix的默认超时时长为1，我们可以通过配置修改这个值：

我们可以通过`hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds`来设置Hystrix超时时间。该配置没有提示。

```yaml
hystrix:
  command:
    default:
      execution:
        isolation:
          thread:
            timeoutInMilliseconds: 6000 # 设置hystrix的超时时间为6000ms
```

**改造服务提供者**

改造服务提供者的UserController接口，随机休眠一段时间，以触发熔断：

```java
@GetMapping("{id}")
public User queryUserById(@PathVariable("id") Long id) {
    try {
        Thread.sleep(6000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    return this.userService.queryUserById(id);
}
```

#### 6.服务熔断

熔断原理

熔断器，也叫断路器，其英文单词为：Circuit Breaker 

![1525658640314](C:/Users/Murphy/Pictures/1525658640314.png)



熔断状态机3个状态：

- Closed：关闭状态，所有请求都正常访问。
- Open：打开状态，所有请求都会被降级。Hystix会对请求情况计数，当一定时间内失败请求百分比达到阈值，则触发熔断，断路器会完全打开。默认失败比例的阈值是50%，请求次数最少不低于20次。
- Half Open：半开状态，open状态不是永久的，打开后会进入休眠时间（默认是5S）。随后断路器会自动进入半开状态。此时会释放部分请求通过，若这些请求都是健康的，则会完全关闭断路器，否则继续保持打开，再次进行休眠计时



动手实践

为了能够精确控制请求的成功或失败，我们在consumer的调用业务中加入一段逻辑：

```java
@GetMapping("{id}")
@HystrixCommand
public String queryUserById(@PathVariable("id") Long id){
    if(id == 1){
        throw new RuntimeException("太忙了");
    }
    String user = this.restTemplate.getForObject("http://service-provider/user/" + id, String.class);
    return user;
}
```

这样如果参数是id为1，一定失败，其它情况都成功。（不要忘了清空service-provider中的休眠逻辑）

我们准备两个请求窗口：

- 一个请求：http://localhost/consumer/user/1，注定失败
- 一个请求：http://localhost/consumer/user/2，肯定成功

当我们疯狂访问id为1的请求时（超过20次），就会触发熔断。断路器会断开，一切请求都会被降级处理。

此时你访问id为2的请求，会发现返回的也是失败，而且失败时间很短，只有几毫秒左右：

![1543053265477](C:/Users/Murphy/Pictures/1543053265477.png)



不过，默认的熔断触发要求较高，休眠时间窗较短，为了测试方便，我们可以通过配置修改熔断策略：

```properties
circuitBreaker.requestVolumeThreshold=10
circuitBreaker.sleepWindowInMilliseconds=10000
circuitBreaker.errorThresholdPercentage=50
```

解读：

- requestVolumeThreshold：触发熔断的最小请求次数，默认20
- errorThresholdPercentage：触发熔断的失败请求最小占比，默认50%
- sleepWindowInMilliseconds：休眠时长，默认是5000毫秒

阶段总结

```

1.引入启动器
2.覆盖默认配置
3.在引导类上启用组件

1.高可用 itcast-eureka
10086 10087

2.心跳过期 itcast-service-provider
eureka：
	instance:
		lease-renewal-interval-in-seconds: 5 # 心跳时间
		lease-expiration-duration-in-seconds: 15 # 过期时间

3.拉取服务的间隔时间 itcast-service-consumer
eureka:
  client:
    registry-fetch-interval-seconds: 5

4.关闭自我保护，定期清除无效连接
eureka:
  server:
    eviction-interval-timer-in-ms: 5000 
    enable-self-preservation: false

ribbon: 负载均衡组件
	1.eureka集成了
	2.@LoadBalanced：开启负载均衡
	3.this.restTemplate.getForObject("http://service-provider/user/" + id, User.class);
	
hystrix：容错组件
	降级：检查每次请求，是否请求超时，或者连接池已满
		1.引入hystrix启动器
		2.熔断时间，默认1s， 6s
		3.在引导类上添加了一个注解：@EnableCircuitBreaker  @SpringCloudApplication
		4.定义熔断方法：局部（要和被熔断的方法返回值和参数列表一致）  全局（返回值类型要被熔断的方法一致，参数列表必须为空）
		5.@HystrixCommand(fallbackMethod="局部熔断方法名")：声明被熔断的方法
		6.@DefaultProperties(defaultFallback="全局熔断方法名")
	熔断：不再发送请求
		1.close：闭合状态，所有请求正常方法
		2.open：打开状态，所有请求都无法访问。如果在一定时间内容，失败的比例不小于50%或者次数不少于20次
		3.half open：半开状态，打开状态默认5s休眠期，在休眠期所有请求无法正常访问。过了休眠期会进入半开状态，放部分请求通过
```

### 17.feign的玩法

在前面的学习中，我们使用了Ribbon的负载均衡功能，大大简化了远程调用时的代码：

```java
String user = this.restTemplate.getForObject("http://service-provider/user/" + id, String.class);
```

如果就学到这里，你可能以后需要编写类似的大量重复代码，格式基本相同，无非参数不一样。有没有更优雅的方式，来对这些代码再次优化呢？

这就是我们接下来要学的Feign的功能了。



#### 1.简介

有道词典的英文解释：

![1528855057359](C:/Users/Murphy/Pictures/1528855057359.png)

为什么叫伪装？

Feign可以把Rest的请求进行隐藏，伪装成类似SpringMVC的Controller一样。你不用再自己拼接url，拼接参数等等操作，一切都交给Feign去做。



项目主页：https://github.com/OpenFeign/feign

![1525652009416](C:/Users/Murphy/Pictures/1525652009416.png)



#### 2.快速入门

改造itcast-service-consumer工程

2.1.导入依赖

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>
```



2.2.开启Feign功能

我们在启动类上，**添加注解**，开启Feign功能

```java
@SpringCloudApplication
@EnableFeignClients // 开启feign客户端
public class ItcastServiceConsumerApplication {
    
    public static void main(String[] args) {
        SpringApplication.run(ItcastServiceConsumerApplication.class, args);
    }
}
```

**删除RestTemplate**：feign已经自动集成了Ribbon负载均衡的RestTemplate。所以，此处不需要再注册RestTemplate。



#### 2.3.Feign的客户端

在itcast-service-consumer工程中，添加UserClient接口：

 ![1540683659305](C:/Users/Murphy/Pictures/1540683659305.png)

内容：

```java
@FeignClient(value = "service-provider") // 标注该类是一个feign接口
public interface UserClient {

    @GetMapping("user/{id}")
    User queryById(@PathVariable("id") Long id);
}
```

- 首先这是一个接口，Feign会通过动态代理，帮我们生成实现类。这点跟mybatis的mapper很像
- `@FeignClient`，声明这是一个Feign客户端，类似`@Mapper`注解。同时通过`value`属性指定服务名称
- 接口中的定义方法，完全采用SpringMVC的注解，Feign会根据注解帮我们生成URL，并访问获取结果

改造原来的调用逻辑，调用UserClient接口：

```java
@Controller
@RequestMapping("consumer/user")
public class UserController {

    @Autowired
    private UserClient userClient;

    @GetMapping
    @ResponseBody
    public User queryUserById(@RequestParam("id") Long id){
        User user = this.userClient.queryUserById(id);
        return user;
    }

}
```



#### 2.4.启动测试

访问接口： 

![1535346290987](C:/Users/Murphy/Pictures/1535346290987.png)

正常获取到了结果。

#### 3.负载均衡

Feign中本身已经集成了Ribbon依赖和自动配置：

![1528859608579](C:/Users/Murphy/Pictures/1528859608579.png)

因此我们不需要额外引入依赖，也不需要再注册`RestTemplate`对象。



#### 4.Hystrix支持

Feign默认也有对Hystrix的集成：

![1528861288636](C:/Users/Murphy/Pictures/1528861288636.png)

只不过，默认情况下是关闭的。我们需要通过下面的参数来开启：(在itcast-service-consumer工程添加配置内容)

```yaml
feign:
  hystrix:
    enabled: true # 开启Feign的熔断功能
```

但是，Feign中的Fallback配置不像hystrix中那样简单了。

1）首先，我们要定义一个类UserClientFallback，实现刚才编写的UserClient，作为fallback的处理类

 ![1540683742479](C:/Users/Murphy/Pictures/1540683742479.png)

```java
@Component
public class UserClientFallback implements UserClient {

    @Override
    public User queryById(Long id) {
        User user = new User();
        user.setUserName("服务器繁忙，请稍后再试！");
        return user;
    }
}
```

2）然后在UserFeignClient中，指定刚才编写的实现类

```java
@FeignClient(value = "service-provider", fallback = UserClientFallback.class) // 标注该类是一个feign接口
public interface UserClient {

    @GetMapping("user/{id}")
    User queryUserById(@PathVariable("id") Long id);
}
```

3）重启测试：

![1535346896313](C:/Users/Murphy/Pictures/1535346896313.png)



#### 5.请求压缩(了解)

Spring Cloud Feign 支持对请求和响应进行GZIP压缩，以减少通信过程中的性能损耗。通过下面的参数即可开启请求与响应的压缩功能：

```yaml
feign:
  compression:
    request:
      enabled: true # 开启请求压缩
    response:
      enabled: true # 开启响应压缩
```

同时，我们也可以对请求的数据类型，以及触发压缩的大小下限进行设置：

```yaml
feign:
  compression:
    request:
      enabled: true # 开启请求压缩
      mime-types: text/html,application/xml,application/json # 设置压缩的数据类型
      min-request-size: 2048 # 设置触发压缩的大小下限
```

注：上面的数据类型、压缩大小下限均为默认值。



#### 6.日志级别(了解)

前面讲过，通过`logging.level.xx=debug`来设置日志级别。然而这个对Fegin客户端而言不会产生效果。因为`@FeignClient`注解修改的客户端在被代理时，都会创建一个新的Fegin.Logger实例。我们需要额外指定这个日志的级别才可以。

1）设置com.leyou包下的日志级别都为debug

```yaml
logging:
  level:
    cn.itcast: debug
```

2）编写配置类，定义日志级别

 ![1529113196740](C:/Users/Murphy/Pictures/1529113196740.png)

内容：

```java
@Configuration
public class FeignLogConfiguration {

    @Bean
    Logger.Level feignLoggerLevel(){
        return Logger.Level.FULL;
    }
}
```

这里指定的Level级别是FULL，Feign支持4种级别：

![1528863525224](C:/Users/Murphy/Pictures/1528863525224.png)

- NONE：不记录任何日志信息，这是默认值。
- BASIC：仅记录请求的方法，URL以及响应状态码和执行时间
- HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息
- FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。



3）在FeignClient中指定配置类：

```java
@FeignClient(value = "service-privider", fallback = UserFeignClientFallback.class, configuration = FeignConfig.class)
public interface UserFeignClient {
    @GetMapping("/user/{id}")
    User queryUserById(@PathVariable("id") Long id);
}
```

4）重启项目，即可看到每次访问的日志：

![1528863489923](C:/Users/Murphy/Pictures/1528863489923.png)



### 18.feign总结

```
feign
	1.引入openFeign启动器
	2.feign.hystrix.enable=true,开启feign的熔断功能
	3.在引导类上 @EnableFeignClients
	4.创建一个接口，在接口添加@FeignClient(value="服务id", fallback=实现类.class)
	5.在接口中定义一些方法，这些方法的书写方式跟之前controller类似
	6.创建了一个熔断类，实现feign接口，实现对应的方法，这些实现方法就是熔断方法
```

### 19.zuu简介

通过前面的学习，使用Spring Cloud实现微服务的架构基本成型，大致是这样的：

![1525674644660](C:/Users/Murphy/Pictures/1525674644660.png)

	我们使用Spring Cloud Netflix中的Eureka实现了服务注册中心以及服务注册与发现；而服务间通过Ribbon或Feign实现服务的消费以及均衡负载。为了使得服务集群更为健壮，使用Hystrix的融断机制来避免在微服务架构中个别服务出现异常时引起的故障蔓延。
	
	在该架构中，我们的服务集群包含：内部服务Service A和Service B，他们都会注册与订阅服务至Eureka Server，而Open Service是一个对外的服务，通过均衡负载公开至服务调用方。我们把焦点聚集在对外服务这块，直接暴露我们的服务地址，这样的实现是否合理，或者是否有更好的实现方式呢？



先来说说这样架构需要做的一些事儿以及存在的不足：

- 破坏了服务无状态特点。

  	为了保证对外服务的安全性，我们需要实现对服务访问的权限控制，而开放服务的权限控制机制将会贯穿并污染整个开放服务的业务逻辑，这会带来的最直接问题是，破坏了服务集群中REST API无状态的特点。
  	
  	从具体开发和测试的角度来说，在工作中除了要考虑实际的业务逻辑之外，还需要额外考虑对接口访问的控制处理。

- 无法直接复用既有接口。

  	当我们需要对一个即有的集群内访问接口，实现外部服务访问时，我们不得不通过在原有接口上增加校验逻辑，或增加一个代理调用来实现权限控制，无法直接复用原有的接口。



面对类似上面的问题，我们要如何解决呢？答案是：服务网关！



为了解决上面这些问题，我们需要将权限控制这样的东西从我们的服务单元中抽离出去，而最适合这些逻辑的地方就是处于对外访问最前端的地方，我们需要一个更强大一些的均衡负载器的 服务网关。

 

服务网关是微服务架构中一个不可或缺的部分。通过服务网关统一向外系统提供REST API的过程中，除了具备`服务路由`、`均衡负载`功能之外，它还具备了`权限控制`等功能。Spring Cloud Netflix中的Zuul就担任了这样的一个角色，为微服务架构提供了前门保护的作用，同时将权限控制这些较重的非业务逻辑内容迁移到服务路由层面，使得服务集群主体能够具备更高的可复用性和可测试性。



#### 1.简介

官网：https://github.com/Netflix/zuul

 ![](C:/Users/Murphy/Pictures/1525675037152.png)

Zuul：维基百科

电影《捉鬼敢死队》中的怪兽，Zuul，在纽约引发了巨大骚乱。

事实上，在微服务架构中，Zuul就是守门的大Boss！一夫当关，万夫莫开！

![1525675168152](C:/Users/Murphy/Pictures/1525675168152.png)



#### 2.Zuul加入后的架构

 ![1525675648881](C:/Users/Murphy/Pictures/1525675648881.png)

不管是来自于客户端（PC或移动端）的请求，还是服务内部调用。一切对服务的请求都会经过Zuul这个网关，然后再由网关来实现 鉴权、动态路由等等操作。Zuul就是我们服务的统一入口。

### 20.zuul的基本使用

#### 1.新建工程

填写基本信息：

![1529112749084](C:/Users/Murphy/Pictures/1529112749084.png)

添加Zuul依赖：

![1529112691169](C:/Users/Murphy/Pictures/1529112691169.png)



#### 2.编写配置

```yaml
server:
  port: 10010 #服务端口
spring:
  application:
    name: api-gateway #指定服务名
```



#### 3.编写引导类

通过`@EnableZuulProxy `注解开启Zuul的功能：

```java
@SpringBootApplication
@EnableZuulProxy // 开启网关功能
public class ItcastZuulApplication {

    public static void main(String[] args) {
        SpringApplication.run(ItcastZuulApplication.class, args);
    }
}
```



#### 4.编写路由规则

我们需要用Zuul来代理service-provider服务，先看一下控制面板中的服务状态：

![1542672192226](C:/Users/Murphy/Pictures/1542672192226.png)

- ip为：127.0.0.1
- 端口为：8081

映射规则：

```yaml
server:
  port: 10010 #服务端口
spring:
  application:
    name: api-gateway #指定服务名
zuul:
  routes:
    service-provider: # 这里是路由id，随意写
      path: /service-provider/** # 这里是映射路径
      url: http://127.0.0.1:8081 # 映射路径对应的实际url地址
```

我们将符合`path` 规则的一切请求，都代理到 `url`参数指定的地址

本例中，我们将 `/service-provider/**`开头的请求，代理到http://127.0.0.1:8081



#### 5.启动测试

访问的路径中需要加上配置规则的映射路径，我们访问：http://127.0.0.1:10010/service-provider/user/1

![1543054030005](C:/Users/Murphy/Pictures/1543054030005.png)



### 21.zuul的四种路由

在刚才的路由规则中，我们把路径对应的服务地址写死了！如果同一服务有多个实例的话，这样做显然就不合理了。我们应该根据服务的名称，去Eureka注册中心查找 服务对应的所有实例列表，然后进行动态路由才对！

对itcast-zuul工程修改优化：

#### 1.添加Eureka客户端依赖

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>
```



#### 2.添加Eureka配置，获取服务信息

```yaml
eureka:
  client:
    registry-fetch-interval-seconds: 5 # 获取服务列表的周期：5s
    service-url:
      defaultZone: http://127.0.0.1:10086/eureka
```



#### 3.开启Eureka客户端发现功能

```java
@SpringBootApplication
@EnableZuulProxy // 开启Zuul的网关功能
@EnableDiscoveryClient
public class ZuulDemoApplication {

	public static void main(String[] args) {
		SpringApplication.run(ZuulDemoApplication.class, args);
	}
}
```



#### 4.修改映射配置，通过服务名称获取

因为已经有了Eureka客户端，我们可以从Eureka获取服务的地址信息，因此映射时无需指定IP地址，而是通过服务名称来访问，而且Zuul已经集成了Ribbon的负载均衡功能。

```yaml
zuul:
  routes:
    service-provider: # 这里是路由id，随意写
      path: /service-provider/** # 这里是映射路径
      serviceId: service-provider # 指定服务名称
```



#### 5.启动测试

再次启动，这次Zuul进行代理时，会利用Ribbon进行负载均衡访问：

![1543054030005](C:/Users/Murphy/Pictures/1543054030005-16363555939611.png)



#### 5.简化的路由配置

在刚才的配置中，我们的规则是这样的：

- `zuul.routes.<route>.path=/xxx/**`： 来指定映射路径。`<route>`是自定义的路由名
- `zuul.routes.<route>.serviceId=service-provider`：来指定服务名。

而大多数情况下，我们的`<route>`路由名称往往和服务名会写成一样的。因此Zuul就提供了一种简化的配置语法：`zuul.routes.<serviceId>=<path>`

比方说上面我们关于service-provider的配置可以简化为一条：

```yaml
zuul:
  routes:
    service-provider: /service-provider/** # 这里是映射路径
```

省去了对服务名称的配置。



#### 6.默认的路由规则

在使用Zuul的过程中，上面讲述的规则已经大大的简化了配置项。但是当服务较多时，配置也是比较繁琐的。因此Zuul就指定了默认的路由规则：

- 默认情况下，一切服务的映射路径就是服务名本身。例如服务名为：`service-provider`，则默认的映射路径就	是：`/service-provider/**`

也就是说，刚才的映射规则我们完全不配置也是OK的，不信就试试看。



#### 7.路由前缀

配置示例：

```yaml
zuul:
  routes:
    service-provider: /service-provider/**
    service-consumer: /service-consumer/**
  prefix: /api # 添加路由前缀
```

我们通过`zuul.prefix=/api`来指定了路由的前缀，这样在发起请求时，路径就要以/api开头。

![1543054221479](C:/Users/Murphy/Pictures/1543054221479.png)



### 22.zuul过滤器

Zuul作为网关的其中一个重要功能，就是实现请求的鉴权。而这个动作我们往往是通过Zuul提供的过滤器来实现的。

### 3.8.1.ZuulFilter

ZuulFilter是过滤器的顶级父类。在这里我们看一下其中定义的4个最重要的方法：

```java
public abstract ZuulFilter implements IZuulFilter{

    abstract public String filterType();

    abstract public int filterOrder();
    
    boolean shouldFilter();// 来自IZuulFilter

    Object run() throws ZuulException;// IZuulFilter
}
```

- `shouldFilter`：返回一个`Boolean`值，判断该过滤器是否需要执行。返回true执行，返回false不执行。
- `run`：过滤器的具体业务逻辑。
- `filterType`：返回字符串，代表过滤器的类型。包含以下4种：
  - `pre`：请求在被路由之前执行
  - `route`：在路由请求时调用
  - `post`：在route和errror过滤器之后调用
  - `error`：处理请求时发生错误调用
- `filterOrder`：通过返回的int值来定义过滤器的执行顺序，数字越小优先级越高。



### 3.8.2.过滤器执行生命周期

这张是Zuul官网提供的请求生命周期图，清晰的表现了一个请求在各个过滤器的执行顺序。

![1529152248172](C:/Users/Murphy/Pictures/1529152248172.png)

正常流程：

- 请求到达首先会经过pre类型过滤器，而后到达route类型，进行路由，请求就到达真正的服务提供者，执行请求，返回结果后，会到达post过滤器。而后返回响应。

异常流程：

- 整个过程中，pre或者route过滤器出现异常，都会直接进入error过滤器，在error处理完毕后，会将请求交给POST过滤器，最后返回给用户。
- 如果是error过滤器自己出现异常，最终也会进入POST过滤器，将最终结果返回给请求客户端。
- 如果是POST过滤器出现异常，会跳转到error过滤器，但是与pre和route不同的是，请求不会再到达POST过滤器了。

所有内置过滤器列表：

 ![](C:/Users/Murphy/Pictures/1525682427811.png)



### 3.8.3.使用场景

场景非常多：

- 请求鉴权：一般放在pre类型，如果发现没有访问权限，直接就拦截了
- 异常处理：一般会在error类型和post类型过滤器中结合来处理。
- 服务调用时长统计：pre和post结合使用。



## 3.9.自定义过滤器

接下来我们来自定义一个过滤器，模拟一个登录的校验。基本逻辑：如果请求中有access-token参数，则认为请求有效，放行。

### 3.9.1.定义过滤器类

 ![1529136926454](C:/Users/Murphy/Pictures/1529136926454.png)

内容：

```java
@Component
public class LoginFilter extends ZuulFilter {

    /**
     * 过滤器的类型:pre route post error
     * @return
     */
    @Override
    public String filterType() {
        return "pre";
    }

    /**
     * 执行顺序，返回值越小，优先级越高
     * @return
     */
    @Override
    public int filterOrder() {
        return 10;
    }

    /**
     * 是否执行run方法
     * true：执行run方法
     * @return
     */
    @Override
    public boolean shouldFilter() {
        return true;
    }

    /**
     * 编写过滤器的业务逻辑
     * @return
     * @throws ZuulException
     */
    @Override
    public Object run() throws ZuulException {
        //初始化context上下文对象，servlet spring
        RequestContext context = RequestContext.getCurrentContext();

        //获取request参数
        HttpServletRequest request = context.getRequest();

        //获取参数
        String token = request.getParameter("token");
        if (StringUtils.isBlank(token)) {
            //拦截,不转发请求
            context.setSendZuulResponse(false);
            //响应状态码，401-身份未认证
            context.setResponseStatusCode(HttpStatus.SC_UNAUTHORIZED);
            //设置响应的提示
            context.setResponseBody("request error");
        }

        //返回值为null，就代表该过滤器什么都不做
        return null;
    }
}
```



### 3.9.2.测试

没有token参数时，访问失败：

![1529161460740](C:/Users/Murphy/Pictures/1529161460740.png)

添加token参数后：

![1529161252733](C:/Users/Murphy/Pictures/1529161252733.png)



## 3.10.负载均衡和熔断

Zuul中默认就已经集成了Ribbon负载均衡和Hystix熔断机制。但是所有的超时策略都是走的默认值，比如熔断超时时间只有1S，很容易就触发了。因此建议我们手动进行配置：

```yaml
hystrix:
  command:
    default:
      execution:
        isolation:
          thread:
            timeoutInMilliseconds: 2000 # 设置hystrix的超时时间为6000ms
```



### 23.总结

```
zuul
	1.引入zuul的启动器
	2.配置：
		zuul.routes.<路由名称>.path=/service-provider/**
		zuul.routes.<路由名称>.url=http://localhost:8082
		
		zuul.routes.<路由名称>.path=/service-provider/**
		zuul.routes.<路由名称>.serviceId=service-provider
		
		zuul.routes.服务名=/service-provider/**   *******************
		
		不用配置，默认就是服务id开头路径
		
	3.@EnableZuulProxy
	
	过滤器：
		创建一个类继承ZuulFilter基类
		重写四个方法
			filterType：pre route post error
			filterOrder：返回值越小优先级越高
			shouldFilter：是否执行run方法。true执行
			run：具体的拦截逻辑
```

# 通用Mapper

## 1.  通用Mapper

### 1.1. 通用Mapper介绍

通用 Mapper 提供了一些通用的方法，这些通用方法是以接口的形式提供的，它主要简化了我们工作中常做的单表操作问题，让MyBatis由面向过程转换成了面向对象的操作方式，当然，MyBatis编写SQL面向过程操作和通用Mapper面向对象操作可以共存。

### 1.2. 配置介绍

使用通用通用Mapper首先需要引入依赖包。

```xml
<!--通用Mapper-->
<dependency>
    <groupId>tk.mybatis</groupId>
    <artifactId>mapper</artifactId>
</dependency>
```

替换MyBatis集成Spring的包扫描bean，修改pinyougou-mapper项目中spring-mybatis.xml

替换前：

```
<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"
   p:basePackage="com.pinyougou.mapper"
     p:sqlSessionFactoryBeanName="sqlSessionFactoryBean" />

```

替换后：

```
<bean class="tk.mybatis.spring.mapper.MapperScannerConfigurer"
     p:basePackage="com.pinyougou.mapper"
     p:sqlSessionFactoryBeanName="sqlSessionFactoryBean">
<!--通用接口-->
 <property name="properties">
      <value>
         mappers=tk.mybatis.mapper.common.Mapper
      </value>
   </property>
</bean>
```

### 1.3. MyBatis+通用Mapper+Spring集成测试

在pinyougou-sellergoods-service编写测试类

```java
package com.pinyougou;
import org.junit.Before;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
public class MapperTest {
    private ApplicationContext act;
    @Before
    public void init(){
        act = new ClassPathXmlApplicationContext("classpath:spring/spring.xml");
    }
    @Test
    public void testSpring(){
        //获取容器中所有的Bean
        String[] names = act.getBeanDefinitionNames();

        for (String name : names) {
            System.out.println(name);
        }
    }
}
```

### 1.4. 通用Mapper的使用

#### 1.4.1.  增加操作

##### 1.4.1.1.    不忽略空值-insert

```java
/***
 * 增加数据
 * 不忽略空值
 */
@Test
public void testInsert(){
    Brand brand = new Brand();
    brand.setName("测试");
    //brand.setFirstChar("C");
    int acount = brandMapper.insert(brand);
    System.out.println(acount);
}

```

当Brand的id、firstChar为空的时候，SQL语句仍然执行了插入操作。

##### 1.4.1.2.    忽略空值-insertSelective

```java
/***
 * 增加数据
 * 忽略空值
 */
@Test
public void testInsertSelective(){
    Brand brand = new Brand();
    brand.setName("测试");
    //brand.setFirstChar("C");
    int acount = brandMapper.insertSelective(brand);
    System.out.println(acount);
}

```

当Brand的id、firstChar为空的时候，SQL语句没有执行了插入操作。

#### 1.4.2.  修改操作

##### 1.4.2.1.    根据主键修改数据-不忽略空值

```java
/**
 * 需改操作
 * 不忽略空值
 */
@Test
public void testUpdateByPrimaryKey(){
    Brand brand = new Brand();
    brand.setId(25L);
    //brand.setName("测试");
    brand.setFirstChar("S");
    //根据主键修改数据
    int mcount = brandMapper.updateByPrimaryKey(brand);
    System.out.println(mcount);
}
```

当name为空的时候，SQL语句仍然执行修改。

##### 1.4.2.2.    根据主键修改数据-忽略空值

```java
/**
 * 修改操作
 * 忽略空值
 */
@Test
public void testUpdateByPrimaryKeySelective(){
    Brand brand = new Brand();
    brand.setId(25L);
    brand.setName("测试");
    //brand.setFirstChar("S");
    //根据主键修改数据
    int mcount = brandMapper.updateByPrimaryKeySelective(brand);
    System.out.println(mcount);
}

```

当name为空的时候，SQL语句不执行修改。

##### 1.4.2.3.    构造条件修改数据-不忽略空值

```java
/**
 * 构造条件执行修改
 * 不忽略空值
 */
@Test
public void testUpdateByExample(){
    //firstChar=S
    Brand brand = new Brand();
    brand.setName("测试");

    //创建Example对象
    Example example = new Example(Brand.class);

    //Criteria 用来构造约束条件
    Example.Criteria criteria = example.createCriteria();

    //第一个参数是Brand对应的属性，第二个参数是属性约束值   相当于 where firstChar=S
    criteria.andEqualTo("firstChar","S");

    //条件修改数据
    int mcount = brandMapper.updateByExample(brand,example);
    System.out.println(mcount);
}
```

criteria.andEqualTo("firstChar","S"); 转换成了这里的SQL语句 where(first_char=?)，这里firstChart为空，但SQL语句仍然执行了修改。

##### 1.4.2.4.    构造条件修改数据-忽略空值

```java
/**
 * 构造条件执行修改
 * 忽略空值
 */
@Test
public void testUpdateByExampleSelective(){
    //firstChar=S
    Brand brand = new Brand();
    brand.setFirstChar("S");
    //创建Example对象
    Example example = new Example(Brand.class);
    //Criteria 用来构造约束条件
    Example.Criteria criteria = example.createCriteria();

    //第一个参数是Brand对应的属性，第二个参数是属性约束值   相当于 where name='深圳市黑马训练营'
    criteria.andEqualTo("name","测试");

    //条件修改数据
    int mcount = brandMapper.updateByExampleSelective(brand,example);
    System.out.println(mcount);
}
```

这里name为空，SQL语句并没有做出修改操作。

#### 1.4.3.  查询操作

##### 1.4.3.1.    根据主键查询

```java
/***
 * 根据主键查询
 */
@Test
public void testSelectByPrimaryKey(){
    long id = 25L;
    Brand brand = brandMapper.selectByPrimaryKey(id);
    System.out.println(brand);
}
```

##### 1.4.3.2.    查询单条记录

```java
/***
 * 查询单个记录
 */
@Test
public void testSelectOne(){
    Brand brand = new Brand();
    brand.setId(25L);
    brand.setName("测试");
    Brand brand1 = brandMapper.selectOne(brand);
    System.out.println(brand1);
}
```

注意：

这里需要注意一下，复合该条件的数据，数据库里必须<=1条，如果大于了1条数据，则会报错

```
TooManyResultsException: Expected one result (or null) to be returned by selectOne(), but found: 3
```

##### 1.4.3.3.    根据条件查询-Example

```java
/***
 * 根据条件执行查询
 */
@Test
public void testExample(){
    Example example = new Example(Brand.class);
    Example.Criteria criteria = example.createCriteria();
    //id IN(1,2,5,6)
    List<Long> ids = new ArrayList<Long>();
    ids.add(1L);
    ids.add(2L);
    ids.add(5L);
    ids.add(6L);

    //第二个参数是个集合对象即可，注意集合对象这里对应的类型虽然是Object，不过要和你数据库对应的类型保持一致
    criteria.andIn("id",ids);

    //执行查询
    List<Brand> brands = brandMapper.selectByExample(example);

    for (Brand brand : brands) {
        System.out.println(brand);
    }
}

```

##### 1.4.3.4.    根据条件查询-JavaBean

```java
/***
 * 根据条件查询
 * 入参：JavaBean
 */
@Test
public void testSelect(){
    Brand brand = new Brand();
    brand.setId(25L);
    brand.setName("测试");
    //把brand作为查询条件，这里会忽略空值
    List<Brand> brands = brandMapper.select(brand);
    for (Brand bd : brands) {
        System.out.println(bd);
    }
}

```

##### 1.4.3.5.    查询所有

```java
/***
 * 插询所有
 */
@Test
public void testSelectAll(){
    //执行查询
    List<Brand> brands = brandMapper.selectAll();

    for (Brand brand : brands) {
        System.out.println(brand);
    }
}

```

##### 1.4.3.6.    统计查询

```java
/***
 * 统计查询-总记录数
 */
@Test
public void testSelectCount(){
    //查询总记录数
    int count = brandMapper.selectCount(null);
    System.out.println(count);
} 
```

#### 1.4.4.  删除操作

##### 1.4.4.1.    根据主键删除

```java
/***
 * 根据ID删除
 */
@Test
public void testDeleteByPrimaryKey(){
    long id = 25;
    int dcount = brandMapper.deleteByPrimaryKey(id);
    System.out.println(dcount);
}
```

##### 1.4.4.2.    条件删除-Example

```java
/***
 * 条件删除
 */
@Test
public void testDeleteByExample(){
    Example example = new Example(Brand.class);
    Example.Criteria criteria = example.createCriteria();
    //where id between 23 and 28
    criteria.andBetween("id",23L,28L);
    //根据条件删除
    int dcount = brandMapper.deleteByExample(example);
    System.out.println(dcount);
}
```

##### 1.4.4.3.    条件删除-JavaBean

```java
/***
 * 条件删除
 * 入参：javaBean
 */
@Test
public void testDelete(){
    Brand brand = new Brand();
    brand.setName("阿凡达");
    //根据条件删除
    int dcount = brandMapper.delete(brand);
    System.out.println(dcount);
}
```

## 2.  分页工具

在做项目的时候，分页属于很常见的，但通常都有繁琐的封装。这里提供了一个通用分页插件pagehelper，能满足我们工作中的基本需求。

### 2.1. 配置介绍

首先需要引入对应的依赖

```xml
<!--分页工具包-->
<dependency>
    <groupId>com.github.pagehelper</groupId>
    <artifactId>pagehelper</artifactId>
</dependency>
```

然后需要配置一个mybatis拦截器，在pinyougou-mapper项目的mybatis.xml中加入如下插件代码

```xml
<plugins>
    <!-- com.github.pagehelper为PageInterceptor类所在包名 -->
    <plugin interceptor="com.github.pagehelper.PageInterceptor">
        <property name="reasonable" value="true"/>
    </plugin>
</plugins>

```

### 2.2. 分页类介绍

PageInfo类既包含我们工作中的分页信息，也包含分页查询的集合对象，所以很实用，如下代码：

```java
public class PageInfo<T> implements Serializable {
    private static final long serialVersionUID = 1L;
    //当前页
    private int pageNum;
    //每页的数量
    private int pageSize;
    //当前页的数量
    private int size;
    //当前页面第一个元素在数据库中的行号
    private int startRow;
    //当前页面最后一个元素在数据库中的行号
    private int endRow;
    //总记录数
    private long total;
    //总页数
    private int pages;
    //结果集
    private List<T> list;
    //前一页
    private int prePage;
    //下一页
    private int nextPage;
    //是否为第一页
    private boolean isFirstPage = false;
    //是否为最后一页
    private boolean isLastPage = false;
    //是否有前一页
    private boolean hasPreviousPage = false;
    //是否有下一页
    private boolean hasNextPage = false;
    //导航页码数
    private int navigatePages;
    //所有导航页号
    private int[] navigatepageNums;
    //导航条上的第一页
    private int navigateFirstPage;
    //导航条上的最后一页
    private int navigateLastPage;
     //........略
}

```

### 2.3. 分页插件的使用

分页插件的使用很简单，配置好了后，直接调用PageHelper的静态方法startPage即可实现分页，其他查询正常写就行了，注意一点，调用startPage的方法必须写在执行查询selectAll()前面，否则分页无效。

```java
/**
 * 分页测试
 */
@Test
public void testPage(){
    //page 当前页    size 每页显示多少条
    int page = 1,size=10;
    //分页处理,只需要调用PageHelper.startPage静态方法即可。S
    PageHelper.startPage(page,size);

    //查询
    List<Brand> brands = brandMapper.selectAll();

    //获取分页信息,注意这里传入了brands集合对象
    PageInfo<Brand> pageInfo = new PageInfo<Brand>(brands);
    System.out.println(pageInfo);
}
```

# 全文检索

### 全文检索:lucene

Lucene是一个基于Java开发全文检索工具包。

### 全文检索:ElasticSearch

1.1 什么是ElasticSearch

Elaticsearch，简称为es， es是一个开源的高扩展的分布式全文检索引擎，它可以近乎实时的存储、检索数据；本身扩展性很好，可以扩展到上百台服务器，处理PB级别的数据。es也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。

1.2 ElasticSearch的使用案例

- 2013年初，GitHub抛弃了Solr，采取ElasticSearch 来做PB级的搜索。 “GitHub使用ElasticSearch搜索20TB的数据，包括13亿文件和1300亿行代码”
- 维基百科：启动以elasticsearch为基础的核心搜索架构
- SoundCloud：“SoundCloud使用ElasticSearch为1.8亿用户提供即时而精准的音乐搜索服务”
- 百度：百度目前广泛使用ElasticSearch作为文本数据分析，采集百度所有服务器上的各类指标数据及用户自定义数据，通过对各种数据进行多维分析展示，辅助定位分析实例异常或业务层面异常。目前覆盖百度内部20多个业务线（包括casio、云分析、网盟、预测、文库、直达号、钱包、风控等），单集群最大100台机器，200个ES节点，每天导入30TB+数据
- 新浪使用ES 分析处理32亿条实时日志
- 阿里使用ES 构建挖财自己的日志采集和分析体系

1.3 ElasticSearch对比Solr

- Solr 利用 Zookeeper 进行分布式管理，而 Elasticsearch 自身带有分布式协调管理功能;
- Solr 支持更多格式的数据，而 Elasticsearch 仅支持json文件格式；
- Solr 官方提供的功能更多，而 Elasticsearch 本身更注重于核心功能，高级功能多有第三方插件提供；
- Solr 在传统的搜索应用中表现好于 Elasticsearch，但在处理实时搜索应用时效率明显低于 Elasticsearch